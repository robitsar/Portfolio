{"version":3,"file":"2104.60b16a03f27190035834.js?v=60b16a03f27190035834","mappings":"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","sources":["webpack://@jupyterlab/application-top/./node_modules/@lezer/common/dist/index.js"],"sourcesContent":["// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node.\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\nclass NodeProp {\n    /// Create a new node prop type.\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// This is meant to be used with\n    /// [`NodeSet.extend`](#common.NodeSet.extend) or\n    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    /// prop values for each node type in the set. Takes a [match\n    /// object](#common.NodeType^match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages in mixed-language parsers.\nNodeProp.mounted = new NodeProp({ perNode: true });\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\nclass MountedTree {\n    constructor(\n    /// The inner tree.\n    tree, \n    /// If this is null, this tree replaces the entire node (it will\n    /// be included in the regular iteration instead of its host\n    /// node). If not, only the given ranges are considered to be\n    /// covered by this tree. This is used for trees that are mixed in\n    /// a way that isn't strictly hierarchical. Such mounted trees are\n    /// only entered by [`resolveInner`](#common.Tree.resolveInner)\n    /// and [`enter`](#common.SyntaxNode.enter).\n    overlay, \n    /// The parser used to create this subtree.\n    parser) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n}\nconst noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nclass NodeType {\n    /// @internal\n    constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    id, \n    /// @internal\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /// Define a node type.\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |\n            (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    prop(prop) { return this.props[prop.id]; }\n    /// True when this is the top node of a grammar.\n    get isTop() { return (this.flags & 1 /* NodeFlag.Top */) > 0; }\n    /// True when this node is produced by a skip rule.\n    get isSkipped() { return (this.flags & 2 /* NodeFlag.Skipped */) > 0; }\n    /// Indicates whether this is an error node.\n    get isError() { return (this.flags & 4 /* NodeFlag.Error */) > 0; }\n    /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n    get isAnonymous() { return (this.flags & 8 /* NodeFlag.Anonymous */) > 0; }\n    /// Returns true when this node's name or one of its\n    /// [groups](#common.NodeProp^group) matches the given string.\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#common.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\nclass NodeSet {\n    /// Create a set with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    constructor(\n    /// The node types in this set, by id.\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /// Create a copy of this set with some node properties added. The\n    /// arguments to this method can be created with\n    /// [`NodeProp.add`](#common.NodeProp.add).\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/// Options that control iteration. Can be combined with the `|`\n/// operator to enable multiple ones.\nvar IterMode;\n(function (IterMode) {\n    /// When enabled, iteration will only visit [`Tree`](#common.Tree)\n    /// objects, not nodes packed into\n    /// [`TreeBuffer`](#common.TreeBuffer)s.\n    IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /// Enable this to make iteration include anonymous nodes (such as\n    /// the nodes that wrap repeated grammar constructs into a balanced\n    /// tree).\n    IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /// By default, regular [mounted](#common.NodeProp^mounted) nodes\n    /// replace their base node in iteration. Enable this to ignore them\n    /// instead.\n    IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /// This option only applies in\n    /// [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    /// library to not enter mounted overlays if one covers the given\n    /// position.\n    IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\nclass Tree {\n    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    constructor(\n    /// The type of the top node.\n    type, \n    /// This node's child nodes.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree\n    length, \n    /// Per-node [node props](#common.NodeProp) to associate with this node.\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /// @internal\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /// @internal\n    toString() {\n        let mounted = this.prop(NodeProp.mounted);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /// Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    /// the tree. Mode can be used to [control](#common.IterMode) which\n    /// nodes the cursor visits.\n    cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /// Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    /// at the given position and side (see\n    /// [`moveTo`](#common.TreeCursor.moveTo).\n    cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n    /// tree.\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /// Get the [syntax node](#common.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n    ///\n    /// Note that this will not enter\n    /// [overlays](#common.MountedTree.overlay), and you often want\n    /// [`resolveInner`](#common.Tree.resolveInner) instead.\n    resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /// Like [`resolve`](#common.Tree.resolve), but will enter\n    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    /// pointing into the innermost overlaid tree at the given position\n    /// (with parent links going through all parent structure, including\n    /// the host trees).\n    resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, that node will\n    /// not have its children iterated over (or `leave` called).\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous);;) {\n            let entered = false;\n            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild())\n                    continue;\n                entered = true;\n            }\n            for (;;) {\n                if (entered && leave && !c.type.isAnonymous)\n                    leave(c);\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                entered = true;\n            }\n        }\n    }\n    /// Get the value of the given [node prop](#common.NodeProp) for this\n    /// node. Works with both per-node and per-type props.\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    /// format that can be passed to the [`Tree`](#common.Tree)\n    /// constructor.\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /// Balance the direct children of this tree, producing a copy of\n    /// which may have children grouped into subtrees with type\n    /// [`NodeType.none`](#common.NodeType^none).\n    balance(config = {}) {\n        return this.children.length <= 8 /* Balance.BranchFactor */ ? this :\n            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    static build(data) { return buildTree(data); }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it).\nclass TreeBuffer {\n    /// Create a tree buffer.\n    constructor(\n    /// The buffer's content.\n    buffer, \n    /// The total length of the group of nodes in the buffer.\n    length, \n    /// The node set used in this buffer.\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /// @internal\n    get type() { return NodeType.none; }\n    /// @internal\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /// @internal\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /// @internal\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /// @internal\n    slice(startI, endI, from) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI), len = 0;\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            let to = copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n            len = Math.max(len, to);\n        }\n        return new TreeBuffer(copy, len, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Side.Before */: return from < pos;\n        case -1 /* Side.AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Side.Around */: return from < pos && to > pos;\n        case 1 /* Side.AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* Side.After */: return to > pos;\n        case 4 /* Side.DontCare */: return true;\n    }\n}\nfunction enterUnfinishedNodesBefore(node, pos) {\n    let scan = node.childBefore(pos);\n    while (scan) {\n        let last = scan.lastChild;\n        if (!last || last.to != scan.to)\n            break;\n        if (last.type.isError && last.from == last.to) {\n            node = scan;\n            scan = last.prevSibling;\n        }\n        else {\n            scan = last;\n        }\n    }\n    return node;\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while (node.from == node.to ||\n        (side < 1 ? node.from >= pos : node.from > pos) ||\n        (side > -1 ? node.to <= pos : node.to < pos)) {\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent)\n            return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays)\n        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)\n                node = parent;\n        }\n    for (;;) {\n        let inner = node.enter(pos, side, mode);\n        if (!inner)\n            return node;\n        node = inner;\n    }\n}\nclass TreeNode {\n    constructor(_tree, from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this._tree.type; }\n    get name() { return this._tree.type.name; }\n    get to() { return this.from + this._tree.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) &&\n                        next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */); }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 ? from <= rPos : from < rPos) &&\n                    (side < 0 ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return this._tree; }\n    toTree() { return this._tree; }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    /// @internal\n    toString() { return this._tree.toString(); }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        while (!cur.type.is(before))\n            if (!cur.nextSibling())\n                return result;\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for (let p = node.parent; i >= 0; p = p.parent) {\n        if (!p)\n            return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name)\n                return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode {\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    constructor(context, _parent, index) {\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Side.Before */); }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1];\n            children.push(buffer.slice(startI, endI, from));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    /// @internal\n    toString() { return this.context.buffer.childString(this.index); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nclass TreeCursor {\n    /// Shorthand for `.type.name`.\n    get name() { return this.type.name; }\n    /// @internal\n    constructor(node, \n    /// @internal\n    mode = 0) {\n        this.mode = mode;\n        /// @internal\n        this.buffer = null;\n        this.stack = [];\n        /// @internal\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /// @internal\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /// @internal\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n    firstChild() { return this.enterChild(1, 0, 4 /* Side.DontCare */); }\n    /// Move the cursor to this node's last child.\n    lastChild() { return this.enterChild(-1, 0, 4 /* Side.DontCare */); }\n    /// Move the cursor to the first child that ends after `pos`.\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* Side.After */); }\n    /// Move to the last child that starts before `pos`.\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Side.Before */); }\n    /// Move the cursor to the child around `pos`. If side is -1 the\n    /// child may end at that position, when 1 it may start there. This\n    /// will also enter [overlaid](#common.MountedTree.overlay)\n    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    /// set to false.\n    enter(pos, side, mode = this.mode) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /// Move to the node's parent node, if this isn't the top node.\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /// @internal\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;\n    }\n    /// Move to this node's next sibling, if any.\n    nextSibling() { return this.sibling(1); }\n    /// Move to this node's previous sibling, if any.\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\n                    let child = parent._tree.children[i];\n                    if ((this.mode & IterMode.IncludeAnonymous) ||\n                        child instanceof TreeBuffer ||\n                        !child.type.isAnonymous ||\n                        hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty or `enter` is false, its next sibling or\n    /// the next sibling of the first parent node that has one.\n    next(enter = true) { return this.move(1, enter); }\n    /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by its last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n    prev(enter = true) { return this.move(-1, enter); }\n    /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    /// position.\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /// Get the [tree](#common.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#common.TreeBuffer).\n    get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /// Iterate over the current node and all its descendants, calling\n    /// `enter` when entering a node and `leave`, if given, when leaving\n    /// one. When `enter` returns `false`, any children of that node are\n    /// skipped, and `leave` isn't called for it.\n    iterate(enter, leave) {\n        for (let depth = 0;;) {\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (this.nextSibling())\n                    break;\n                if (!depth)\n                    return;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /// Test whether the current node matches a given context—a sequence\n    /// of direct parent node names. Empty strings in the context array\n    /// are treated as wildcards.\n    matchContext(context) {\n        if (!this.buffer)\n            return matchNodeContext(this.node, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n            if (d < 0)\n                return matchNodeContext(this.node, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name)\n                    return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while (size < 0) {\n            cursor.next();\n            if (size == -1 /* SpecialRecord.Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* SpecialRecord.ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* SpecialRecord.LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function makeBalanced(type) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* SpecialRecord.ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* SpecialRecord.LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children) {\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/// Provides a way to associate values with pieces of trees. As long\n/// as that part of the tree is reused, the associated values can be\n/// retrieved from an updated tree.\nclass NodeWeakMap {\n    constructor() {\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner)\n            this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /// Set the value for this syntax node.\n    set(node, value) {\n        if (node instanceof BufferNode)\n            this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode)\n            this.map.set(node.tree, value);\n    }\n    /// Retrieve value for this syntax node, if it exists in the map.\n    get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)\n            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /// Set the value for the node that a cursor currently points to.\n    cursorSet(cursor, value) {\n        if (cursor.buffer)\n            this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else\n            this.map.set(cursor.tree, value);\n    }\n    /// Retrieve the value for the node that a cursor currently points\n    /// to.\n    cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n\n/// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\nclass TreeFragment {\n    /// Construct a tree fragment. You'll usually want to use\n    /// [`addTree`](#common.TreeFragment^addTree) and\n    /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    /// calling this directly.\n    constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    from, \n    /// The end of the unchanged range.\n    to, \n    /// The tree that this fragment is based on.\n    tree, \n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);\n    }\n    /// Whether the start of the fragment represents the start of a\n    /// parse, or the end of a change. (In the second case, it may not\n    /// be safe to reuse some nodes at the start, depending on the\n    /// parsing algorithm.)\n    get openStart() { return (this.open & 1 /* Open.Start */) > 0; }\n    /// Whether the end of the fragment represents the end of a\n    /// full-document parse, or the start of a change.\n    get openEnd() { return (this.open & 2 /* Open.End */) > 0; }\n    /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the resulting\n    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    /// true.\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/// A superclass that parsers should extend.\nclass Parser {\n    /// Start a parse, returning a [partial parse](#common.PartialParse)\n    /// object. [`fragments`](#common.TreeFragment) can be passed in to\n    /// make the parse incremental.\n    ///\n    /// By default, the entire input is parsed. You can pass `ranges`,\n    /// which should be a sorted array of non-empty, non-overlapping\n    /// ranges, to parse only those ranges. The tree returned in that\n    /// case will start at `ranges[0].from`.\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /// Run a full parse, returning the resulting tree.\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, ranges) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.ranges = ranges;\n    }\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({ perNode: true });\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null)\n                for (let inner of this.inner)\n                    inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null)\n                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let pos = this.input.length;\n        for (let i = this.innerDone; i < this.inner.length; i++) {\n            if (this.inner[i].ranges[0].from < pos)\n                pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {\n            let enter = true, range;\n            if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Cover.Full */;\n            }\n            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n                if (!cursor.tree)\n                    materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n                    if (ranges.length)\n                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));\n                    if (!nest.overlay)\n                        enter = false;\n                    else if (ranges.length)\n                        covered = { ranges, depth: 0, prev: covered };\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to)\n                    overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n                if (covered)\n                    covered.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length)\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth)\n                        covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered) {\n        if (range.from >= to)\n            break;\n        if (range.to > from)\n            return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;\n    }\n    return 0 /* Cover.None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1];\n        nodes.push(buf.slice(startI, endI, from));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, depth = 0;\n    // Scan up to the nearest tree\n    do {\n        cursor.parent();\n        depth++;\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let i = 0, base = cursor.tree, off = 0;\n    for (;; i++) {\n        off = base.positions[i] + cursor.from;\n        if (off <= node.from && off + base.children[i].length >= node.to)\n            break;\n    }\n    let buf = base.children[i], b = buf.buffer;\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length) {\n        let i = startI;\n        while (b[i + 2] + off <= node.from)\n            i = b[i + 3];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, i, children, positions, innerOffset);\n        let from = b[i + 1], to = b[i + 2];\n        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;\n        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);\n    // Move the cursor back to the target node\n    for (let d = 0; d <= depth; d++)\n        cursor.childAfter(node.from);\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curTo)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\nexport { DefaultBufferLength, IterMode, MountedTree, NodeProp, NodeSet, NodeType, NodeWeakMap, Parser, Tree, TreeBuffer, TreeCursor, TreeFragment, parseMixed };\n"],"names":["DefaultBufferLength","nextPropID","Range","constructor","from","to","this","NodeProp","config","id","perNode","deserialize","Error","add","match","RangeError","NodeType","type","result","undefined","closedBy","str","split","openedBy","group","contextHash","lookAhead","mounted","MountedTree","tree","overlay","parser","noProps","Object","create","name","props","flags","static","spec","length","top","skipped","error","src","Array","isArray","prop","isTop","isSkipped","isError","isAnonymous","is","indexOf","map","direct","node","groups","i","found","none","NodeSet","types","extend","newTypes","newProps","source","assign","push","CachedNode","WeakMap","CachedInnerNode","IterMode","Tree","children","positions","value","toString","ch","test","JSON","stringify","cursor","mode","TreeCursor","topNode","cursorAt","pos","side","scope","get","moveTo","set","_tree","TreeNode","resolve","resolveNode","resolveInner","iterate","enter","leave","c","IncludeAnonymous","entered","firstChild","nextSibling","parent","propValues","balance","balanceRange","makeTree","data","buildTree","empty","FlatBufferCursor","buffer","index","start","end","size","next","fork","TreeBuffer","childString","join","endIndex","findChild","startIndex","dir","pick","checkSide","slice","startI","endI","b","copy","Uint16Array","len","j","Math","max","enterUnfinishedNodesBefore","scan","childBefore","last","lastChild","prevSibling","overlays","_a","IgnoreOverlays","inner","_parent","nextChild","e","ExcludeBuffers","BufferNode","BufferContext","hasChild","IgnoreMounts","childAfter","rPos","nextSignificantParent","val","toTree","getChild","before","after","r","getChildren","matchContext","context","matchNodeContext","cur","p","child","externalSibling","parentStart","stack","bufferNode","yieldNode","n","unshift","yieldBuf","yield","enterChild","pop","sibling","d","atLastNode","move","prev","cache","depth","mustLeave","some","nodeSet","maxBufferLength","reused","minRepeatType","takeNode","minPos","inRepeat","lookAheadAtStart","startPos","findBufferSize","skip","endPos","copyToBuffer","localChildren","localPositions","localInRepeat","lastGroup","lastEnd","makeRepeatLeaf","reverse","make","makeBalanced","lastI","lookAheadProp","base","pair","concat","maxSize","minStart","nodeSize","localSkipped","nodeStart","bufferStart","topID","nodeSizeCache","balanceType","mkTop","mkTree","total","maxChild","ceil","divide","offset","groupFrom","groupStart","groupSize","nextSize","only","NodeWeakMap","setBuffer","Map","getBuffer","cursorSet","cursorGet","TreeFragment","openStart","openEnd","open","fragments","partial","f","changes","minGap","fI","nextF","cI","off","nextC","nextPos","fromA","cut","fFrom","fTo","min","toA","toB","Parser","startParse","input","ranges","StringInput","createParse","parse","done","advance","string","chunk","lineChunks","read","parseMixed","nest","MixedParse","InnerParse","target","ActiveOverlay","predicate","mounts","stoppedInner","innerDone","baseTree","stoppedAt","baseParse","startInner","stopAt","parsedPos","fragmentCursor","FragmentCursor","covered","isCovered","range","hasNode","find","m","frag","mount","checkCover","materialize","oldMounts","findMounts","punchRanges","enterFragments","splice","sliceBuf","buf","nodes","innerOffset","isTarget","StructureCursor","root","curTo","fragI","first","curFrag","nextFrag","outer","current","gapFrom","gapTo","findCoverChanges","a","iA","iB","inA","inB","nextA","nextB"],"sourceRoot":""}