{"version":3,"file":"9041.95e5c457beaff3704105.js?v=95e5c457beaff3704105","mappings":"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","sources":["webpack://@jupyterlab/application-top/./node_modules/@lezer/generator/dist/index.js"],"sourcesContent":["import { NodeProp } from '@lezer/common';\nimport { LRParser, LocalTokenGroup } from '@lezer/lr';\n\nclass Node {\n    constructor(start) {\n        this.start = start;\n    }\n}\nclass GrammarDeclaration extends Node {\n    constructor(start, rules, topRules, tokens, localTokens, context, externalTokens, externalSpecializers, externalPropSources, precedences, mainSkip, scopedSkip, dialects, externalProps, autoDelim) {\n        super(start);\n        this.rules = rules;\n        this.topRules = topRules;\n        this.tokens = tokens;\n        this.localTokens = localTokens;\n        this.context = context;\n        this.externalTokens = externalTokens;\n        this.externalSpecializers = externalSpecializers;\n        this.externalPropSources = externalPropSources;\n        this.precedences = precedences;\n        this.mainSkip = mainSkip;\n        this.scopedSkip = scopedSkip;\n        this.dialects = dialects;\n        this.externalProps = externalProps;\n        this.autoDelim = autoDelim;\n    }\n    toString() { return Object.values(this.rules).join(\"\\n\"); }\n}\nclass RuleDeclaration extends Node {\n    constructor(start, id, props, params, expr) {\n        super(start);\n        this.id = id;\n        this.props = props;\n        this.params = params;\n        this.expr = expr;\n    }\n    toString() {\n        return this.id.name + (this.params.length ? `<${this.params.join()}>` : \"\") + \" -> \" + this.expr;\n    }\n}\nclass PrecDeclaration extends Node {\n    constructor(start, items) {\n        super(start);\n        this.items = items;\n    }\n}\nclass TokenPrecDeclaration extends Node {\n    constructor(start, items) {\n        super(start);\n        this.items = items;\n    }\n}\nclass TokenConflictDeclaration extends Node {\n    constructor(start, a, b) {\n        super(start);\n        this.a = a;\n        this.b = b;\n    }\n}\nclass TokenDeclaration extends Node {\n    constructor(start, precedences, conflicts, rules, literals) {\n        super(start);\n        this.precedences = precedences;\n        this.conflicts = conflicts;\n        this.rules = rules;\n        this.literals = literals;\n    }\n}\nclass LocalTokenDeclaration extends Node {\n    constructor(start, precedences, rules, fallback) {\n        super(start);\n        this.precedences = precedences;\n        this.rules = rules;\n        this.fallback = fallback;\n    }\n}\nclass LiteralDeclaration extends Node {\n    constructor(start, literal, props) {\n        super(start);\n        this.literal = literal;\n        this.props = props;\n    }\n}\nclass ContextDeclaration extends Node {\n    constructor(start, id, source) {\n        super(start);\n        this.id = id;\n        this.source = source;\n    }\n}\nclass ExternalTokenDeclaration extends Node {\n    constructor(start, id, source, tokens) {\n        super(start);\n        this.id = id;\n        this.source = source;\n        this.tokens = tokens;\n    }\n}\nclass ExternalSpecializeDeclaration extends Node {\n    constructor(start, type, token, id, source, tokens) {\n        super(start);\n        this.type = type;\n        this.token = token;\n        this.id = id;\n        this.source = source;\n        this.tokens = tokens;\n    }\n}\nclass ExternalPropSourceDeclaration extends Node {\n    constructor(start, id, source) {\n        super(start);\n        this.id = id;\n        this.source = source;\n    }\n}\nclass ExternalPropDeclaration extends Node {\n    constructor(start, id, externalID, source) {\n        super(start);\n        this.id = id;\n        this.externalID = externalID;\n        this.source = source;\n    }\n}\nclass Identifier extends Node {\n    constructor(start, name) {\n        super(start);\n        this.name = name;\n    }\n    toString() { return this.name; }\n}\nclass Expression extends Node {\n    walk(f) { return f(this); }\n    eq(_other) { return false; }\n}\nExpression.prototype.prec = 10;\nclass NameExpression extends Expression {\n    constructor(start, id, args) {\n        super(start);\n        this.id = id;\n        this.args = args;\n    }\n    toString() { return this.id.name + (this.args.length ? `<${this.args.join()}>` : \"\"); }\n    eq(other) {\n        return this.id.name == other.id.name && exprsEq(this.args, other.args);\n    }\n    walk(f) {\n        let args = walkExprs(this.args, f);\n        return f(args == this.args ? this : new NameExpression(this.start, this.id, args));\n    }\n}\nclass SpecializeExpression extends Expression {\n    constructor(start, type, props, token, content) {\n        super(start);\n        this.type = type;\n        this.props = props;\n        this.token = token;\n        this.content = content;\n    }\n    toString() { return `@${this.type}[${this.props.join(\",\")}]<${this.token}, ${this.content}>`; }\n    eq(other) {\n        return this.type == other.type && Prop.eqProps(this.props, other.props) && exprEq(this.token, other.token) &&\n            exprEq(this.content, other.content);\n    }\n    walk(f) {\n        let token = this.token.walk(f), content = this.content.walk(f);\n        return f(token == this.token && content == this.content ? this : new SpecializeExpression(this.start, this.type, this.props, token, content));\n    }\n}\nclass InlineRuleExpression extends Expression {\n    constructor(start, rule) {\n        super(start);\n        this.rule = rule;\n    }\n    toString() {\n        let rule = this.rule;\n        return `${rule.id}${rule.props.length ? `[${rule.props.join(\",\")}]` : \"\"} { ${rule.expr} }`;\n    }\n    eq(other) {\n        let rule = this.rule, oRule = other.rule;\n        return exprEq(rule.expr, oRule.expr) && rule.id.name == oRule.id.name && Prop.eqProps(rule.props, oRule.props);\n    }\n    walk(f) {\n        let rule = this.rule, expr = rule.expr.walk(f);\n        return f(expr == rule.expr ? this :\n            new InlineRuleExpression(this.start, new RuleDeclaration(rule.start, rule.id, rule.props, [], expr)));\n    }\n}\nclass ChoiceExpression extends Expression {\n    constructor(start, exprs) {\n        super(start);\n        this.exprs = exprs;\n    }\n    toString() { return this.exprs.map(e => maybeParens(e, this)).join(\" | \"); }\n    eq(other) {\n        return exprsEq(this.exprs, other.exprs);\n    }\n    walk(f) {\n        let exprs = walkExprs(this.exprs, f);\n        return f(exprs == this.exprs ? this : new ChoiceExpression(this.start, exprs));\n    }\n}\nChoiceExpression.prototype.prec = 1;\nclass SequenceExpression extends Expression {\n    constructor(start, exprs, markers, empty = false) {\n        super(start);\n        this.exprs = exprs;\n        this.markers = markers;\n        this.empty = empty;\n    }\n    toString() { return this.empty ? \"()\" : this.exprs.map(e => maybeParens(e, this)).join(\" \"); }\n    eq(other) {\n        return exprsEq(this.exprs, other.exprs) && this.markers.every((m, i) => {\n            let om = other.markers[i];\n            return m.length == om.length && m.every((x, i) => x.eq(om[i]));\n        });\n    }\n    walk(f) {\n        let exprs = walkExprs(this.exprs, f);\n        return f(exprs == this.exprs ? this : new SequenceExpression(this.start, exprs, this.markers, this.empty && !exprs.length));\n    }\n}\nSequenceExpression.prototype.prec = 2;\nclass ConflictMarker extends Node {\n    constructor(start, id, type) {\n        super(start);\n        this.id = id;\n        this.type = type;\n    }\n    toString() { return (this.type == \"ambig\" ? \"~\" : \"!\") + this.id.name; }\n    eq(other) { return this.id.name == other.id.name && this.type == other.type; }\n}\nclass RepeatExpression extends Expression {\n    constructor(start, expr, kind) {\n        super(start);\n        this.expr = expr;\n        this.kind = kind;\n    }\n    toString() { return maybeParens(this.expr, this) + this.kind; }\n    eq(other) {\n        return exprEq(this.expr, other.expr) && this.kind == other.kind;\n    }\n    walk(f) {\n        let expr = this.expr.walk(f);\n        return f(expr == this.expr ? this : new RepeatExpression(this.start, expr, this.kind));\n    }\n}\nRepeatExpression.prototype.prec = 3;\nclass LiteralExpression extends Expression {\n    // value.length is always > 0\n    constructor(start, value) {\n        super(start);\n        this.value = value;\n    }\n    toString() { return JSON.stringify(this.value); }\n    eq(other) { return this.value == other.value; }\n}\nclass SetExpression extends Expression {\n    constructor(start, ranges, inverted) {\n        super(start);\n        this.ranges = ranges;\n        this.inverted = inverted;\n    }\n    toString() {\n        return `[${this.inverted ? \"^\" : \"\"}${this.ranges.map(([a, b]) => {\n            return String.fromCodePoint(a) + (b == a + 1 ? \"\" : \"-\" + String.fromCodePoint(b));\n        })}]`;\n    }\n    eq(other) {\n        return this.inverted == other.inverted && this.ranges.length == other.ranges.length &&\n            this.ranges.every(([a, b], i) => { let [x, y] = other.ranges[i]; return a == x && b == y; });\n    }\n}\nclass AnyExpression extends Expression {\n    constructor(start) {\n        super(start);\n    }\n    toString() { return \"_\"; }\n    eq() { return true; }\n}\nfunction walkExprs(exprs, f) {\n    let result = null;\n    for (let i = 0; i < exprs.length; i++) {\n        let expr = exprs[i].walk(f);\n        if (expr != exprs[i] && !result)\n            result = exprs.slice(0, i);\n        if (result)\n            result.push(expr);\n    }\n    return result || exprs;\n}\nconst CharClasses = {\n    asciiLetter: [[65, 91], [97, 123]],\n    asciiLowercase: [[97, 123]],\n    asciiUppercase: [[65, 91]],\n    digit: [[48, 58]],\n    whitespace: [[9, 14], [32, 33], [133, 134], [160, 161], [5760, 5761], [8192, 8203],\n        [8232, 8234], [8239, 8240], [8287, 8288], [12288, 12289]],\n    eof: [[0xffff, 0xffff]]\n};\nclass CharClass extends Expression {\n    constructor(start, type) {\n        super(start);\n        this.type = type;\n    }\n    toString() { return \"@\" + this.type; }\n    eq(expr) { return this.type == expr.type; }\n}\nfunction exprEq(a, b) {\n    return a.constructor == b.constructor && a.eq(b);\n}\nfunction exprsEq(a, b) {\n    return a.length == b.length && a.every((e, i) => exprEq(e, b[i]));\n}\nclass Prop extends Node {\n    constructor(start, at, name, value) {\n        super(start);\n        this.at = at;\n        this.name = name;\n        this.value = value;\n    }\n    eq(other) {\n        return this.name == other.name && this.value.length == other.value.length &&\n            this.value.every((v, i) => v.value == other.value[i].value && v.name == other.value[i].name);\n    }\n    toString() {\n        let result = (this.at ? \"@\" : \"\") + this.name;\n        if (this.value.length) {\n            result += \"=\";\n            for (let { name, value } of this.value)\n                result += name ? `{${name}}` : /[^\\w-]/.test(value) ? JSON.stringify(value) : value;\n        }\n        return result;\n    }\n    static eqProps(a, b) {\n        return a.length == b.length && a.every((p, i) => p.eq(b[i]));\n    }\n}\nclass PropPart extends Node {\n    constructor(start, value, name) {\n        super(start);\n        this.value = value;\n        this.name = name;\n    }\n}\nfunction maybeParens(node, parent) {\n    return node.prec < parent.prec ? \"(\" + node.toString() + \")\" : node.toString();\n}\n\n/// The type of error raised when the parser generator finds an issue.\nclass GenError extends Error {\n}\n\nfunction hasProps(props) {\n    for (let _p in props)\n        return true;\n    return false;\n}\nlet termHash = 0;\nclass Term {\n    constructor(name, flags, nodeName, props = {}) {\n        this.name = name;\n        this.flags = flags;\n        this.nodeName = nodeName;\n        this.props = props;\n        this.hash = ++termHash; // Used for sorting and hashing during parser generation\n        this.id = -1; // Assigned in a later stage, used in actual output\n        // Filled in only after the rules are simplified, used in automaton.ts\n        this.rules = [];\n    }\n    toString() { return this.name; }\n    get nodeType() { return this.top || this.nodeName != null || hasProps(this.props) || this.repeated; }\n    get terminal() { return (this.flags & 1 /* TermFlag.Terminal */) > 0; }\n    get eof() { return (this.flags & 4 /* TermFlag.Eof */) > 0; }\n    get error() { return \"error\" in this.props; }\n    get top() { return (this.flags & 2 /* TermFlag.Top */) > 0; }\n    get interesting() { return this.flags > 0 || this.nodeName != null; }\n    get repeated() { return (this.flags & 16 /* TermFlag.Repeated */) > 0; }\n    set preserve(value) { this.flags = value ? this.flags | 8 /* TermFlag.Preserve */ : this.flags & ~8 /* TermFlag.Preserve */; }\n    get preserve() { return (this.flags & 8 /* TermFlag.Preserve */) > 0; }\n    set inline(value) { this.flags = value ? this.flags | 32 /* TermFlag.Inline */ : this.flags & ~32 /* TermFlag.Inline */; }\n    get inline() { return (this.flags & 32 /* TermFlag.Inline */) > 0; }\n    cmp(other) { return this.hash - other.hash; }\n}\nclass TermSet {\n    constructor() {\n        this.terms = [];\n        // Map from term names to Term instances\n        this.names = Object.create(null);\n        this.tops = [];\n        this.eof = this.term(\"\", null, 1 /* TermFlag.Terminal */ | 4 /* TermFlag.Eof */);\n        this.error = this.term(\"\", \"\", 8 /* TermFlag.Preserve */);\n    }\n    term(name, nodeName, flags = 0, props = {}) {\n        let term = new Term(name, flags, nodeName, props);\n        this.terms.push(term);\n        this.names[name] = term;\n        return term;\n    }\n    makeTop(nodeName, props) {\n        const term = this.term(\"@top\", nodeName, 2 /* TermFlag.Top */, props);\n        this.tops.push(term);\n        return term;\n    }\n    makeTerminal(name, nodeName, props = {}) {\n        return this.term(name, nodeName, 1 /* TermFlag.Terminal */, props);\n    }\n    makeNonTerminal(name, nodeName, props = {}) {\n        return this.term(name, nodeName, 0, props);\n    }\n    makeRepeat(name) {\n        return this.term(name, null, 16 /* TermFlag.Repeated */);\n    }\n    uniqueName(name) {\n        for (let i = 0;; i++) {\n            let cur = i ? `${name}-${i}` : name;\n            if (!this.names[cur])\n                return cur;\n        }\n    }\n    finish(rules) {\n        for (let rule of rules)\n            rule.name.rules.push(rule);\n        this.terms = this.terms.filter(t => t.terminal || t.preserve || rules.some(r => r.name == t || r.parts.includes(t)));\n        let names = {};\n        let nodeTypes = [this.error];\n        this.error.id = 0 /* T.Err */;\n        let nextID = 0 /* T.Err */ + 1;\n        // Assign ids to terms that represent node types\n        for (let term of this.terms)\n            if (term.id < 0 && term.nodeType && !term.repeated) {\n                term.id = nextID++;\n                nodeTypes.push(term);\n            }\n        // Put all repeated terms after the regular node types\n        let minRepeatTerm = nextID;\n        for (let term of this.terms)\n            if (term.repeated) {\n                term.id = nextID++;\n                nodeTypes.push(term);\n            }\n        // Then comes the EOF term\n        this.eof.id = nextID++;\n        // And then the remaining (non-node, non-repeat) terms.\n        for (let term of this.terms) {\n            if (term.id < 0)\n                term.id = nextID++;\n            if (term.name)\n                names[term.id] = term.name;\n        }\n        if (nextID >= 0xfffe)\n            throw new GenError(\"Too many terms\");\n        return { nodeTypes, names, minRepeatTerm, maxTerm: nextID - 1 };\n    }\n}\nfunction cmpSet(a, b, cmp) {\n    if (a.length != b.length)\n        return a.length - b.length;\n    for (let i = 0; i < a.length; i++) {\n        let diff = cmp(a[i], b[i]);\n        if (diff)\n            return diff;\n    }\n    return 0;\n}\nconst none$3 = [];\nclass Conflicts {\n    constructor(precedence, ambigGroups = none$3, cut = 0) {\n        this.precedence = precedence;\n        this.ambigGroups = ambigGroups;\n        this.cut = cut;\n    }\n    join(other) {\n        if (this == Conflicts.none || this == other)\n            return other;\n        if (other == Conflicts.none)\n            return this;\n        return new Conflicts(Math.max(this.precedence, other.precedence), union(this.ambigGroups, other.ambigGroups), Math.max(this.cut, other.cut));\n    }\n    cmp(other) {\n        return this.precedence - other.precedence || cmpSet(this.ambigGroups, other.ambigGroups, (a, b) => a < b ? -1 : a > b ? 1 : 0) ||\n            this.cut - other.cut;\n    }\n}\nConflicts.none = new Conflicts(0);\nfunction union(a, b) {\n    if (a.length == 0 || a == b)\n        return b;\n    if (b.length == 0)\n        return a;\n    let result = a.slice();\n    for (let value of b)\n        if (!a.includes(value))\n            result.push(value);\n    return result.sort();\n}\nlet ruleID = 0;\nclass Rule {\n    constructor(name, parts, conflicts, skip) {\n        this.name = name;\n        this.parts = parts;\n        this.conflicts = conflicts;\n        this.skip = skip;\n        this.id = ruleID++;\n    }\n    cmp(rule) {\n        return this.id - rule.id;\n    }\n    cmpNoName(rule) {\n        return this.parts.length - rule.parts.length ||\n            this.skip.hash - rule.skip.hash ||\n            this.parts.reduce((r, s, i) => r || s.cmp(rule.parts[i]), 0) ||\n            cmpSet(this.conflicts, rule.conflicts, (a, b) => a.cmp(b));\n    }\n    toString() {\n        return this.name + \" -> \" + this.parts.join(\" \");\n    }\n    get isRepeatWrap() {\n        return this.name.repeated && this.parts.length == 2 && this.parts[0] == this.name;\n    }\n    sameReduce(other) {\n        return this.name == other.name && this.parts.length == other.parts.length && this.isRepeatWrap == other.isRepeatWrap;\n    }\n}\n\nconst MAX_CHAR = 0xffff;\nclass Edge {\n    constructor(from, to, target) {\n        this.from = from;\n        this.to = to;\n        this.target = target;\n    }\n    toString() {\n        return `-> ${this.target.id}[label=${JSON.stringify(this.from < 0 ? \"\" : charFor(this.from) +\n            (this.to > this.from + 1 ? \"-\" + charFor(this.to - 1) : \"\"))}]`;\n    }\n}\nfunction charFor(n) {\n    return n > MAX_CHAR ? \"\"\n        : n == 10 ? \"\\\\n\"\n            : n == 13 ? \"\\\\r\"\n                : n < 32 || n >= 0xd800 && n < 0xdfff ? \"\\\\u{\" + n.toString(16) + \"}\"\n                    : String.fromCharCode(n);\n}\nfunction minimize(states, start) {\n    let partition = Object.create(null);\n    let byAccepting = Object.create(null);\n    for (let state of states) {\n        let id = ids(state.accepting);\n        let group = byAccepting[id] || (byAccepting[id] = []);\n        group.push(state);\n        partition[state.id] = group;\n    }\n    for (;;) {\n        let split = false, newPartition = Object.create(null);\n        for (let state of states) {\n            if (newPartition[state.id])\n                continue;\n            let group = partition[state.id];\n            if (group.length == 1) {\n                newPartition[group[0].id] = group;\n                continue;\n            }\n            let parts = [];\n            groups: for (let state of group) {\n                for (let p of parts) {\n                    if (isEquivalent(state, p[0], partition)) {\n                        p.push(state);\n                        continue groups;\n                    }\n                }\n                parts.push([state]);\n            }\n            if (parts.length > 1)\n                split = true;\n            for (let p of parts)\n                for (let s of p)\n                    newPartition[s.id] = p;\n        }\n        if (!split)\n            return applyMinimization(states, start, partition);\n        partition = newPartition;\n    }\n}\nfunction isEquivalent(a, b, partition) {\n    if (a.edges.length != b.edges.length)\n        return false;\n    for (let i = 0; i < a.edges.length; i++) {\n        let eA = a.edges[i], eB = b.edges[i];\n        if (eA.from != eB.from || eA.to != eB.to || partition[eA.target.id] != partition[eB.target.id])\n            return false;\n    }\n    return true;\n}\nfunction applyMinimization(states, start, partition) {\n    for (let state of states) {\n        for (let i = 0; i < state.edges.length; i++) {\n            let edge = state.edges[i], target = partition[edge.target.id][0];\n            if (target != edge.target)\n                state.edges[i] = new Edge(edge.from, edge.to, target);\n        }\n    }\n    return partition[start.id][0];\n}\nlet stateID = 1;\nclass State$1 {\n    constructor(accepting = [], id = stateID++) {\n        this.accepting = accepting;\n        this.id = id;\n        this.edges = [];\n    }\n    edge(from, to, target) {\n        this.edges.push(new Edge(from, to, target));\n    }\n    nullEdge(target) { this.edge(-1, -1, target); }\n    compile() {\n        let labeled = Object.create(null), localID = 0;\n        let startState = explore(this.closure().sort((a, b) => a.id - b.id));\n        return minimize(Object.values(labeled), startState);\n        function explore(states) {\n            let newState = labeled[ids(states)] =\n                new State$1(states.reduce((a, s) => union(a, s.accepting), []), localID++);\n            let out = [];\n            for (let state of states)\n                for (let edge of state.edges) {\n                    if (edge.from >= 0)\n                        out.push(edge);\n                }\n            let transitions = mergeEdges(out);\n            for (let merged of transitions) {\n                let targets = merged.targets.sort((a, b) => a.id - b.id);\n                newState.edge(merged.from, merged.to, labeled[ids(targets)] || explore(targets));\n            }\n            return newState;\n        }\n    }\n    closure() {\n        let result = [], seen = Object.create(null);\n        function explore(state) {\n            if (seen[state.id])\n                return;\n            seen[state.id] = true;\n            // States with only epsilon edges and no accepting term that\n            // isn't also in the next states are left out to help reduce the\n            // number of unique state combinations\n            if (state.edges.some(e => e.from >= 0) ||\n                (state.accepting.length > 0 && !state.edges.some(e => sameSet$1(state.accepting, e.target.accepting))))\n                result.push(state);\n            for (let edge of state.edges)\n                if (edge.from < 0)\n                    explore(edge.target);\n        }\n        explore(this);\n        return result;\n    }\n    findConflicts(occurTogether) {\n        let conflicts = [], cycleTerms = this.cycleTerms();\n        function add(a, b, soft, aEdges, bEdges) {\n            if (a.id < b.id) {\n                [a, b] = [b, a];\n                soft = -soft;\n            }\n            let found = conflicts.find(c => c.a == a && c.b == b);\n            if (!found)\n                conflicts.push(new Conflict$1(a, b, soft, exampleFromEdges(aEdges), bEdges && exampleFromEdges(bEdges)));\n            else if (found.soft != soft)\n                found.soft = 0;\n        }\n        this.reachable((state, edges) => {\n            if (state.accepting.length == 0)\n                return;\n            for (let i = 0; i < state.accepting.length; i++)\n                for (let j = i + 1; j < state.accepting.length; j++)\n                    add(state.accepting[i], state.accepting[j], 0, edges);\n            state.reachable((s, es) => {\n                if (s != state)\n                    for (let term of s.accepting) {\n                        let hasCycle = cycleTerms.includes(term);\n                        for (let orig of state.accepting)\n                            if (term != orig)\n                                add(term, orig, hasCycle || cycleTerms.includes(orig) || !occurTogether(term, orig) ? 0 : 1, edges, edges.concat(es));\n                    }\n            });\n        });\n        return conflicts;\n    }\n    cycleTerms() {\n        let work = [];\n        this.reachable(state => {\n            for (let { target } of state.edges)\n                work.push(state, target);\n        });\n        let table = new Map;\n        let haveCycle = [];\n        for (let i = 0; i < work.length;) {\n            let from = work[i++], to = work[i++];\n            let entry = table.get(from);\n            if (!entry)\n                table.set(from, entry = []);\n            if (entry.includes(to))\n                continue;\n            if (from == to) {\n                if (!haveCycle.includes(from))\n                    haveCycle.push(from);\n            }\n            else {\n                for (let next of entry)\n                    work.push(from, next);\n                entry.push(to);\n            }\n        }\n        let result = [];\n        for (let state of haveCycle) {\n            for (let term of state.accepting) {\n                if (!result.includes(term))\n                    result.push(term);\n            }\n        }\n        return result;\n    }\n    reachable(f) {\n        let seen = [], edges = [];\n        (function explore(s) {\n            f(s, edges);\n            seen.push(s);\n            for (let edge of s.edges)\n                if (!seen.includes(edge.target)) {\n                    edges.push(edge);\n                    explore(edge.target);\n                    edges.pop();\n                }\n        })(this);\n    }\n    toString() {\n        let out = \"digraph {\\n\";\n        this.reachable(state => {\n            if (state.accepting.length)\n                out += `  ${state.id} [label=${JSON.stringify(state.accepting.join())}];\\n`;\n            for (let edge of state.edges)\n                out += `  ${state.id} ${edge};\\n`;\n        });\n        return out + \"}\";\n    }\n    // Tokenizer data is represented as a single flat array. This\n    // contains regions for each tokenizer state. Region offsets are\n    // used to identify states.\n    //\n    // Each state is laid out as:\n    //  - Token group mask\n    //  - Offset of the end of the accepting data\n    //  - Number of outgoing edges in the state\n    //  - Pairs of token masks and term ids that indicate the accepting\n    //    states, sorted by precedence\n    //  - Triples for the edges: each with a low and high bound and the\n    //    offset of the next state.\n    toArray(groupMasks, precedence) {\n        let offsets = []; // Used to 'link' the states after building the arrays\n        let data = [];\n        this.reachable(state => {\n            let start = data.length;\n            let acceptEnd = start + 3 + state.accepting.length * 2;\n            offsets[state.id] = start;\n            data.push(state.stateMask(groupMasks), acceptEnd, state.edges.length);\n            state.accepting.sort((a, b) => precedence.indexOf(a.id) - precedence.indexOf(b.id));\n            for (let term of state.accepting)\n                data.push(term.id, groupMasks[term.id] || 0xffff);\n            for (let edge of state.edges)\n                data.push(edge.from, edge.to, -edge.target.id - 1);\n        });\n        // Replace negative numbers with resolved state offsets\n        for (let i = 0; i < data.length; i++)\n            if (data[i] < 0)\n                data[i] = offsets[-data[i] - 1];\n        if (data.length > 2 ** 16)\n            throw new GenError(\"Tokenizer tables too big to represent with 16-bit offsets.\");\n        return Uint16Array.from(data);\n    }\n    stateMask(groupMasks) {\n        let mask = 0;\n        this.reachable(state => {\n            for (let term of state.accepting)\n                mask |= (groupMasks[term.id] || 0xffff);\n        });\n        return mask;\n    }\n}\nclass Conflict$1 {\n    constructor(a, b, \n    // Conflicts between two non-cyclic tokens are marked as\n    // 'soft', with a negative number if a is shorter than\n    // b, and a positive if b is shorter than a.\n    soft, exampleA, exampleB) {\n        this.a = a;\n        this.b = b;\n        this.soft = soft;\n        this.exampleA = exampleA;\n        this.exampleB = exampleB;\n    }\n}\nfunction exampleFromEdges(edges) {\n    let str = \"\";\n    for (let i = 0; i < edges.length; i++)\n        str += String.fromCharCode(edges[i].from);\n    return str;\n}\nfunction ids(elts) {\n    let result = \"\";\n    for (let elt of elts) {\n        if (result.length)\n            result += \"-\";\n        result += elt.id;\n    }\n    return result;\n}\nfunction sameSet$1(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i])\n            return false;\n    return true;\n}\nclass MergedEdge {\n    constructor(from, to, targets) {\n        this.from = from;\n        this.to = to;\n        this.targets = targets;\n    }\n}\n// Merge multiple edges (tagged by character ranges) into a set of\n// mutually exclusive ranges pointing at all target states for that\n// range\nfunction mergeEdges(edges) {\n    let separate = [], result = [];\n    for (let edge of edges) {\n        if (!separate.includes(edge.from))\n            separate.push(edge.from);\n        if (!separate.includes(edge.to))\n            separate.push(edge.to);\n    }\n    separate.sort((a, b) => a - b);\n    for (let i = 1; i < separate.length; i++) {\n        let from = separate[i - 1], to = separate[i];\n        let found = [];\n        for (let edge of edges)\n            if (edge.to > from && edge.from < to) {\n                for (let target of edge.target.closure())\n                    if (!found.includes(target))\n                        found.push(target);\n            }\n        if (found.length)\n            result.push(new MergedEdge(from, to, found));\n    }\n    let eof = edges.filter(e => e.from == 65535 /* Seq.End */ && e.to == 65535 /* Seq.End */);\n    if (eof.length) {\n        let found = [];\n        for (let edge of eof)\n            for (let target of edge.target.closure())\n                if (!found.includes(target))\n                    found.push(target);\n        if (found.length)\n            result.push(new MergedEdge(65535 /* Seq.End */, 65535 /* Seq.End */, found));\n    }\n    return result;\n}\n\n// Note that this is the parser for grammar files, not the generated parser\nlet word = /[\\w_-]+/gy;\n// Some engines (specifically SpiderMonkey) have still not implemented \\p\ntry {\n    word = /[\\p{Alphabetic}\\d_-]+/ugy;\n}\ncatch (_) { }\nconst none$2 = [];\nclass Input {\n    constructor(string, fileName = null) {\n        this.string = string;\n        this.fileName = fileName;\n        this.type = \"sof\";\n        this.value = null;\n        this.start = 0;\n        this.end = 0;\n        this.next();\n    }\n    lineInfo(pos) {\n        for (let line = 1, cur = 0;;) {\n            let next = this.string.indexOf(\"\\n\", cur);\n            if (next > -1 && next < pos) {\n                ++line;\n                cur = next + 1;\n            }\n            else {\n                return { line, ch: pos - cur };\n            }\n        }\n    }\n    message(msg, pos = -1) {\n        let posInfo = this.fileName || \"\";\n        if (pos > -1) {\n            let info = this.lineInfo(pos);\n            posInfo += (posInfo ? \" \" : \"\") + info.line + \":\" + info.ch;\n        }\n        return posInfo ? msg + ` (${posInfo})` : msg;\n    }\n    raise(msg, pos = -1) {\n        throw new GenError(this.message(msg, pos));\n    }\n    match(pos, re) {\n        let match = re.exec(this.string.slice(pos));\n        return match ? pos + match[0].length : -1;\n    }\n    next() {\n        let start = this.match(this.end, /^(\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n        if (start == this.string.length)\n            return this.set(\"eof\", null, start, start);\n        let next = this.string[start];\n        if (next == '\"') {\n            let end = this.match(start + 1, /^(\\\\.|[^\"\\\\])*\"/);\n            if (end == -1)\n                this.raise(\"Unterminated string literal\", start);\n            return this.set(\"string\", readString(this.string.slice(start + 1, end - 1)), start, end);\n        }\n        else if (next == \"'\") {\n            let end = this.match(start + 1, /^(\\\\.|[^'\\\\])*'/);\n            if (end == -1)\n                this.raise(\"Unterminated string literal\", start);\n            return this.set(\"string\", readString(this.string.slice(start + 1, end - 1)), start, end);\n        }\n        else if (next == \"@\") {\n            word.lastIndex = start + 1;\n            let m = word.exec(this.string);\n            if (!m)\n                return this.raise(\"@ without a name\", start);\n            return this.set(\"at\", m[0], start, start + 1 + m[0].length);\n        }\n        else if ((next == \"$\" || next == \"!\") && this.string[start + 1] == \"[\") {\n            let end = this.match(start + 2, /^(?:\\\\.|[^\\]\\\\])*\\]/);\n            if (end == -1)\n                this.raise(\"Unterminated character set\", start);\n            return this.set(\"set\", this.string.slice(start + 2, end - 1), start, end);\n        }\n        else if (/[\\[\\]()!~+*?{}<>\\.,|:$=]/.test(next)) {\n            return this.set(next, null, start, start + 1);\n        }\n        else {\n            word.lastIndex = start;\n            let m = word.exec(this.string);\n            if (!m)\n                return this.raise(\"Unexpected character \" + JSON.stringify(next), start);\n            return this.set(\"id\", m[0], start, start + m[0].length);\n        }\n    }\n    set(type, value, start, end) {\n        this.type = type;\n        this.value = value;\n        this.start = start;\n        this.end = end;\n    }\n    eat(type, value = null) {\n        if (this.type == type && (value == null || this.value === value)) {\n            this.next();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    unexpected() {\n        return this.raise(`Unexpected token '${this.string.slice(this.start, this.end)}'`, this.start);\n    }\n    expect(type, value = null) {\n        let val = this.value;\n        if (this.type != type || !(value == null || val === value))\n            this.unexpected();\n        this.next();\n        return val;\n    }\n    parse() {\n        return parseGrammar(this);\n    }\n}\nfunction parseGrammar(input) {\n    let start = input.start;\n    let rules = [];\n    let prec = null;\n    let tokens = null;\n    let localTokens = [];\n    let mainSkip = null;\n    let scopedSkip = [];\n    let dialects = [];\n    let context = null;\n    let external = [];\n    let specialized = [];\n    let props = [];\n    let propSources = [];\n    let tops = [];\n    let sawTop = false;\n    let autoDelim = false;\n    while (input.type != \"eof\") {\n        let start = input.start;\n        if (input.eat(\"at\", \"top\")) {\n            if (input.type != \"id\")\n                input.raise(`Top rules must have a name`, input.start);\n            tops.push(parseRule(input, parseIdent(input)));\n            sawTop = true;\n        }\n        else if (input.type == \"at\" && input.value == \"tokens\") {\n            if (tokens)\n                input.raise(`Multiple @tokens declaractions`, input.start);\n            else\n                tokens = parseTokens(input);\n        }\n        else if (input.eat(\"at\", \"local\")) {\n            input.expect(\"id\", \"tokens\");\n            localTokens.push(parseLocalTokens(input, start));\n        }\n        else if (input.eat(\"at\", \"context\")) {\n            if (context)\n                input.raise(`Multiple @context declarations`, start);\n            let id = parseIdent(input);\n            input.expect(\"id\", \"from\");\n            let source = input.expect(\"string\");\n            context = new ContextDeclaration(start, id, source);\n        }\n        else if (input.eat(\"at\", \"external\")) {\n            if (input.eat(\"id\", \"tokens\"))\n                external.push(parseExternalTokens(input, start));\n            else if (input.eat(\"id\", \"prop\"))\n                props.push(parseExternalProp(input, start));\n            else if (input.eat(\"id\", \"extend\"))\n                specialized.push(parseExternalSpecialize(input, \"extend\", start));\n            else if (input.eat(\"id\", \"specialize\"))\n                specialized.push(parseExternalSpecialize(input, \"specialize\", start));\n            else if (input.eat(\"id\", \"propSource\"))\n                propSources.push(parseExternalPropSource(input, start));\n            else\n                input.unexpected();\n        }\n        else if (input.eat(\"at\", \"dialects\")) {\n            input.expect(\"{\");\n            for (let first = true; !input.eat(\"}\"); first = false) {\n                if (!first)\n                    input.eat(\",\");\n                dialects.push(parseIdent(input));\n            }\n        }\n        else if (input.type == \"at\" && input.value == \"precedence\") {\n            if (prec)\n                input.raise(`Multiple precedence declarations`, input.start);\n            prec = parsePrecedence(input);\n        }\n        else if (input.eat(\"at\", \"detectDelim\")) {\n            autoDelim = true;\n        }\n        else if (input.eat(\"at\", \"skip\")) {\n            let skip = parseBracedExpr(input);\n            if (input.type == \"{\") {\n                input.next();\n                let rules = [], topRules = [];\n                while (!input.eat(\"}\")) {\n                    if (input.eat(\"at\", \"top\")) {\n                        topRules.push(parseRule(input, parseIdent(input)));\n                        sawTop = true;\n                    }\n                    else {\n                        rules.push(parseRule(input));\n                    }\n                }\n                scopedSkip.push({ expr: skip, topRules, rules });\n            }\n            else {\n                if (mainSkip)\n                    input.raise(`Multiple top-level skip declarations`, input.start);\n                mainSkip = skip;\n            }\n        }\n        else {\n            rules.push(parseRule(input));\n        }\n    }\n    if (!sawTop)\n        return input.raise(`Missing @top declaration`);\n    return new GrammarDeclaration(start, rules, tops, tokens, localTokens, context, external, specialized, propSources, prec, mainSkip, scopedSkip, dialects, props, autoDelim);\n}\nfunction parseRule(input, named) {\n    let start = named ? named.start : input.start;\n    let id = named || parseIdent(input);\n    let props = parseProps(input);\n    let params = [];\n    if (input.eat(\"<\"))\n        while (!input.eat(\">\")) {\n            if (params.length)\n                input.expect(\",\");\n            params.push(parseIdent(input));\n        }\n    let expr = parseBracedExpr(input);\n    return new RuleDeclaration(start, id, props, params, expr);\n}\nfunction parseProps(input) {\n    if (input.type != \"[\")\n        return none$2;\n    let props = [];\n    input.expect(\"[\");\n    while (!input.eat(\"]\")) {\n        if (props.length)\n            input.expect(\",\");\n        props.push(parseProp(input));\n    }\n    return props;\n}\nfunction parseProp(input) {\n    let start = input.start, value = [], name = input.value, at = input.type == \"at\";\n    if (!input.eat(\"at\") && !input.eat(\"id\"))\n        input.unexpected();\n    if (input.eat(\"=\"))\n        for (;;) {\n            if (input.type == \"string\" || input.type == \"id\") {\n                value.push(new PropPart(input.start, input.value, null));\n                input.next();\n            }\n            else if (input.eat(\".\")) {\n                value.push(new PropPart(input.start, \".\", null));\n            }\n            else if (input.eat(\"{\")) {\n                value.push(new PropPart(input.start, null, input.expect(\"id\")));\n                input.expect(\"}\");\n            }\n            else {\n                break;\n            }\n        }\n    return new Prop(start, at, name, value);\n}\nfunction parseBracedExpr(input) {\n    input.expect(\"{\");\n    let expr = parseExprChoice(input);\n    input.expect(\"}\");\n    return expr;\n}\nconst SET_MARKER = \"\\ufdda\"; // (Invalid unicode character)\nfunction parseExprInner(input) {\n    let start = input.start;\n    if (input.eat(\"(\")) {\n        if (input.eat(\")\"))\n            return new SequenceExpression(start, none$2, [none$2, none$2]);\n        let expr = parseExprChoice(input);\n        input.expect(\")\");\n        return expr;\n    }\n    else if (input.type == \"string\") {\n        let value = input.value;\n        input.next();\n        if (value.length == 0)\n            return new SequenceExpression(start, none$2, [none$2, none$2]);\n        return new LiteralExpression(start, value);\n    }\n    else if (input.eat(\"id\", \"_\")) {\n        return new AnyExpression(start);\n    }\n    else if (input.type == \"set\") {\n        let content = input.value, invert = input.string[input.start] == \"!\";\n        let unescaped = readString(content.replace(/\\\\.|-|\"/g, (m) => {\n            return m == \"-\" ? SET_MARKER : m == '\"' ? '\\\\\"' : m;\n        }));\n        let ranges = [];\n        for (let pos = 0; pos < unescaped.length;) {\n            let code = unescaped.codePointAt(pos);\n            pos += code > 0xffff ? 2 : 1;\n            if (pos < unescaped.length - 1 && unescaped[pos] == SET_MARKER) {\n                let end = unescaped.codePointAt(pos + 1);\n                pos += end > 0xffff ? 3 : 2;\n                if (end < code)\n                    input.raise(\"Invalid character range\", input.start);\n                addRange(input, ranges, code, end + 1);\n            }\n            else {\n                if (code == SET_MARKER.charCodeAt(0))\n                    code = 45;\n                addRange(input, ranges, code, code + 1);\n            }\n        }\n        input.next();\n        return new SetExpression(start, ranges.sort((a, b) => a[0] - b[0]), invert);\n    }\n    else if (input.type == \"at\" && (input.value == \"specialize\" || input.value == \"extend\")) {\n        let { start, value } = input;\n        input.next();\n        let props = parseProps(input);\n        input.expect(\"<\");\n        let token = parseExprChoice(input), content;\n        if (input.eat(\",\")) {\n            content = parseExprChoice(input);\n        }\n        else if (token instanceof LiteralExpression) {\n            content = token;\n        }\n        else {\n            input.raise(`@${value} requires two arguments when its first argument isn't a literal string`);\n        }\n        input.expect(\">\");\n        return new SpecializeExpression(start, value, props, token, content);\n    }\n    else if (input.type == \"at\" && CharClasses.hasOwnProperty(input.value)) {\n        let cls = new CharClass(input.start, input.value);\n        input.next();\n        return cls;\n    }\n    else if (input.type == \"[\") {\n        let rule = parseRule(input, new Identifier(start, \"_anon\"));\n        if (rule.params.length)\n            input.raise(`Inline rules can't have parameters`, rule.start);\n        return new InlineRuleExpression(start, rule);\n    }\n    else {\n        let id = parseIdent(input);\n        if (input.type == \"[\" || input.type == \"{\") {\n            let rule = parseRule(input, id);\n            if (rule.params.length)\n                input.raise(`Inline rules can't have parameters`, rule.start);\n            return new InlineRuleExpression(start, rule);\n        }\n        else {\n            if (input.eat(\".\") && id.name == \"std\" && CharClasses.hasOwnProperty(input.value)) {\n                let cls = new CharClass(start, input.value);\n                input.next();\n                return cls;\n            }\n            return new NameExpression(start, id, parseArgs(input));\n        }\n    }\n}\nfunction parseArgs(input) {\n    let args = [];\n    if (input.eat(\"<\"))\n        while (!input.eat(\">\")) {\n            if (args.length)\n                input.expect(\",\");\n            args.push(parseExprChoice(input));\n        }\n    return args;\n}\nfunction addRange(input, ranges, from, to) {\n    if (!ranges.every(([a, b]) => b <= from || a >= to))\n        input.raise(\"Overlapping character range\", input.start);\n    ranges.push([from, to]);\n}\nfunction parseExprSuffix(input) {\n    let start = input.start;\n    let expr = parseExprInner(input);\n    for (;;) {\n        let kind = input.type;\n        if (input.eat(\"*\") || input.eat(\"?\") || input.eat(\"+\"))\n            expr = new RepeatExpression(start, expr, kind);\n        else\n            return expr;\n    }\n}\nfunction endOfSequence(input) {\n    return input.type == \"}\" || input.type == \")\" || input.type == \"|\" || input.type == \"/\" ||\n        input.type == \"/\\\\\" || input.type == \"{\" || input.type == \",\" || input.type == \">\";\n}\nfunction parseExprSequence(input) {\n    let start = input.start, exprs = [], markers = [none$2];\n    do {\n        // Add markers at this position\n        for (;;) {\n            let localStart = input.start, markerType;\n            if (input.eat(\"~\"))\n                markerType = \"ambig\";\n            else if (input.eat(\"!\"))\n                markerType = \"prec\";\n            else\n                break;\n            markers[markers.length - 1] =\n                markers[markers.length - 1].concat(new ConflictMarker(localStart, parseIdent(input), markerType));\n        }\n        if (endOfSequence(input))\n            break;\n        exprs.push(parseExprSuffix(input));\n        markers.push(none$2);\n    } while (!endOfSequence(input));\n    if (exprs.length == 1 && markers.every(ms => ms.length == 0))\n        return exprs[0];\n    return new SequenceExpression(start, exprs, markers, !exprs.length);\n}\nfunction parseExprChoice(input) {\n    let start = input.start, left = parseExprSequence(input);\n    if (!input.eat(\"|\"))\n        return left;\n    let exprs = [left];\n    do {\n        exprs.push(parseExprSequence(input));\n    } while (input.eat(\"|\"));\n    let empty = exprs.find(s => s instanceof SequenceExpression && s.empty);\n    if (empty)\n        input.raise(\"Empty expression in choice operator. If this is intentional, use () to make it explicit.\", empty.start);\n    return new ChoiceExpression(start, exprs);\n}\nfunction parseIdent(input) {\n    if (input.type != \"id\")\n        input.unexpected();\n    let start = input.start, name = input.value;\n    input.next();\n    return new Identifier(start, name);\n}\nfunction parsePrecedence(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let items = [];\n    while (!input.eat(\"}\")) {\n        if (items.length)\n            input.eat(\",\");\n        items.push({\n            id: parseIdent(input),\n            type: input.eat(\"at\", \"left\") ? \"left\" : input.eat(\"at\", \"right\") ? \"right\" : input.eat(\"at\", \"cut\") ? \"cut\" : null\n        });\n    }\n    return new PrecDeclaration(start, items);\n}\nfunction parseTokens(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let tokenRules = [];\n    let literals = [];\n    let precedences = [];\n    let conflicts = [];\n    while (!input.eat(\"}\")) {\n        if (input.type == \"at\" && input.value == \"precedence\") {\n            precedences.push(parseTokenPrecedence(input));\n        }\n        else if (input.type == \"at\" && input.value == \"conflict\") {\n            conflicts.push(parseTokenConflict(input));\n        }\n        else if (input.type == \"string\") {\n            literals.push(new LiteralDeclaration(input.start, input.expect(\"string\"), parseProps(input)));\n        }\n        else {\n            tokenRules.push(parseRule(input));\n        }\n    }\n    return new TokenDeclaration(start, precedences, conflicts, tokenRules, literals);\n}\nfunction parseLocalTokens(input, start) {\n    input.expect(\"{\");\n    let tokenRules = [];\n    let precedences = [];\n    let fallback = null;\n    while (!input.eat(\"}\")) {\n        if (input.type == \"at\" && input.value == \"precedence\") {\n            precedences.push(parseTokenPrecedence(input));\n        }\n        else if (input.eat(\"at\", \"else\") && !fallback) {\n            fallback = { id: parseIdent(input), props: parseProps(input) };\n        }\n        else {\n            tokenRules.push(parseRule(input));\n        }\n    }\n    return new LocalTokenDeclaration(start, precedences, tokenRules, fallback);\n}\nfunction parseTokenPrecedence(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let tokens = [];\n    while (!input.eat(\"}\")) {\n        if (tokens.length)\n            input.eat(\",\");\n        let expr = parseExprInner(input);\n        if (expr instanceof LiteralExpression || expr instanceof NameExpression)\n            tokens.push(expr);\n        else\n            input.raise(`Invalid expression in token precedences`, expr.start);\n    }\n    return new TokenPrecDeclaration(start, tokens);\n}\nfunction parseTokenConflict(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let a = parseExprInner(input);\n    if (!(a instanceof LiteralExpression || a instanceof NameExpression))\n        input.raise(`Invalid expression in token conflict`, a.start);\n    input.eat(\",\");\n    let b = parseExprInner(input);\n    if (!(b instanceof LiteralExpression || b instanceof NameExpression))\n        input.raise(`Invalid expression in token conflict`, b.start);\n    input.expect(\"}\");\n    return new TokenConflictDeclaration(start, a, b);\n}\nfunction parseExternalTokenSet(input) {\n    let tokens = [];\n    input.expect(\"{\");\n    while (!input.eat(\"}\")) {\n        if (tokens.length)\n            input.eat(\",\");\n        let id = parseIdent(input);\n        let props = parseProps(input);\n        tokens.push({ id, props });\n    }\n    return tokens;\n}\nfunction parseExternalTokens(input, start) {\n    let id = parseIdent(input);\n    input.expect(\"id\", \"from\");\n    let from = input.expect(\"string\");\n    return new ExternalTokenDeclaration(start, id, from, parseExternalTokenSet(input));\n}\nfunction parseExternalSpecialize(input, type, start) {\n    let token = parseBracedExpr(input);\n    let id = parseIdent(input);\n    input.expect(\"id\", \"from\");\n    let from = input.expect(\"string\");\n    return new ExternalSpecializeDeclaration(start, type, token, id, from, parseExternalTokenSet(input));\n}\nfunction parseExternalPropSource(input, start) {\n    let id = parseIdent(input);\n    input.expect(\"id\", \"from\");\n    return new ExternalPropSourceDeclaration(start, id, input.expect(\"string\"));\n}\nfunction parseExternalProp(input, start) {\n    let externalID = parseIdent(input);\n    let id = input.eat(\"id\", \"as\") ? parseIdent(input) : externalID;\n    input.expect(\"id\", \"from\");\n    let from = input.expect(\"string\");\n    return new ExternalPropDeclaration(start, id, externalID, from);\n}\nfunction readString(string) {\n    let point = /\\\\(?:u\\{([\\da-f]+)\\}|u([\\da-f]{4})|x([\\da-f]{2})|([ntbrf0])|(.))|[^]/yig;\n    let out = \"\", m;\n    while (m = point.exec(string)) {\n        let [all, u1, u2, u3, single, unknown] = m;\n        if (u1 || u2 || u3)\n            out += String.fromCodePoint(parseInt(u1 || u2 || u3, 16));\n        else if (single)\n            out += single == \"n\" ? \"\\n\" : single == \"t\" ? \"\\t\" : single == \"0\" ? \"\\0\" : single == \"r\" ? \"\\r\" : single == \"f\" ? \"\\f\" : \"\\b\";\n        else if (unknown)\n            out += unknown;\n        else\n            out += all;\n    }\n    return out;\n}\n\nfunction hash(a, b) { return (a << 5) + a + b; }\nfunction hashString(h, s) {\n    for (let i = 0; i < s.length; i++)\n        h = hash(h, s.charCodeAt(i));\n    return h;\n}\n\nconst verbose = (typeof process != \"undefined\" && process.env.LOG) || \"\";\nconst timing = /\\btime\\b/.test(verbose);\nconst time = timing ? (label, f) => {\n    let t0 = Date.now();\n    let result = f();\n    console.log(`${label} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);\n    return result;\n} : (_label, f) => f();\n\nclass Pos {\n    constructor(rule, pos, \n    // NOTE `ahead` and `ambigAhead` aren't mutated anymore after `finish()` has been called\n    ahead, ambigAhead, skipAhead, via) {\n        this.rule = rule;\n        this.pos = pos;\n        this.ahead = ahead;\n        this.ambigAhead = ambigAhead;\n        this.skipAhead = skipAhead;\n        this.via = via;\n        this.hash = 0;\n    }\n    finish() {\n        let h = hash(hash(this.rule.id, this.pos), this.skipAhead.hash);\n        for (let a of this.ahead)\n            h = hash(h, a.hash);\n        for (let group of this.ambigAhead)\n            h = hashString(h, group);\n        this.hash = h;\n        return this;\n    }\n    get next() {\n        return this.pos < this.rule.parts.length ? this.rule.parts[this.pos] : null;\n    }\n    advance() {\n        return new Pos(this.rule, this.pos + 1, this.ahead, this.ambigAhead, this.skipAhead, this.via).finish();\n    }\n    get skip() {\n        return this.pos == this.rule.parts.length ? this.skipAhead : this.rule.skip;\n    }\n    cmp(pos) {\n        return this.rule.cmp(pos.rule) || this.pos - pos.pos || this.skipAhead.hash - pos.skipAhead.hash ||\n            cmpSet(this.ahead, pos.ahead, (a, b) => a.cmp(b)) || cmpSet(this.ambigAhead, pos.ambigAhead, cmpStr);\n    }\n    eqSimple(pos) {\n        return pos.rule == this.rule && pos.pos == this.pos;\n    }\n    toString() {\n        let parts = this.rule.parts.map(t => t.name);\n        parts.splice(this.pos, 0, \"\");\n        return `${this.rule.name} -> ${parts.join(\" \")}`;\n    }\n    eq(other) {\n        return this == other ||\n            this.hash == other.hash && this.rule == other.rule && this.pos == other.pos && this.skipAhead == other.skipAhead &&\n                sameSet(this.ahead, other.ahead) &&\n                sameSet(this.ambigAhead, other.ambigAhead);\n    }\n    trail(maxLen = 60) {\n        let result = [];\n        for (let pos = this; pos; pos = pos.via) {\n            for (let i = pos.pos - 1; i >= 0; i--)\n                result.push(pos.rule.parts[i]);\n        }\n        let value = result.reverse().join(\" \");\n        if (value.length > maxLen)\n            value = value.slice(value.length - maxLen).replace(/.*? /, \" \");\n        return value;\n    }\n    conflicts(pos = this.pos) {\n        let result = this.rule.conflicts[pos];\n        if (pos == this.rule.parts.length && this.ambigAhead.length)\n            result = result.join(new Conflicts(0, this.ambigAhead));\n        return result;\n    }\n    static addOrigins(group, context) {\n        let result = group.slice();\n        for (let i = 0; i < result.length; i++) {\n            let next = result[i];\n            if (next.pos == 0)\n                for (let pos of context) {\n                    if (pos.next == next.rule.name && !result.includes(pos))\n                        result.push(pos);\n                }\n        }\n        return result;\n    }\n}\nfunction conflictsAt(group) {\n    let result = Conflicts.none;\n    for (let pos of group)\n        result = result.join(pos.conflicts());\n    return result;\n}\n// Applies automatic action precedence based on repeat productions.\n// These are left-associative, so reducing the `R -> R R` rule has\n// higher precedence.\nfunction compareRepeatPrec(a, b) {\n    for (let pos of a)\n        if (pos.rule.name.repeated) {\n            for (let posB of b)\n                if (posB.rule.name == pos.rule.name) {\n                    if (pos.rule.isRepeatWrap && pos.pos == 2)\n                        return 1;\n                    if (posB.rule.isRepeatWrap && posB.pos == 2)\n                        return -1;\n                }\n        }\n    return 0;\n}\nfunction cmpStr(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\nfunction termsAhead(rule, pos, after, first) {\n    let found = [];\n    for (let i = pos + 1; i < rule.parts.length; i++) {\n        let next = rule.parts[i], cont = false;\n        if (next.terminal) {\n            addTo(next, found);\n        }\n        else\n            for (let term of first[next.name]) {\n                if (term == null)\n                    cont = true;\n                else\n                    addTo(term, found);\n            }\n        if (!cont)\n            return found;\n    }\n    for (let a of after)\n        addTo(a, found);\n    return found;\n}\nfunction eqSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction sameSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i])\n            return false;\n    return true;\n}\nclass Shift {\n    constructor(term, target) {\n        this.term = term;\n        this.target = target;\n    }\n    eq(other) { return other instanceof Shift && this.term == other.term && other.target.id == this.target.id; }\n    cmp(other) { return other instanceof Reduce ? -1 : this.term.id - other.term.id || this.target.id - other.target.id; }\n    toString() { return \"s\" + this.target.id; }\n    map(mapping, states) {\n        let mapped = states[mapping[this.target.id]];\n        return mapped == this.target ? this : new Shift(this.term, mapped);\n    }\n}\nclass Reduce {\n    constructor(term, rule) {\n        this.term = term;\n        this.rule = rule;\n    }\n    eq(other) {\n        return other instanceof Reduce && this.term == other.term && other.rule.sameReduce(this.rule);\n    }\n    cmp(other) {\n        return other instanceof Shift ? 1 : this.term.id - other.term.id || this.rule.name.id - other.rule.name.id ||\n            this.rule.parts.length - other.rule.parts.length;\n    }\n    toString() { return `${this.rule.name.name}(${this.rule.parts.length})`; }\n    map() { return this; }\n}\nfunction hashPositions(set) {\n    let h = 5381;\n    for (let pos of set)\n        h = hash(h, pos.hash);\n    return h;\n}\nclass State {\n    constructor(id, set, flags = 0, skip, hash = hashPositions(set), startRule = null) {\n        this.id = id;\n        this.set = set;\n        this.flags = flags;\n        this.skip = skip;\n        this.hash = hash;\n        this.startRule = startRule;\n        this.actions = [];\n        this.actionPositions = [];\n        this.goto = [];\n        this.tokenGroup = -1;\n        this.defaultReduce = null;\n    }\n    toString() {\n        let actions = this.actions.map(t => t.term + \"=\" + t).join(\",\") +\n            (this.goto.length ? \" | \" + this.goto.map(g => g.term + \"=\" + g).join(\",\") : \"\");\n        return this.id + \": \" + this.set.filter(p => p.pos > 0).join() +\n            (this.defaultReduce ? `\\n  always ${this.defaultReduce.name}(${this.defaultReduce.parts.length})`\n                : actions.length ? \"\\n  \" + actions : \"\");\n    }\n    addActionInner(value, positions) {\n        check: for (let i = 0; i < this.actions.length; i++) {\n            let action = this.actions[i];\n            if (action.term == value.term) {\n                if (action.eq(value))\n                    return null;\n                let fullPos = Pos.addOrigins(positions, this.set), actionFullPos = Pos.addOrigins(this.actionPositions[i], this.set);\n                let conflicts = conflictsAt(fullPos), actionConflicts = conflictsAt(actionFullPos);\n                let diff = compareRepeatPrec(fullPos, actionFullPos) || conflicts.precedence - actionConflicts.precedence;\n                if (diff > 0) { // Drop the existing action\n                    this.actions.splice(i, 1);\n                    this.actionPositions.splice(i, 1);\n                    i--;\n                    continue check;\n                }\n                else if (diff < 0) { // Drop this one\n                    return null;\n                }\n                else if (conflicts.ambigGroups.some(g => actionConflicts.ambigGroups.includes(g))) { // Explicitly allowed ambiguity\n                    continue check;\n                }\n                else { // Not resolved\n                    return action;\n                }\n            }\n        }\n        this.actions.push(value);\n        this.actionPositions.push(positions);\n        return null;\n    }\n    addAction(value, positions, conflicts) {\n        let conflict = this.addActionInner(value, positions);\n        if (conflict) {\n            let conflictPos = this.actionPositions[this.actions.indexOf(conflict)][0];\n            let rules = [positions[0].rule.name, conflictPos.rule.name];\n            if (conflicts.some(c => c.rules.some(r => rules.includes(r))))\n                return;\n            let error;\n            if (conflict instanceof Shift)\n                error = `shift/reduce conflict between\\n  ${conflictPos}\\nand\\n  ${positions[0].rule}`;\n            else\n                error = `reduce/reduce conflict between\\n  ${conflictPos.rule}\\nand\\n  ${positions[0].rule}`;\n            error += `\\nWith input:\\n  ${positions[0].trail(70)}  ${value.term} `;\n            error += findConflictOrigin(conflictPos, positions[0]);\n            conflicts.push(new Conflict(error, rules));\n        }\n    }\n    getGoto(term) {\n        return this.goto.find(a => a.term == term);\n    }\n    hasSet(set) {\n        return eqSet(this.set, set);\n    }\n    finish() {\n        if (this.actions.length) {\n            let first = this.actions[0];\n            if (first instanceof Reduce) {\n                let { rule } = first;\n                if (this.actions.every(a => a instanceof Reduce && a.rule.sameReduce(rule)))\n                    this.defaultReduce = rule;\n            }\n        }\n        this.actions.sort((a, b) => a.cmp(b));\n        this.goto.sort((a, b) => a.cmp(b));\n    }\n    eq(other) {\n        let dThis = this.defaultReduce, dOther = other.defaultReduce;\n        if (dThis || dOther)\n            return dThis && dOther ? dThis.sameReduce(dOther) : false;\n        return this.skip == other.skip &&\n            this.tokenGroup == other.tokenGroup &&\n            eqSet(this.actions, other.actions) &&\n            eqSet(this.goto, other.goto);\n    }\n}\nfunction closure(set, first) {\n    let added = [], redo = [];\n    function addFor(name, ahead, ambigAhead, skipAhead, via) {\n        for (let rule of name.rules) {\n            let add = added.find(a => a.rule == rule);\n            if (!add) {\n                let existing = set.find(p => p.pos == 0 && p.rule == rule);\n                add = existing ? new Pos(rule, 0, existing.ahead.slice(), existing.ambigAhead, existing.skipAhead, existing.via)\n                    : new Pos(rule, 0, [], none$1, skipAhead, via);\n                added.push(add);\n            }\n            if (add.skipAhead != skipAhead)\n                throw new GenError(\"Inconsistent skip sets after \" + via.trail());\n            add.ambigAhead = union(add.ambigAhead, ambigAhead);\n            for (let term of ahead)\n                if (!add.ahead.includes(term)) {\n                    add.ahead.push(term);\n                    if (add.rule.parts.length && !add.rule.parts[0].terminal)\n                        addTo(add, redo);\n                }\n        }\n    }\n    for (let pos of set) {\n        let next = pos.next;\n        if (next && !next.terminal)\n            addFor(next, termsAhead(pos.rule, pos.pos, pos.ahead, first), pos.conflicts(pos.pos + 1).ambigGroups, pos.pos == pos.rule.parts.length - 1 ? pos.skipAhead : pos.rule.skip, pos);\n    }\n    while (redo.length) {\n        let add = redo.pop();\n        addFor(add.rule.parts[0], termsAhead(add.rule, 0, add.ahead, first), union(add.rule.conflicts[1].ambigGroups, add.rule.parts.length == 1 ? add.ambigAhead : none$1), add.rule.parts.length == 1 ? add.skipAhead : add.rule.skip, add);\n    }\n    let result = set.slice();\n    for (let add of added) {\n        add.ahead.sort((a, b) => a.hash - b.hash);\n        add.finish();\n        let origIndex = set.findIndex(p => p.pos == 0 && p.rule == add.rule);\n        if (origIndex > -1)\n            result[origIndex] = add;\n        else\n            result.push(add);\n    }\n    return result.sort((a, b) => a.cmp(b));\n}\nfunction addTo(value, array) {\n    if (!array.includes(value))\n        array.push(value);\n}\nfunction computeFirstSets(terms) {\n    let table = Object.create(null);\n    for (let t of terms.terms)\n        if (!t.terminal)\n            table[t.name] = [];\n    for (;;) {\n        let change = false;\n        for (let nt of terms.terms)\n            if (!nt.terminal)\n                for (let rule of nt.rules) {\n                    let set = table[nt.name];\n                    let found = false, startLen = set.length;\n                    for (let part of rule.parts) {\n                        found = true;\n                        if (part.terminal) {\n                            addTo(part, set);\n                        }\n                        else {\n                            for (let t of table[part.name]) {\n                                if (t == null)\n                                    found = false;\n                                else\n                                    addTo(t, set);\n                            }\n                        }\n                        if (found)\n                            break;\n                    }\n                    if (!found)\n                        addTo(null, set);\n                    if (set.length > startLen)\n                        change = true;\n                }\n        if (!change)\n            return table;\n    }\n}\nclass Core {\n    constructor(set, state) {\n        this.set = set;\n        this.state = state;\n    }\n}\nclass Conflict {\n    constructor(error, rules) {\n        this.error = error;\n        this.rules = rules;\n    }\n}\nfunction findConflictOrigin(a, b) {\n    if (a.eqSimple(b))\n        return \"\";\n    function via(root, start) {\n        let hist = [];\n        for (let p = start.via; !p.eqSimple(root); p = p.via)\n            hist.push(p);\n        if (!hist.length)\n            return \"\";\n        hist.unshift(start);\n        return hist.reverse().map((p, i) => \"\\n\" + \"  \".repeat(i + 1) + (p == start ? \"\" : \"via \") + p).join(\"\");\n    }\n    for (let p = a; p; p = p.via)\n        for (let p2 = b; p2; p2 = p2.via) {\n            if (p.eqSimple(p2))\n                return \"\\nShared origin: \" + p + via(p, a) + via(p, b);\n        }\n    return \"\";\n}\n// Builds a full LR(1) automaton\nfunction buildFullAutomaton(terms, startTerms, first) {\n    let states = [];\n    let cores = {};\n    let t0 = Date.now();\n    function getState(core, top) {\n        if (core.length == 0)\n            return null;\n        let coreHash = hashPositions(core), byHash = cores[coreHash];\n        let skip;\n        for (let pos of core) {\n            if (!skip)\n                skip = pos.skip;\n            else if (skip != pos.skip)\n                throw new GenError(\"Inconsistent skip sets after \" + pos.trail());\n        }\n        if (byHash)\n            for (let known of byHash)\n                if (eqSet(core, known.set)) {\n                    if (known.state.skip != skip)\n                        throw new GenError(\"Inconsistent skip sets after \" + known.set[0].trail());\n                    return known.state;\n                }\n        let set = closure(core, first);\n        let hash = hashPositions(set), found;\n        if (!top)\n            for (let state of states)\n                if (state.hash == hash && state.hasSet(set))\n                    found = state;\n        if (!found) {\n            found = new State(states.length, set, 0, skip, hash, top);\n            states.push(found);\n            if (timing && states.length % 500 == 0)\n                console.log(`${states.length} states after ${((Date.now() - t0) / 1000).toFixed(2)}s`);\n        }\n        (cores[coreHash] || (cores[coreHash] = [])).push(new Core(core, found));\n        return found;\n    }\n    for (const startTerm of startTerms) {\n        const startSkip = startTerm.rules.length ? startTerm.rules[0].skip : terms.names[\"%noskip\"];\n        getState(startTerm.rules.map(rule => new Pos(rule, 0, [terms.eof], none$1, startSkip, null).finish()), startTerm);\n    }\n    let conflicts = [];\n    for (let filled = 0; filled < states.length; filled++) {\n        let state = states[filled];\n        let byTerm = [], byTermPos = [], atEnd = [];\n        for (let pos of state.set) {\n            if (pos.pos == pos.rule.parts.length) {\n                if (!pos.rule.name.top)\n                    atEnd.push(pos);\n            }\n            else {\n                let next = pos.rule.parts[pos.pos];\n                let index = byTerm.indexOf(next);\n                if (index < 0) {\n                    byTerm.push(next);\n                    byTermPos.push([pos]);\n                }\n                else {\n                    byTermPos[index].push(pos);\n                }\n            }\n        }\n        for (let i = 0; i < byTerm.length; i++) {\n            let term = byTerm[i], positions = byTermPos[i].map(p => p.advance());\n            if (term.terminal) {\n                let set = applyCut(positions);\n                let next = getState(set);\n                if (next)\n                    state.addAction(new Shift(term, next), byTermPos[i], conflicts);\n            }\n            else {\n                let goto = getState(positions);\n                if (goto)\n                    state.goto.push(new Shift(term, goto));\n            }\n        }\n        let replaced = false;\n        for (let pos of atEnd)\n            for (let ahead of pos.ahead) {\n                let count = state.actions.length;\n                state.addAction(new Reduce(ahead, pos.rule), [pos], conflicts);\n                if (state.actions.length == count)\n                    replaced = true;\n            }\n        // If some actions were replaced by others, double-check whether\n        // goto entries are now superfluous (for example, in an operator\n        // precedence-related state that has a shift for `*` but only a\n        // reduce for `+`, we don't need a goto entry for rules that start\n        // with `+`)\n        if (replaced)\n            for (let i = 0; i < state.goto.length; i++) {\n                let start = first[state.goto[i].term.name];\n                if (!start.some(term => state.actions.some(a => a.term == term && (a instanceof Shift))))\n                    state.goto.splice(i--, 1);\n            }\n    }\n    if (conflicts.length)\n        throw new GenError(conflicts.map(c => c.error).join(\"\\n\\n\"));\n    // Resolve alwaysReduce and sort actions\n    for (let state of states)\n        state.finish();\n    if (timing)\n        console.log(`${states.length} states total.`);\n    return states;\n}\nfunction applyCut(set) {\n    let found = null, cut = 1;\n    for (let pos of set) {\n        let value = pos.rule.conflicts[pos.pos - 1].cut;\n        if (value < cut)\n            continue;\n        if (!found || value > cut) {\n            cut = value;\n            found = [];\n        }\n        found.push(pos);\n    }\n    return found || set;\n}\nfunction canMergeInner(a, b, mapping) {\n    for (let goto of a.goto)\n        for (let other of b.goto) {\n            if (goto.term == other.term && mapping[goto.target.id] != mapping[other.target.id])\n                return false;\n        }\n    actions: for (let action of a.actions) {\n        let conflict = false;\n        for (let other of b.actions)\n            if (other.term == action.term) {\n                if (action instanceof Shift\n                    ? other instanceof Shift && mapping[action.target.id] == mapping[other.target.id]\n                    : other.eq(action))\n                    continue actions;\n                conflict = true;\n            }\n        if (conflict)\n            return false;\n    }\n    return true;\n}\nfunction canMerge(a, b, mapping) {\n    return canMergeInner(a, b, mapping) && canMergeInner(b, a, mapping);\n}\nfunction mergeStates(states, mapping) {\n    let newStates = [];\n    for (let state of states) {\n        let newID = mapping[state.id];\n        if (!newStates[newID]) {\n            newStates[newID] = new State(newID, state.set, 0, state.skip, state.hash, state.startRule);\n            newStates[newID].tokenGroup = state.tokenGroup;\n            newStates[newID].defaultReduce = state.defaultReduce;\n        }\n    }\n    for (let state of states) {\n        let newID = mapping[state.id], target = newStates[newID];\n        target.flags |= state.flags;\n        for (let i = 0; i < state.actions.length; i++) {\n            let action = state.actions[i].map(mapping, newStates);\n            if (!target.actions.some(a => a.eq(action))) {\n                target.actions.push(action);\n                target.actionPositions.push(state.actionPositions[i]);\n            }\n        }\n        for (let goto of state.goto) {\n            let mapped = goto.map(mapping, newStates);\n            if (!target.goto.some(g => g.eq(mapped)))\n                target.goto.push(mapped);\n        }\n    }\n    return newStates;\n}\nclass Group {\n    constructor(origin, member) {\n        this.origin = origin;\n        this.members = [member];\n    }\n}\nfunction samePosSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].eqSimple(b[i]))\n            return false;\n    return true;\n}\n// Collapse an LR(1) automaton to an LALR-like automaton\nfunction collapseAutomaton(states) {\n    let mapping = [], groups = [];\n    assignGroups: for (let i = 0; i < states.length; i++) {\n        let state = states[i];\n        if (!state.startRule)\n            for (let j = 0; j < groups.length; j++) {\n                let group = groups[j], other = states[group.members[0]];\n                if (state.tokenGroup == other.tokenGroup &&\n                    state.skip == other.skip &&\n                    !other.startRule &&\n                    samePosSet(state.set, other.set)) {\n                    group.members.push(i);\n                    mapping.push(j);\n                    continue assignGroups;\n                }\n            }\n        mapping.push(groups.length);\n        groups.push(new Group(groups.length, i));\n    }\n    function spill(groupIndex, index) {\n        let group = groups[groupIndex], state = states[group.members[index]];\n        let pop = group.members.pop();\n        if (index != group.members.length)\n            group.members[index] = pop;\n        for (let i = groupIndex + 1; i < groups.length; i++) {\n            mapping[state.id] = i;\n            if (groups[i].origin == group.origin &&\n                groups[i].members.every(id => canMerge(state, states[id], mapping))) {\n                groups[i].members.push(state.id);\n                return;\n            }\n        }\n        mapping[state.id] = groups.length;\n        groups.push(new Group(group.origin, state.id));\n    }\n    for (let pass = 1;; pass++) {\n        let conflicts = false, t0 = Date.now();\n        for (let g = 0, startLen = groups.length; g < startLen; g++) {\n            let group = groups[g];\n            for (let i = 0; i < group.members.length - 1; i++) {\n                for (let j = i + 1; j < group.members.length; j++) {\n                    let idA = group.members[i], idB = group.members[j];\n                    if (!canMerge(states[idA], states[idB], mapping)) {\n                        conflicts = true;\n                        spill(g, j--);\n                    }\n                }\n            }\n        }\n        if (timing)\n            console.log(`Collapse pass ${pass}${conflicts ? `` : `, done`} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);\n        if (!conflicts)\n            return mergeStates(states, mapping);\n    }\n}\nfunction mergeIdentical(states) {\n    for (let pass = 1;; pass++) {\n        let mapping = [], didMerge = false, t0 = Date.now();\n        let newStates = [];\n        // Find states that either have the same alwaysReduce or the same\n        // actions, and merge them.\n        for (let i = 0; i < states.length; i++) {\n            let state = states[i];\n            let match = newStates.findIndex(s => state.eq(s));\n            if (match < 0) {\n                mapping[i] = newStates.length;\n                newStates.push(state);\n            }\n            else {\n                mapping[i] = match;\n                didMerge = true;\n                let other = newStates[match], add = null;\n                for (let pos of state.set)\n                    if (!other.set.some(p => p.eqSimple(pos)))\n                        (add || (add = [])).push(pos);\n                if (add)\n                    other.set = add.concat(other.set).sort((a, b) => a.cmp(b));\n            }\n        }\n        if (timing)\n            console.log(`Merge identical pass ${pass}${didMerge ? \"\" : \", done\"} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);\n        if (!didMerge)\n            return states;\n        // Make sure actions point at merged state objects\n        for (let state of newStates)\n            if (!state.defaultReduce) {\n                state.actions = state.actions.map(a => a.map(mapping, newStates));\n                state.goto = state.goto.map(a => a.map(mapping, newStates));\n            }\n        // Renumber ids\n        for (let i = 0; i < newStates.length; i++)\n            newStates[i].id = i;\n        states = newStates;\n    }\n}\nconst none$1 = [];\nfunction finishAutomaton(full) {\n    return mergeIdentical(collapseAutomaton(full));\n}\n\n// Encode numbers as groups of printable ascii characters\n//\n// - 0xffff, which is often used as placeholder, is encoded as \"~\"\n//\n// - The characters from \" \" (32) to \"}\" (125), excluding '\"' and\n//   \"\\\\\", indicate values from 0 to 92\n//\n// - The first bit in a 'digit' is used to indicate whether this is\n//   the end of a number.\n//\n// - That leaves 46 other values, which are actually significant.\n//\n// - The digits in a number are ordered from high to low significance.\nfunction digitToChar(digit) {\n    let ch = digit + 32 /* Encode.Start */;\n    if (ch >= 34 /* Encode.Gap1 */)\n        ch++;\n    if (ch >= 92 /* Encode.Gap2 */)\n        ch++;\n    return String.fromCharCode(ch);\n}\nfunction encode(value, max = 0xffff) {\n    if (value > max)\n        throw new Error(\"Trying to encode a number that's too big: \" + value);\n    if (value == 65535 /* Encode.BigVal */)\n        return String.fromCharCode(126 /* Encode.BigValCode */);\n    let result = \"\";\n    for (let first = 46 /* Encode.Base */;; first = 0) {\n        let low = value % 46 /* Encode.Base */, rest = value - low;\n        result = digitToChar(low + first) + result;\n        if (rest == 0)\n            break;\n        value = rest / 46 /* Encode.Base */;\n    }\n    return result;\n}\nfunction encodeArray(values, max = 0xffff) {\n    let result = '\"' + encode(values.length, 0xffffffff);\n    for (let i = 0; i < values.length; i++)\n        result += encode(values[i], max);\n    result += '\"';\n    return result;\n}\n\nconst none = [];\nclass Parts {\n    constructor(terms, conflicts) {\n        this.terms = terms;\n        this.conflicts = conflicts;\n    }\n    concat(other) {\n        if (this == Parts.none)\n            return other;\n        if (other == Parts.none)\n            return this;\n        let conflicts = null;\n        if (this.conflicts || other.conflicts) {\n            conflicts = this.conflicts ? this.conflicts.slice() : this.ensureConflicts();\n            let otherConflicts = other.ensureConflicts();\n            conflicts[conflicts.length - 1] = conflicts[conflicts.length - 1].join(otherConflicts[0]);\n            for (let i = 1; i < otherConflicts.length; i++)\n                conflicts.push(otherConflicts[i]);\n        }\n        return new Parts(this.terms.concat(other.terms), conflicts);\n    }\n    withConflicts(pos, conflicts) {\n        if (conflicts == Conflicts.none)\n            return this;\n        let array = this.conflicts ? this.conflicts.slice() : this.ensureConflicts();\n        array[pos] = array[pos].join(conflicts);\n        return new Parts(this.terms, array);\n    }\n    ensureConflicts() {\n        if (this.conflicts)\n            return this.conflicts;\n        let empty = [];\n        for (let i = 0; i <= this.terms.length; i++)\n            empty.push(Conflicts.none);\n        return empty;\n    }\n}\nParts.none = new Parts(none, null);\nfunction p(...terms) { return new Parts(terms, null); }\nclass BuiltRule {\n    constructor(id, args, term) {\n        this.id = id;\n        this.args = args;\n        this.term = term;\n    }\n    matches(expr) {\n        return this.id == expr.id.name && exprsEq(expr.args, this.args);\n    }\n    matchesRepeat(expr) {\n        return this.id == \"+\" && exprEq(expr.expr, this.args[0]);\n    }\n}\nclass Builder {\n    constructor(text, options) {\n        this.options = options;\n        this.terms = new TermSet;\n        this.specialized = Object.create(null);\n        this.tokenOrigins = Object.create(null);\n        this.rules = [];\n        this.built = [];\n        this.ruleNames = Object.create(null);\n        this.namespaces = Object.create(null);\n        this.namedTerms = Object.create(null);\n        this.termTable = Object.create(null);\n        this.knownProps = Object.create(null);\n        this.dynamicRulePrecedences = [];\n        this.definedGroups = [];\n        this.astRules = [];\n        this.currentSkip = [];\n        time(\"Parse\", () => {\n            this.input = new Input(text, options.fileName);\n            this.ast = this.input.parse();\n        });\n        let NP = NodeProp;\n        for (let prop in NP) {\n            if (NP[prop] instanceof NodeProp && !NP[prop].perNode)\n                this.knownProps[prop] = { prop: NP[prop], source: { name: prop, from: null } };\n        }\n        for (let prop of this.ast.externalProps) {\n            this.knownProps[prop.id.name] = {\n                prop: this.options.externalProp ? this.options.externalProp(prop.id.name) : new NodeProp(),\n                source: { name: prop.externalID.name, from: prop.source }\n            };\n        }\n        this.dialects = this.ast.dialects.map(d => d.name);\n        this.tokens = new MainTokenSet(this, this.ast.tokens);\n        this.localTokens = this.ast.localTokens.map(g => new LocalTokenSet(this, g));\n        this.externalTokens = this.ast.externalTokens.map(ext => new ExternalTokenSet(this, ext));\n        this.externalSpecializers = this.ast.externalSpecializers.map(decl => new ExternalSpecializer(this, decl));\n        time(\"Build rules\", () => {\n            let noSkip = this.newName(\"%noskip\", true);\n            this.defineRule(noSkip, []);\n            let mainSkip = this.ast.mainSkip ? this.newName(\"%mainskip\", true) : noSkip;\n            let scopedSkip = [], topRules = [];\n            for (let rule of this.ast.rules)\n                this.astRules.push({ skip: mainSkip, rule });\n            for (let rule of this.ast.topRules)\n                topRules.push({ skip: mainSkip, rule });\n            for (let scoped of this.ast.scopedSkip) {\n                let skip = noSkip, found = this.ast.scopedSkip.findIndex((sc, i) => i < scopedSkip.length && exprEq(sc.expr, scoped.expr));\n                if (found > -1)\n                    skip = scopedSkip[found];\n                else if (this.ast.mainSkip && exprEq(scoped.expr, this.ast.mainSkip))\n                    skip = mainSkip;\n                else if (!isEmpty(scoped.expr))\n                    skip = this.newName(\"%skip\", true);\n                scopedSkip.push(skip);\n                for (let rule of scoped.rules)\n                    this.astRules.push({ skip, rule });\n                for (let rule of scoped.topRules)\n                    topRules.push({ skip, rule });\n            }\n            for (let { rule } of this.astRules) {\n                this.unique(rule.id);\n            }\n            this.currentSkip.push(noSkip);\n            this.skipRules = mainSkip == noSkip ? [mainSkip] : [noSkip, mainSkip];\n            if (mainSkip != noSkip)\n                this.defineRule(mainSkip, this.normalizeExpr(this.ast.mainSkip));\n            for (let i = 0; i < this.ast.scopedSkip.length; i++) {\n                let skip = scopedSkip[i];\n                if (!this.skipRules.includes(skip)) {\n                    this.skipRules.push(skip);\n                    if (skip != noSkip)\n                        this.defineRule(skip, this.normalizeExpr(this.ast.scopedSkip[i].expr));\n                }\n            }\n            this.currentSkip.pop();\n            for (let { rule, skip } of topRules.sort((a, b) => a.rule.start - b.rule.start)) {\n                this.unique(rule.id);\n                this.used(rule.id.name);\n                this.currentSkip.push(skip);\n                let { name, props } = this.nodeInfo(rule.props, \"a\", rule.id.name, none, none, rule.expr);\n                let term = this.terms.makeTop(name, props);\n                this.namedTerms[name] = term;\n                this.defineRule(term, this.normalizeExpr(rule.expr));\n                this.currentSkip.pop();\n            }\n            for (let ext of this.externalSpecializers)\n                ext.finish();\n            for (let { skip, rule } of this.astRules) {\n                if (this.ruleNames[rule.id.name] && isExported(rule) && !rule.params.length) {\n                    this.buildRule(rule, [], skip, false);\n                    if (rule.expr instanceof SequenceExpression && rule.expr.exprs.length == 0)\n                        this.used(rule.id.name);\n                }\n            }\n        });\n        for (let name in this.ruleNames) {\n            let value = this.ruleNames[name];\n            if (value)\n                this.warn(`Unused rule '${value.name}'`, value.start);\n        }\n        this.tokens.takePrecedences();\n        this.tokens.takeConflicts();\n        for (let { name, group, rule } of this.definedGroups)\n            this.defineGroup(name, group, rule);\n        this.checkGroups();\n    }\n    unique(id) {\n        if (id.name in this.ruleNames)\n            this.raise(`Duplicate definition of rule '${id.name}'`, id.start);\n        this.ruleNames[id.name] = id;\n    }\n    used(name) {\n        this.ruleNames[name] = null;\n    }\n    newName(base, nodeName = null, props = {}) {\n        for (let i = nodeName ? 0 : 1;; i++) {\n            let name = i ? `${base}-${i}` : base;\n            if (!this.terms.names[name])\n                return this.terms.makeNonTerminal(name, nodeName === true ? null : nodeName, props);\n        }\n    }\n    prepareParser() {\n        let rules = time(\"Simplify rules\", () => simplifyRules(this.rules, [\n            ...this.skipRules,\n            ...this.terms.tops\n        ]));\n        let { nodeTypes, names: termNames, minRepeatTerm, maxTerm } = this.terms.finish(rules);\n        for (let prop in this.namedTerms)\n            this.termTable[prop] = this.namedTerms[prop].id;\n        if (/\\bgrammar\\b/.test(verbose))\n            console.log(rules.join(\"\\n\"));\n        let startTerms = this.terms.tops.slice();\n        let first = computeFirstSets(this.terms);\n        let skipInfo = this.skipRules.map((name, id) => {\n            let skip = [], startTokens = [], rules = [];\n            for (let rule of name.rules) {\n                if (!rule.parts.length)\n                    continue;\n                let start = rule.parts[0];\n                for (let t of start.terminal ? [start] : first[start.name] || [])\n                    if (!startTokens.includes(t))\n                        startTokens.push(t);\n                if (start.terminal && rule.parts.length == 1 && !rules.some(r => r != rule && r.parts[0] == start))\n                    skip.push(start);\n                else\n                    rules.push(rule);\n            }\n            name.rules = rules;\n            if (rules.length)\n                startTerms.push(name);\n            return { skip, rule: rules.length ? name : null, startTokens, id };\n        });\n        let fullTable = time(\"Build full automaton\", () => buildFullAutomaton(this.terms, startTerms, first));\n        let localTokens = this.localTokens\n            .map((grp, i) => grp.buildLocalGroup(fullTable, skipInfo, i));\n        let { tokenGroups, tokenPrec, tokenData } = time(\"Build token groups\", () => this.tokens.buildTokenGroups(fullTable, skipInfo, localTokens.length));\n        let table = time(\"Finish automaton\", () => finishAutomaton(fullTable));\n        let skipState = findSkipStates(table, this.terms.tops);\n        if (/\\blr\\b/.test(verbose))\n            console.log(table.join(\"\\n\"));\n        let specialized = [];\n        for (let ext of this.externalSpecializers)\n            specialized.push(ext);\n        for (let name in this.specialized)\n            specialized.push({ token: this.terms.names[name], table: buildSpecializeTable(this.specialized[name]) });\n        let tokStart = (tokenizer) => {\n            if (tokenizer instanceof ExternalTokenSet)\n                return tokenizer.ast.start;\n            return this.tokens.ast ? this.tokens.ast.start : -1;\n        };\n        let tokenizers = tokenGroups\n            .concat(this.externalTokens)\n            .sort((a, b) => tokStart(a) - tokStart(b))\n            .concat(localTokens);\n        let data = new DataBuilder;\n        let skipData = skipInfo.map(info => {\n            let actions = [];\n            for (let term of info.skip)\n                actions.push(term.id, 0, 262144 /* Action.StayFlag */ >> 16);\n            if (info.rule) {\n                let state = table.find(s => s.startRule == info.rule);\n                for (let action of state.actions)\n                    actions.push(action.term.id, state.id, 131072 /* Action.GotoFlag */ >> 16);\n            }\n            actions.push(65535 /* Seq.End */, 0 /* Seq.Done */);\n            return data.storeArray(actions);\n        });\n        let states = time(\"Finish states\", () => {\n            let states = new Uint32Array(table.length * 6 /* ParseState.Size */);\n            let forceReductions = this.computeForceReductions(table, skipInfo);\n            let finishCx = new FinishStateContext(tokenizers, data, states, skipData, skipInfo, table, this);\n            for (let s of table)\n                finishCx.finish(s, skipState(s.id), forceReductions[s.id]);\n            return states;\n        });\n        let dialects = Object.create(null);\n        for (let i = 0; i < this.dialects.length; i++)\n            dialects[this.dialects[i]] = data.storeArray((this.tokens.byDialect[i] || none).map(t => t.id).concat(65535 /* Seq.End */));\n        let dynamicPrecedences = null;\n        if (this.dynamicRulePrecedences.length) {\n            dynamicPrecedences = Object.create(null);\n            for (let { rule, prec } of this.dynamicRulePrecedences)\n                dynamicPrecedences[rule.id] = prec;\n        }\n        let topRules = Object.create(null);\n        for (let term of this.terms.tops)\n            topRules[term.nodeName] = [table.find(state => state.startRule == term).id, term.id];\n        let precTable = data.storeArray(tokenPrec.concat(65535 /* Seq.End */));\n        let { nodeProps, skippedTypes } = this.gatherNodeProps(nodeTypes);\n        return {\n            states,\n            stateData: data.finish(),\n            goto: computeGotoTable(table),\n            nodeNames: nodeTypes.filter(t => t.id < minRepeatTerm).map(t => t.nodeName).join(\" \"),\n            nodeProps,\n            skippedTypes,\n            maxTerm,\n            repeatNodeCount: nodeTypes.length - minRepeatTerm,\n            tokenizers,\n            tokenData,\n            topRules,\n            dialects,\n            dynamicPrecedences,\n            specialized,\n            tokenPrec: precTable,\n            termNames\n        };\n    }\n    getParser() {\n        let { states, stateData, goto, nodeNames, nodeProps: rawNodeProps, skippedTypes, maxTerm, repeatNodeCount, tokenizers, tokenData, topRules, dialects, dynamicPrecedences, specialized: rawSpecialized, tokenPrec, termNames } = this.prepareParser();\n        let specialized = rawSpecialized.map(v => {\n            if (v instanceof ExternalSpecializer) {\n                let ext = this.options.externalSpecializer(v.ast.id.name, this.termTable);\n                return {\n                    term: v.term.id,\n                    get: (value, stack) => (ext(value, stack) << 1) |\n                        (v.ast.type == \"extend\" ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */),\n                    external: ext,\n                    extend: v.ast.type == \"extend\"\n                };\n            }\n            else {\n                return { term: v.token.id, get: (value) => v.table[value] || -1 };\n            }\n        });\n        return LRParser.deserialize({\n            version: 14 /* File.Version */,\n            states,\n            stateData,\n            goto,\n            nodeNames,\n            maxTerm,\n            repeatNodeCount,\n            nodeProps: rawNodeProps.map(({ prop, terms }) => [this.knownProps[prop].prop, ...terms]),\n            propSources: !this.options.externalPropSource ? undefined\n                : this.ast.externalPropSources.map(s => this.options.externalPropSource(s.id.name)),\n            skippedNodes: skippedTypes,\n            tokenData,\n            tokenizers: tokenizers.map(tok => tok.create()),\n            context: this.ast.context ? this.options.contextTracker : undefined,\n            topRules,\n            dialects,\n            dynamicPrecedences,\n            specialized,\n            tokenPrec,\n            termNames\n        });\n    }\n    getParserFile() {\n        let { states, stateData, goto, nodeNames, nodeProps: rawNodeProps, skippedTypes, maxTerm, repeatNodeCount, tokenizers: rawTokenizers, tokenData, topRules, dialects: rawDialects, dynamicPrecedences, specialized: rawSpecialized, tokenPrec, termNames } = this.prepareParser();\n        let mod = this.options.moduleStyle || \"es\";\n        let gen = \"// This file was generated by lezer-generator. You probably shouldn't edit it.\\n\", head = gen;\n        let imports = {}, imported = Object.create(null);\n        let defined = Object.create(null);\n        for (let word of KEYWORDS)\n            defined[word] = true;\n        let exportName = this.options.exportName || \"parser\";\n        defined[exportName] = true;\n        let getName = (prefix) => {\n            for (let i = 0;; i++) {\n                let id = prefix + (i ? \"_\" + i : \"\");\n                if (!defined[id])\n                    return id;\n            }\n        };\n        let importName = (name, source, prefix = name) => {\n            let spec = name + \" from \" + source;\n            if (imported[spec])\n                return imported[spec];\n            let src = JSON.stringify(source), varName = name;\n            if (name in defined) {\n                varName = getName(prefix);\n                name += `${mod == \"cjs\" ? \":\" : \" as\"} ${varName}`;\n            }\n            defined[varName] = true;\n            (imports[src] || (imports[src] = [])).push(name);\n            return imported[spec] = varName;\n        };\n        let lrParser = importName(\"LRParser\", \"@lezer/lr\");\n        let tokenizers = rawTokenizers.map(tok => tok.createSource(importName));\n        let context = this.ast.context ? importName(this.ast.context.id.name, this.ast.context.source) : null;\n        let nodeProps = rawNodeProps.map(({ prop, terms }) => {\n            let { source } = this.knownProps[prop];\n            let propID = source.from ? importName(source.name, source.from) : JSON.stringify(source.name);\n            return `[${propID}, ${terms.map(serializePropValue).join(\",\")}]`;\n        });\n        function specializationTableString(table) {\n            return \"{__proto__:null,\" + Object.keys(table).map(key => `${/\\W/.test(key) ? JSON.stringify(key) : key}:${table[key]}`)\n                .join(\", \") + \"}\";\n        }\n        let specHead = \"\";\n        let specialized = rawSpecialized.map(v => {\n            if (v instanceof ExternalSpecializer) {\n                let name = importName(v.ast.id.name, v.ast.source);\n                return `{term: ${v.term.id}, get: (value, stack) => (${name}(value, stack) << 1)${v.ast.type == \"extend\" ? ` | ${1 /* Specialize.Extend */}` : ''}, external: ${name}${v.ast.type == \"extend\" ? ', extend: true' : ''}}`;\n            }\n            else {\n                let tableName = getName(\"spec_\" + v.token.name.replace(/\\W/g, \"\"));\n                defined[tableName] = true;\n                specHead += `const ${tableName} = ${specializationTableString(v.table)}\\n`;\n                return `{term: ${v.token.id}, get: value => ${tableName}[value] || -1}`;\n            }\n        });\n        let propSources = this.ast.externalPropSources.map(s => importName(s.id.name, s.source));\n        for (let source in imports) {\n            if (mod == \"cjs\")\n                head += `const {${imports[source].join(\", \")}} = require(${source})\\n`;\n            else\n                head += `import {${imports[source].join(\", \")}} from ${source}\\n`;\n        }\n        head += specHead;\n        function serializePropValue(value) {\n            return typeof value != \"string\" || /^(true|false|\\d+(\\.\\d+)?|\\.\\d+)$/.test(value) ? value : JSON.stringify(value);\n        }\n        let dialects = Object.keys(rawDialects).map(d => `${d}: ${rawDialects[d]}`);\n        let parserStr = `${lrParser}.deserialize({\n  version: ${14 /* File.Version */},\n  states: ${encodeArray(states, 0xffffffff)},\n  stateData: ${encodeArray(stateData)},\n  goto: ${encodeArray(goto)},\n  nodeNames: ${JSON.stringify(nodeNames)},\n  maxTerm: ${maxTerm}${context ? `,\n  context: ${context}` : \"\"}${nodeProps.length ? `,\n  nodeProps: [\n    ${nodeProps.join(\",\\n    \")}\n  ]` : \"\"}${propSources.length ? `,\n  propSources: [${propSources.join()}]` : \"\"}${skippedTypes.length ? `,\n  skippedNodes: ${JSON.stringify(skippedTypes)}` : \"\"},\n  repeatNodeCount: ${repeatNodeCount},\n  tokenData: ${encodeArray(tokenData)},\n  tokenizers: [${tokenizers.join(\", \")}],\n  topRules: ${JSON.stringify(topRules)}${dialects.length ? `,\n  dialects: {${dialects.join(\", \")}}` : \"\"}${dynamicPrecedences ? `,\n  dynamicPrecedences: ${JSON.stringify(dynamicPrecedences)}` : \"\"}${specialized.length ? `,\n  specialized: [${specialized.join(\",\")}]` : \"\"},\n  tokenPrec: ${tokenPrec}${this.options.includeNames ? `,\n  termNames: ${JSON.stringify(termNames)}` : ''}\n})`;\n        let terms = [];\n        for (let name in this.termTable) {\n            let id = name;\n            if (KEYWORDS.includes(id))\n                for (let i = 1;; i++) {\n                    id = \"_\".repeat(i) + name;\n                    if (!(id in this.termTable))\n                        break;\n                }\n            terms.push(`${id}${mod == \"cjs\" ? \":\" : \" =\"} ${this.termTable[name]}`);\n        }\n        for (let id = 0; id < this.dialects.length; id++)\n            terms.push(`Dialect_${this.dialects[id]}${mod == \"cjs\" ? \":\" : \" =\"} ${id}`);\n        return {\n            parser: head + (mod == \"cjs\" ? `exports.${exportName} = ${parserStr}\\n` : `export const ${exportName} = ${parserStr}\\n`),\n            terms: mod == \"cjs\" ? `${gen}module.exports = {\\n  ${terms.join(\",\\n  \")}\\n}`\n                : `${gen}export const\\n  ${terms.join(\",\\n  \")}\\n`\n        };\n    }\n    gatherNonSkippedNodes() {\n        let seen = Object.create(null);\n        let work = [];\n        let add = (term) => {\n            if (!seen[term.id]) {\n                seen[term.id] = true;\n                work.push(term);\n            }\n        };\n        this.terms.tops.forEach(add);\n        for (let i = 0; i < work.length; i++) {\n            for (let rule of work[i].rules)\n                for (let part of rule.parts)\n                    add(part);\n        }\n        return seen;\n    }\n    gatherNodeProps(nodeTypes) {\n        let notSkipped = this.gatherNonSkippedNodes(), skippedTypes = [];\n        let nodeProps = [];\n        for (let type of nodeTypes) {\n            if (!notSkipped[type.id] && !type.error)\n                skippedTypes.push(type.id);\n            for (let prop in type.props) {\n                let known = this.knownProps[prop];\n                if (!known)\n                    throw new GenError(\"No known prop type for \" + prop);\n                if (known.source.from == null && (known.source.name == \"repeated\" || known.source.name == \"error\"))\n                    continue;\n                let rec = nodeProps.find(r => r.prop == prop);\n                if (!rec)\n                    nodeProps.push(rec = { prop, values: {} });\n                (rec.values[type.props[prop]] || (rec.values[type.props[prop]] = [])).push(type.id);\n            }\n        }\n        return {\n            nodeProps: nodeProps.map(({ prop, values }) => {\n                let terms = [];\n                for (let val in values) {\n                    let ids = values[val];\n                    if (ids.length == 1) {\n                        terms.push(ids[0], val);\n                    }\n                    else {\n                        terms.push(-ids.length);\n                        for (let id of ids)\n                            terms.push(id);\n                        terms.push(val);\n                    }\n                }\n                return { prop, terms };\n            }),\n            skippedTypes\n        };\n    }\n    makeTerminal(name, tag, props) {\n        return this.terms.makeTerminal(this.terms.uniqueName(name), tag, props);\n    }\n    computeForceReductions(states, skipInfo) {\n        // This finds a forced reduction for every state, trying to guard\n        // against cyclic forced reductions, where a given parse stack can\n        // endlessly continue running forced reductions without making any\n        // progress.\n        //\n        // This occurs with length-1 reductions. We never generate\n        // length-0 reductions, and length-2+ reductions always shrink the\n        // stack, so they are guaranteed to make progress.\n        //\n        // If there are states S1 and S2 whose forced reductions reduce\n        // terms T1 and T2 respectively, both with a length of 1, _and_\n        // there is a state S3, which has goto entries T1 -> S2, T2 -> S1,\n        // you can get cyclic reductions. Of course, the cycle may also\n        // contain more than two steps.\n        let reductions = [];\n        let candidates = [];\n        // A map from terms to states that they are mapped to in goto\n        // entries.\n        let gotoEdges = Object.create(null);\n        for (let state of states) {\n            reductions.push(0);\n            for (let edge of state.goto) {\n                let array = gotoEdges[edge.term.id] || (gotoEdges[edge.term.id] = []);\n                let found = array.find(o => o.target == edge.target.id);\n                if (found)\n                    found.parents.push(state.id);\n                else\n                    array.push({ parents: [state.id], target: edge.target.id });\n            }\n            candidates[state.id] = state.set.filter(pos => pos.pos > 0 && !pos.rule.name.top)\n                .sort((a, b) => b.pos - a.pos || a.rule.parts.length - b.rule.parts.length);\n        }\n        // Mapping from state ids to terms that that state has a length-1\n        // forced reduction for.\n        let length1Reductions = Object.create(null);\n        function createsCycle(term, startState, parents = null) {\n            let edges = gotoEdges[term];\n            if (!edges)\n                return false;\n            return edges.some(val => {\n                let parentIntersection = parents ? parents.filter(id => val.parents.includes(id)) : val.parents;\n                if (parentIntersection.length == 0)\n                    return false;\n                if (val.target == startState)\n                    return true;\n                let found = length1Reductions[val.target];\n                return found != null && createsCycle(found, startState, parentIntersection);\n            });\n        }\n        for (let state of states) {\n            if (state.defaultReduce && state.defaultReduce.parts.length > 0) {\n                reductions[state.id] = reduceAction(state.defaultReduce, skipInfo);\n                if (state.defaultReduce.parts.length == 1)\n                    length1Reductions[state.id] = state.defaultReduce.name.id;\n            }\n        }\n        // To avoid painting states that only have one potential forced\n        // reduction into a corner, reduction assignment is done by\n        // candidate size, starting with the states with fewer candidates.\n        for (let setSize = 1;; setSize++) {\n            let done = true;\n            for (let state of states) {\n                if (state.defaultReduce)\n                    continue;\n                let set = candidates[state.id];\n                if (set.length != setSize) {\n                    if (set.length > setSize)\n                        done = false;\n                    continue;\n                }\n                for (let pos of set) {\n                    if (pos.pos != 1 || !createsCycle(pos.rule.name.id, state.id)) {\n                        reductions[state.id] = reduceAction(pos.rule, skipInfo, pos.pos);\n                        if (pos.pos == 1)\n                            length1Reductions[state.id] = pos.rule.name.id;\n                        break;\n                    }\n                }\n            }\n            if (done)\n                break;\n        }\n        return reductions;\n    }\n    substituteArgs(expr, args, params) {\n        if (args.length == 0)\n            return expr;\n        return expr.walk(expr => {\n            let found;\n            if (expr instanceof NameExpression &&\n                (found = params.findIndex(p => p.name == expr.id.name)) > -1) {\n                let arg = args[found];\n                if (expr.args.length) {\n                    if (arg instanceof NameExpression && !arg.args.length)\n                        return new NameExpression(expr.start, arg.id, expr.args);\n                    this.raise(`Passing arguments to a parameter that already has arguments`, expr.start);\n                }\n                return arg;\n            }\n            else if (expr instanceof InlineRuleExpression) {\n                let r = expr.rule, props = this.substituteArgsInProps(r.props, args, params);\n                return props == r.props ? expr :\n                    new InlineRuleExpression(expr.start, new RuleDeclaration(r.start, r.id, props, r.params, r.expr));\n            }\n            else if (expr instanceof SpecializeExpression) {\n                let props = this.substituteArgsInProps(expr.props, args, params);\n                return props == expr.props ? expr :\n                    new SpecializeExpression(expr.start, expr.type, props, expr.token, expr.content);\n            }\n            return expr;\n        });\n    }\n    substituteArgsInProps(props, args, params) {\n        let substituteInValue = (value) => {\n            let result = value;\n            for (let i = 0; i < value.length; i++) {\n                let part = value[i];\n                if (!part.name)\n                    continue;\n                let found = params.findIndex(p => p.name == part.name);\n                if (found < 0)\n                    continue;\n                if (result == value)\n                    result = value.slice();\n                let expr = args[found];\n                if (expr instanceof NameExpression && !expr.args.length)\n                    result[i] = new PropPart(part.start, expr.id.name, null);\n                else if (expr instanceof LiteralExpression)\n                    result[i] = new PropPart(part.start, expr.value, null);\n                else\n                    this.raise(`Trying to interpolate expression '${expr}' into a prop`, part.start);\n            }\n            return result;\n        };\n        let result = props;\n        for (let i = 0; i < props.length; i++) {\n            let prop = props[i], value = substituteInValue(prop.value);\n            if (value != prop.value) {\n                if (result == props)\n                    result = props.slice();\n                result[i] = new Prop(prop.start, prop.at, prop.name, value);\n            }\n        }\n        return result;\n    }\n    conflictsFor(markers) {\n        let here = Conflicts.none, atEnd = Conflicts.none;\n        for (let marker of markers) {\n            if (marker.type == \"ambig\") {\n                here = here.join(new Conflicts(0, [marker.id.name]));\n            }\n            else {\n                let precs = this.ast.precedences;\n                let index = precs ? precs.items.findIndex(item => item.id.name == marker.id.name) : -1;\n                if (index < 0)\n                    this.raise(`Reference to unknown precedence: '${marker.id.name}'`, marker.id.start);\n                let prec = precs.items[index], value = precs.items.length - index;\n                if (prec.type == \"cut\") {\n                    here = here.join(new Conflicts(0, none, value));\n                }\n                else {\n                    here = here.join(new Conflicts(value << 2));\n                    atEnd = atEnd.join(new Conflicts((value << 2) + (prec.type == \"left\" ? 1 : prec.type == \"right\" ? -1 : 0)));\n                }\n            }\n        }\n        return { here, atEnd };\n    }\n    raise(message, pos = 1) {\n        return this.input.raise(message, pos);\n    }\n    warn(message, pos = -1) {\n        let msg = this.input.message(message, pos);\n        if (this.options.warn)\n            this.options.warn(msg);\n        else\n            console.warn(msg);\n    }\n    defineRule(name, choices) {\n        let skip = this.currentSkip[this.currentSkip.length - 1];\n        for (let choice of choices)\n            this.rules.push(new Rule(name, choice.terms, choice.ensureConflicts(), skip));\n    }\n    resolve(expr) {\n        for (let built of this.built)\n            if (built.matches(expr))\n                return [p(built.term)];\n        let found = this.tokens.getToken(expr);\n        if (found)\n            return [p(found)];\n        for (let grp of this.localTokens) {\n            let found = grp.getToken(expr);\n            if (found)\n                return [p(found)];\n        }\n        for (let ext of this.externalTokens) {\n            let found = ext.getToken(expr);\n            if (found)\n                return [p(found)];\n        }\n        for (let ext of this.externalSpecializers) {\n            let found = ext.getToken(expr);\n            if (found)\n                return [p(found)];\n        }\n        let known = this.astRules.find(r => r.rule.id.name == expr.id.name);\n        if (!known)\n            return this.raise(`Reference to undefined rule '${expr.id.name}'`, expr.start);\n        if (known.rule.params.length != expr.args.length)\n            this.raise(`Wrong number or arguments for '${expr.id.name}'`, expr.start);\n        this.used(known.rule.id.name);\n        return [p(this.buildRule(known.rule, expr.args, known.skip))];\n    }\n    // For tree-balancing reasons, repeat expressions X+ have to be\n    // normalized to something like\n    //\n    //     R -> X | R R\n    //\n    // Returns the `R` term.\n    normalizeRepeat(expr) {\n        let known = this.built.find(b => b.matchesRepeat(expr));\n        if (known)\n            return p(known.term);\n        let name = expr.expr.prec < expr.prec ? `(${expr.expr})+` : `${expr.expr}+`;\n        let term = this.terms.makeRepeat(this.terms.uniqueName(name));\n        this.built.push(new BuiltRule(\"+\", [expr.expr], term));\n        this.defineRule(term, this.normalizeExpr(expr.expr).concat(p(term, term)));\n        return p(term);\n    }\n    normalizeSequence(expr) {\n        let result = expr.exprs.map(e => this.normalizeExpr(e));\n        let builder = this;\n        function complete(start, from, endConflicts) {\n            let { here, atEnd } = builder.conflictsFor(expr.markers[from]);\n            if (from == result.length)\n                return [start.withConflicts(start.terms.length, here.join(endConflicts))];\n            let choices = [];\n            for (let choice of result[from]) {\n                for (let full of complete(start.concat(choice).withConflicts(start.terms.length, here), from + 1, endConflicts.join(atEnd)))\n                    choices.push(full);\n            }\n            return choices;\n        }\n        return complete(Parts.none, 0, Conflicts.none);\n    }\n    normalizeExpr(expr) {\n        if (expr instanceof RepeatExpression && expr.kind == \"?\") {\n            return [Parts.none, ...this.normalizeExpr(expr.expr)];\n        }\n        else if (expr instanceof RepeatExpression) {\n            let repeated = this.normalizeRepeat(expr);\n            return expr.kind == \"+\" ? [repeated] : [Parts.none, repeated];\n        }\n        else if (expr instanceof ChoiceExpression) {\n            return expr.exprs.reduce((o, e) => o.concat(this.normalizeExpr(e)), []);\n        }\n        else if (expr instanceof SequenceExpression) {\n            return this.normalizeSequence(expr);\n        }\n        else if (expr instanceof LiteralExpression) {\n            return [p(this.tokens.getLiteral(expr))];\n        }\n        else if (expr instanceof NameExpression) {\n            return this.resolve(expr);\n        }\n        else if (expr instanceof SpecializeExpression) {\n            return [p(this.resolveSpecialization(expr))];\n        }\n        else if (expr instanceof InlineRuleExpression) {\n            return [p(this.buildRule(expr.rule, none, this.currentSkip[this.currentSkip.length - 1], true))];\n        }\n        else {\n            return this.raise(`This type of expression ('${expr}') may not occur in non-token rules`, expr.start);\n        }\n    }\n    buildRule(rule, args, skip, inline = false) {\n        let expr = this.substituteArgs(rule.expr, args, rule.params);\n        let { name: nodeName, props, dynamicPrec, inline: explicitInline, group, exported } = this.nodeInfo(rule.props || none, inline ? \"pg\" : \"pgi\", rule.id.name, args, rule.params, rule.expr);\n        if (exported && rule.params.length)\n            this.warn(`Can't export parameterized rules`, rule.start);\n        if (exported && inline)\n            this.warn(`Can't export inline rule`, rule.start);\n        let name = this.newName(rule.id.name + (args.length ? \"<\" + args.join(\",\") + \">\" : \"\"), nodeName || true, props);\n        if (explicitInline)\n            name.inline = true;\n        if (dynamicPrec)\n            this.registerDynamicPrec(name, dynamicPrec);\n        if ((name.nodeType || exported) && rule.params.length == 0) {\n            if (!nodeName)\n                name.preserve = true;\n            if (!inline)\n                this.namedTerms[exported || rule.id.name] = name;\n        }\n        if (!inline)\n            this.built.push(new BuiltRule(rule.id.name, args, name));\n        this.currentSkip.push(skip);\n        this.defineRule(name, this.normalizeExpr(expr));\n        this.currentSkip.pop();\n        if (group)\n            this.definedGroups.push({ name, group, rule });\n        return name;\n    }\n    nodeInfo(props, \n    // p for dynamic precedence, d for dialect, i for inline, g for group, a for disabling the ignore test for default name\n    allow, defaultName = null, args = none, params = none, expr, defaultProps) {\n        let result = {};\n        let name = defaultName && (allow.indexOf(\"a\") > -1 || !ignored(defaultName)) && !/ /.test(defaultName) ? defaultName : null;\n        let dialect = null, dynamicPrec = 0, inline = false, group = null, exported = null;\n        for (let prop of props) {\n            if (!prop.at) {\n                if (!this.knownProps[prop.name]) {\n                    let builtin = [\"name\", \"dialect\", \"dynamicPrecedence\", \"export\", \"isGroup\"].includes(prop.name)\n                        ? ` (did you mean '@${prop.name}'?)` : \"\";\n                    this.raise(`Unknown prop name '${prop.name}'${builtin}`, prop.start);\n                }\n                result[prop.name] = this.finishProp(prop, args, params);\n            }\n            else if (prop.name == \"name\") {\n                name = this.finishProp(prop, args, params);\n                if (/ /.test(name))\n                    this.raise(`Node names cannot have spaces ('${name}')`, prop.start);\n            }\n            else if (prop.name == \"dialect\") {\n                if (allow.indexOf(\"d\") < 0)\n                    this.raise(\"Can't specify a dialect on non-token rules\", props[0].start);\n                if (prop.value.length != 1 && !prop.value[0].value)\n                    this.raise(\"The '@dialect' rule prop must hold a plain string value\");\n                let dialectID = this.dialects.indexOf(prop.value[0].value);\n                if (dialectID < 0)\n                    this.raise(`Unknown dialect '${prop.value[0].value}'`, prop.value[0].start);\n                dialect = dialectID;\n            }\n            else if (prop.name == \"dynamicPrecedence\") {\n                if (allow.indexOf(\"p\") < 0)\n                    this.raise(\"Dynamic precedence can only be specified on nonterminals\");\n                if (prop.value.length != 1 || !/^-?(?:10|\\d)$/.test(prop.value[0].value))\n                    this.raise(\"The '@dynamicPrecedence' rule prop must hold an integer between -10 and 10\");\n                dynamicPrec = +prop.value[0].value;\n            }\n            else if (prop.name == \"inline\") {\n                if (prop.value.length)\n                    this.raise(\"'@inline' doesn't take a value\", prop.value[0].start);\n                if (allow.indexOf(\"i\") < 0)\n                    this.raise(\"Inline can only be specified on nonterminals\");\n                inline = true;\n            }\n            else if (prop.name == \"isGroup\") {\n                if (allow.indexOf(\"g\") < 0)\n                    this.raise(\"'@isGroup' can only be specified on nonterminals\");\n                group = prop.value.length ? this.finishProp(prop, args, params) : defaultName;\n            }\n            else if (prop.name == \"export\") {\n                if (prop.value.length)\n                    exported = this.finishProp(prop, args, params);\n                else\n                    exported = defaultName;\n            }\n            else {\n                this.raise(`Unknown built-in prop name '@${prop.name}'`, prop.start);\n            }\n        }\n        if (expr && this.ast.autoDelim && (name || hasProps(result))) {\n            let delim = this.findDelimiters(expr);\n            if (delim) {\n                addToProp(delim[0], \"closedBy\", delim[1].nodeName);\n                addToProp(delim[1], \"openedBy\", delim[0].nodeName);\n            }\n        }\n        if (defaultProps && hasProps(defaultProps)) {\n            for (let prop in defaultProps)\n                if (!(prop in result))\n                    result[prop] = defaultProps[prop];\n        }\n        if (hasProps(result) && !name)\n            this.raise(`Node has properties but no name`, props.length ? props[0].start : expr.start);\n        if (inline && (hasProps(result) || dialect || dynamicPrec))\n            this.raise(`Inline nodes can't have props, dynamic precedence, or a dialect`, props[0].start);\n        if (inline && name)\n            name = null;\n        return { name, props: result, dialect, dynamicPrec, inline, group, exported };\n    }\n    finishProp(prop, args, params) {\n        return prop.value.map(part => {\n            if (part.value)\n                return part.value;\n            let pos = params.findIndex(param => param.name == part.name);\n            if (pos < 0)\n                this.raise(`Property refers to '${part.name}', but no parameter by that name is in scope`, part.start);\n            let expr = args[pos];\n            if (expr instanceof NameExpression && !expr.args.length)\n                return expr.id.name;\n            if (expr instanceof LiteralExpression)\n                return expr.value;\n            return this.raise(`Expression '${expr}' can not be used as part of a property value`, part.start);\n        }).join(\"\");\n    }\n    resolveSpecialization(expr) {\n        let type = expr.type;\n        let { name, props, dialect } = this.nodeInfo(expr.props, \"d\");\n        let terminal = this.normalizeExpr(expr.token);\n        if (terminal.length != 1 || terminal[0].terms.length != 1 || !terminal[0].terms[0].terminal)\n            this.raise(`The first argument to '${type}' must resolve to a token`, expr.token.start);\n        let values;\n        if (expr.content instanceof LiteralExpression)\n            values = [expr.content.value];\n        else if ((expr.content instanceof ChoiceExpression) && expr.content.exprs.every(e => e instanceof LiteralExpression))\n            values = expr.content.exprs.map(expr => expr.value);\n        else\n            return this.raise(`The second argument to '${expr.type}' must be a literal or choice of literals`, expr.content.start);\n        let term = terminal[0].terms[0], token = null;\n        let table = this.specialized[term.name] || (this.specialized[term.name] = []);\n        for (let value of values) {\n            let known = table.find(sp => sp.value == value);\n            if (known == null) {\n                if (!token) {\n                    token = this.makeTerminal(term.name + \"/\" + JSON.stringify(value), name, props);\n                    if (dialect != null)\n                        (this.tokens.byDialect[dialect] || (this.tokens.byDialect[dialect] = [])).push(token);\n                }\n                table.push({ value, term: token, type, dialect, name });\n                this.tokenOrigins[token.name] = { spec: term };\n            }\n            else {\n                if (known.type != type)\n                    this.raise(`Conflicting specialization types for ${JSON.stringify(value)} of ${term.name} (${type} vs ${known.type})`, expr.start);\n                if (known.dialect != dialect)\n                    this.raise(`Conflicting dialects for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start);\n                if (known.name != name)\n                    this.raise(`Conflicting names for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start);\n                if (token && known.term != token)\n                    this.raise(`Conflicting specialization tokens for ${JSON.stringify(value)} of ${term.name}`, expr.start);\n                token = known.term;\n            }\n        }\n        return token;\n    }\n    findDelimiters(expr) {\n        if (!(expr instanceof SequenceExpression) || expr.exprs.length < 2)\n            return null;\n        let findToken = (expr) => {\n            if (expr instanceof LiteralExpression)\n                return { term: this.tokens.getLiteral(expr), str: expr.value };\n            if (expr instanceof NameExpression && expr.args.length == 0) {\n                let rule = this.ast.rules.find(r => r.id.name == expr.id.name);\n                if (rule)\n                    return findToken(rule.expr);\n                let token = this.tokens.rules.find(r => r.id.name == expr.id.name);\n                if (token && token.expr instanceof LiteralExpression)\n                    return { term: this.tokens.getToken(expr), str: token.expr.value };\n            }\n            return null;\n        };\n        let lastToken = findToken(expr.exprs[expr.exprs.length - 1]);\n        if (!lastToken || !lastToken.term.nodeName)\n            return null;\n        const brackets = [\"()\", \"[]\", \"{}\", \"<>\"];\n        let bracket = brackets.find(b => lastToken.str.indexOf(b[1]) > -1 && lastToken.str.indexOf(b[0]) < 0);\n        if (!bracket)\n            return null;\n        let firstToken = findToken(expr.exprs[0]);\n        if (!firstToken || !firstToken.term.nodeName ||\n            firstToken.str.indexOf(bracket[0]) < 0 || firstToken.str.indexOf(bracket[1]) > -1)\n            return null;\n        return [firstToken.term, lastToken.term];\n    }\n    registerDynamicPrec(term, prec) {\n        this.dynamicRulePrecedences.push({ rule: term, prec });\n        term.preserve = true;\n    }\n    defineGroup(rule, group, ast) {\n        var _a;\n        let recur = [];\n        let getNamed = (rule) => {\n            if (rule.nodeName)\n                return [rule];\n            if (recur.includes(rule))\n                this.raise(`Rule '${ast.id.name}' cannot define a group because it contains a non-named recursive rule ('${rule.name}')`, ast.start);\n            let result = [];\n            recur.push(rule);\n            for (let r of this.rules)\n                if (r.name == rule) {\n                    let names = r.parts.map(getNamed).filter(x => x.length);\n                    if (names.length > 1)\n                        this.raise(`Rule '${ast.id.name}' cannot define a group because some choices produce multiple named nodes`, ast.start);\n                    if (names.length == 1)\n                        for (let n of names[0])\n                            result.push(n);\n                }\n            recur.pop();\n            return result;\n        };\n        for (let name of getNamed(rule))\n            name.props[\"group\"] = (((_a = name.props[\"group\"]) === null || _a === void 0 ? void 0 : _a.split(\" \")) || []).concat(group).sort().join(\" \");\n    }\n    checkGroups() {\n        let groups = Object.create(null), nodeNames = Object.create(null);\n        for (let term of this.terms.terms)\n            if (term.nodeName) {\n                nodeNames[term.nodeName] = true;\n                if (term.props[\"group\"])\n                    for (let group of term.props[\"group\"].split(\" \")) {\n                        (groups[group] || (groups[group] = [])).push(term);\n                    }\n            }\n        let names = Object.keys(groups);\n        for (let i = 0; i < names.length; i++) {\n            let name = names[i], terms = groups[name];\n            if (nodeNames[name])\n                this.warn(`Group name '${name}' conflicts with a node of the same name`);\n            for (let j = i + 1; j < names.length; j++) {\n                let other = groups[names[j]];\n                if (terms.some(t => other.includes(t)) &&\n                    (terms.length > other.length ? other.some(t => !terms.includes(t)) : terms.some(t => !other.includes(t))))\n                    this.warn(`Groups '${name}' and '${names[j]}' overlap without one being a superset of the other`);\n            }\n        }\n    }\n}\nconst MinSharedActions = 5;\nclass FinishStateContext {\n    constructor(tokenizers, data, stateArray, skipData, skipInfo, states, builder) {\n        this.tokenizers = tokenizers;\n        this.data = data;\n        this.stateArray = stateArray;\n        this.skipData = skipData;\n        this.skipInfo = skipInfo;\n        this.states = states;\n        this.builder = builder;\n        this.sharedActions = [];\n    }\n    findSharedActions(state) {\n        if (state.actions.length < MinSharedActions)\n            return null;\n        let found = null;\n        for (let shared of this.sharedActions) {\n            if ((!found || shared.actions.length > found.actions.length) &&\n                shared.actions.every(a => state.actions.some(b => b.eq(a))))\n                found = shared;\n        }\n        if (found)\n            return found;\n        let max = null, scratch = [];\n        for (let i = state.id + 1; i < this.states.length; i++) {\n            let other = this.states[i], fill = 0;\n            if (other.defaultReduce || other.actions.length < MinSharedActions)\n                continue;\n            for (let a of state.actions)\n                for (let b of other.actions)\n                    if (a.eq(b))\n                        scratch[fill++] = a;\n            if (fill >= MinSharedActions && (!max || max.length < fill)) {\n                max = scratch;\n                scratch = [];\n            }\n        }\n        if (!max)\n            return null;\n        let result = { actions: max, addr: this.storeActions(max, -1, null) };\n        this.sharedActions.push(result);\n        return result;\n    }\n    storeActions(actions, skipReduce, shared) {\n        if (skipReduce < 0 && shared && shared.actions.length == actions.length)\n            return shared.addr;\n        let data = [];\n        for (let action of actions) {\n            if (shared && shared.actions.some(a => a.eq(action)))\n                continue;\n            if (action instanceof Shift) {\n                data.push(action.term.id, action.target.id, 0);\n            }\n            else {\n                let code = reduceAction(action.rule, this.skipInfo);\n                if (code != skipReduce)\n                    data.push(action.term.id, code & 65535 /* Action.ValueMask */, code >> 16);\n            }\n        }\n        data.push(65535 /* Seq.End */);\n        if (skipReduce > -1)\n            data.push(2 /* Seq.Other */, skipReduce & 65535 /* Action.ValueMask */, skipReduce >> 16);\n        else if (shared)\n            data.push(1 /* Seq.Next */, shared.addr & 0xffff, shared.addr >> 16);\n        else\n            data.push(0 /* Seq.Done */);\n        return this.data.storeArray(data);\n    }\n    finish(state, isSkip, forcedReduce) {\n        let b = this.builder;\n        let skipID = b.skipRules.indexOf(state.skip);\n        let skipTable = this.skipData[skipID], skipTerms = this.skipInfo[skipID].startTokens;\n        let defaultReduce = state.defaultReduce ? reduceAction(state.defaultReduce, this.skipInfo) : 0;\n        let flags = isSkip ? 1 /* StateFlag.Skipped */ : 0;\n        let skipReduce = -1, shared = null;\n        if (defaultReduce == 0) {\n            if (isSkip)\n                for (const action of state.actions)\n                    if (action instanceof Reduce && action.term.eof)\n                        skipReduce = reduceAction(action.rule, this.skipInfo);\n            if (skipReduce < 0)\n                shared = this.findSharedActions(state);\n        }\n        if (state.set.some(p => p.rule.name.top && p.pos == p.rule.parts.length))\n            flags |= 2 /* StateFlag.Accepting */;\n        let external = [];\n        for (let i = 0; i < state.actions.length + skipTerms.length; i++) {\n            let term = i < state.actions.length ? state.actions[i].term : skipTerms[i - state.actions.length];\n            for (;;) {\n                let orig = b.tokenOrigins[term.name];\n                if (orig && orig.spec) {\n                    term = orig.spec;\n                    continue;\n                }\n                if (orig && (orig.external instanceof ExternalTokenSet))\n                    addToSet(external, orig.external);\n                break;\n            }\n        }\n        let tokenizerMask = 0;\n        for (let i = 0; i < this.tokenizers.length; i++) {\n            let tok = this.tokenizers[i];\n            if (external.includes(tok) || tok.groupID == state.tokenGroup)\n                tokenizerMask |= (1 << i);\n        }\n        let base = state.id * 6 /* ParseState.Size */;\n        this.stateArray[base + 0 /* ParseState.Flags */] = flags;\n        this.stateArray[base + 1 /* ParseState.Actions */] = this.storeActions(defaultReduce ? none : state.actions, skipReduce, shared);\n        this.stateArray[base + 2 /* ParseState.Skip */] = skipTable;\n        this.stateArray[base + 3 /* ParseState.TokenizerMask */] = tokenizerMask;\n        this.stateArray[base + 4 /* ParseState.DefaultReduce */] = defaultReduce;\n        this.stateArray[base + 5 /* ParseState.ForcedReduce */] = forcedReduce;\n    }\n}\nfunction addToProp(term, prop, value) {\n    let cur = term.props[prop];\n    if (!cur || cur.split(\" \").indexOf(value) < 0)\n        term.props[prop] = cur ? cur + \" \" + value : value;\n}\nfunction buildSpecializeTable(spec) {\n    let table = Object.create(null);\n    for (let { value, term, type } of spec) {\n        let code = type == \"specialize\" ? 0 /* Specialize.Specialize */ : 1 /* Specialize.Extend */;\n        table[value] = (term.id << 1) | code;\n    }\n    return table;\n}\nfunction reduceAction(rule, skipInfo, depth = rule.parts.length) {\n    return rule.name.id | 65536 /* Action.ReduceFlag */ |\n        (rule.isRepeatWrap && depth == rule.parts.length ? 131072 /* Action.RepeatFlag */ : 0) |\n        (skipInfo.some(i => i.rule == rule.name) ? 262144 /* Action.StayFlag */ : 0) |\n        (depth << 19 /* Action.ReduceDepthShift */);\n}\nfunction findArray(data, value) {\n    search: for (let i = 0;;) {\n        let next = data.indexOf(value[0], i);\n        if (next == -1 || next + value.length > data.length)\n            break;\n        for (let j = 1; j < value.length; j++) {\n            if (value[j] != data[next + j]) {\n                i = next + 1;\n                continue search;\n            }\n        }\n        return next;\n    }\n    return -1;\n}\nfunction findSkipStates(table, startRules) {\n    let nonSkip = Object.create(null);\n    let work = [];\n    let add = (state) => {\n        if (!nonSkip[state.id]) {\n            nonSkip[state.id] = true;\n            work.push(state);\n        }\n    };\n    for (let state of table)\n        if (state.startRule && startRules.includes(state.startRule))\n            add(state);\n    for (let i = 0; i < work.length; i++) {\n        for (let a of work[i].actions)\n            if (a instanceof Shift)\n                add(a.target);\n        for (let a of work[i].goto)\n            add(a.target);\n    }\n    return (id) => !nonSkip[id];\n}\nclass DataBuilder {\n    constructor() {\n        this.data = [];\n    }\n    storeArray(data) {\n        let found = findArray(this.data, data);\n        if (found > -1)\n            return found;\n        let pos = this.data.length;\n        for (let num of data)\n            this.data.push(num);\n        return pos;\n    }\n    finish() {\n        return Uint16Array.from(this.data);\n    }\n}\n// The goto table maps a start state + a term to a new state, and is\n// used to determine the new state when reducing. Because this allows\n// more more efficient representation and access, unlike the action\n// tables, the goto table is organized by term, with groups of start\n// states that map to a given end state enumerated for each term.\n// Since many terms only have a single valid goto target, this makes\n// it cheaper to look those up.\n//\n// (Unfortunately, though the standard LR parsing mechanism never\n// looks up invalid goto states, the incremental parsing mechanism\n// needs accurate goto information for a state/term pair, so we do\n// need to store state ids even for terms that have only one target.)\n//\n// - First comes the amount of terms in the table\n//\n// - Then, for each term, the offset of the term's data\n//\n// - At these offsets, there's a record for each target state\n//\n//   - Such a record starts with the amount of start states that go to\n//     this target state, shifted one to the left, with the first bit\n//     only set if this is the last record for this term.\n//\n//   - Then follows the target state id\n//\n//   - And then the start state ids\nfunction computeGotoTable(states) {\n    let goto = {};\n    let maxTerm = 0;\n    for (let state of states) {\n        for (let entry of state.goto) {\n            maxTerm = Math.max(entry.term.id, maxTerm);\n            let set = goto[entry.term.id] || (goto[entry.term.id] = {});\n            (set[entry.target.id] || (set[entry.target.id] = [])).push(state.id);\n        }\n    }\n    let data = new DataBuilder;\n    let index = [];\n    let offset = maxTerm + 2; // Offset of the data, taking index size into account\n    for (let term = 0; term <= maxTerm; term++) {\n        let entries = goto[term];\n        if (!entries) {\n            index.push(1);\n            continue;\n        }\n        let termTable = [];\n        let keys = Object.keys(entries);\n        for (let target of keys) {\n            let list = entries[target];\n            termTable.push((target == keys[keys.length - 1] ? 1 : 0) + (list.length << 1));\n            termTable.push(+target);\n            for (let source of list)\n                termTable.push(source);\n        }\n        index.push(data.storeArray(termTable) + offset);\n    }\n    if (index.some(n => n > 0xffff))\n        throw new GenError(\"Goto table too large\");\n    return Uint16Array.from([maxTerm + 1, ...index, ...data.data]);\n}\nclass TokenGroup {\n    constructor(tokens, groupID) {\n        this.tokens = tokens;\n        this.groupID = groupID;\n    }\n    create() { return this.groupID; }\n    createSource() { return String(this.groupID); }\n}\nfunction addToSet(set, value) {\n    if (!set.includes(value))\n        set.push(value);\n}\nfunction buildTokenMasks(groups) {\n    let masks = Object.create(null);\n    for (let group of groups) {\n        let groupMask = 1 << group.groupID;\n        for (let term of group.tokens) {\n            masks[term.id] = (masks[term.id] || 0) | groupMask;\n        }\n    }\n    return masks;\n}\nclass TokenArg {\n    constructor(name, expr, scope) {\n        this.name = name;\n        this.expr = expr;\n        this.scope = scope;\n    }\n}\nclass BuildingRule {\n    constructor(name, start, to, args) {\n        this.name = name;\n        this.start = start;\n        this.to = to;\n        this.args = args;\n    }\n}\nclass TokenSet {\n    constructor(b, ast) {\n        this.b = b;\n        this.ast = ast;\n        this.startState = new State$1;\n        this.built = [];\n        this.building = []; // Used for recursion check\n        this.byDialect = Object.create(null);\n        this.precedenceRelations = [];\n        this.rules = ast ? ast.rules : none;\n        for (let rule of this.rules)\n            b.unique(rule.id);\n    }\n    getToken(expr) {\n        for (let built of this.built)\n            if (built.matches(expr))\n                return built.term;\n        let name = expr.id.name;\n        let rule = this.rules.find(r => r.id.name == name);\n        if (!rule)\n            return null;\n        let { name: nodeName, props, dialect, exported } = this.b.nodeInfo(rule.props, \"d\", name, expr.args, rule.params.length != expr.args.length ? none : rule.params);\n        let term = this.b.makeTerminal(expr.toString(), nodeName, props);\n        if (dialect != null)\n            (this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term);\n        if ((term.nodeType || exported) && rule.params.length == 0) {\n            if (!term.nodeType)\n                term.preserve = true;\n            this.b.namedTerms[exported || name] = term;\n        }\n        this.buildRule(rule, expr, this.startState, new State$1([term]));\n        this.built.push(new BuiltRule(name, expr.args, term));\n        return term;\n    }\n    buildRule(rule, expr, from, to, args = none) {\n        let name = expr.id.name;\n        if (rule.params.length != expr.args.length)\n            this.b.raise(`Incorrect number of arguments for token '${name}'`, expr.start);\n        let building = this.building.find(b => b.name == name && exprsEq(expr.args, b.args));\n        if (building) {\n            if (building.to == to) {\n                from.nullEdge(building.start);\n                return;\n            }\n            let lastIndex = this.building.length - 1;\n            while (this.building[lastIndex].name != name)\n                lastIndex--;\n            this.b.raise(`Invalid (non-tail) recursion in token rules: ${this.building.slice(lastIndex).map(b => b.name).join(\" -> \")}`, expr.start);\n        }\n        this.b.used(rule.id.name);\n        let start = new State$1;\n        from.nullEdge(start);\n        this.building.push(new BuildingRule(name, start, to, expr.args));\n        this.build(this.b.substituteArgs(rule.expr, expr.args, rule.params), start, to, expr.args.map((e, i) => new TokenArg(rule.params[i].name, e, args)));\n        this.building.pop();\n    }\n    build(expr, from, to, args) {\n        if (expr instanceof NameExpression) {\n            let name = expr.id.name, arg = args.find(a => a.name == name);\n            if (arg)\n                return this.build(arg.expr, from, to, arg.scope);\n            let rule;\n            for (let i = 0, lt = this.b.localTokens; i <= lt.length; i++) {\n                let set = i == lt.length ? this.b.tokens : lt[i];\n                rule = set.rules.find(r => r.id.name == name);\n            }\n            if (!rule)\n                return this.b.raise(`Reference to token rule '${expr.id.name}', which isn't found`, expr.start);\n            this.buildRule(rule, expr, from, to, args);\n        }\n        else if (expr instanceof CharClass) {\n            for (let [a, b] of CharClasses[expr.type])\n                from.edge(a, b, to);\n        }\n        else if (expr instanceof ChoiceExpression) {\n            for (let choice of expr.exprs)\n                this.build(choice, from, to, args);\n        }\n        else if (isEmpty(expr)) {\n            from.nullEdge(to);\n        }\n        else if (expr instanceof SequenceExpression) {\n            let conflict = expr.markers.find(c => c.length > 0);\n            if (conflict)\n                this.b.raise(\"Conflict marker in token expression\", conflict[0].start);\n            for (let i = 0; i < expr.exprs.length; i++) {\n                let next = i == expr.exprs.length - 1 ? to : new State$1;\n                this.build(expr.exprs[i], from, next, args);\n                from = next;\n            }\n        }\n        else if (expr instanceof RepeatExpression) {\n            if (expr.kind == \"*\") {\n                let loop = new State$1;\n                from.nullEdge(loop);\n                this.build(expr.expr, loop, loop, args);\n                loop.nullEdge(to);\n            }\n            else if (expr.kind == \"+\") {\n                let loop = new State$1;\n                this.build(expr.expr, from, loop, args);\n                this.build(expr.expr, loop, loop, args);\n                loop.nullEdge(to);\n            }\n            else { // expr.kind == \"?\"\n                from.nullEdge(to);\n                this.build(expr.expr, from, to, args);\n            }\n        }\n        else if (expr instanceof SetExpression) {\n            for (let [a, b] of expr.inverted ? invertRanges(expr.ranges) : expr.ranges)\n                rangeEdges(from, to, a, b);\n        }\n        else if (expr instanceof LiteralExpression) {\n            for (let i = 0; i < expr.value.length; i++) {\n                let ch = expr.value.charCodeAt(i);\n                let next = i == expr.value.length - 1 ? to : new State$1;\n                from.edge(ch, ch + 1, next);\n                from = next;\n            }\n        }\n        else if (expr instanceof AnyExpression) {\n            let mid = new State$1;\n            from.edge(0, 0xDC00, to);\n            from.edge(0xDC00, MAX_CHAR + 1, to);\n            from.edge(0xD800, 0xDC00, mid);\n            mid.edge(0xDC00, 0xE000, to);\n        }\n        else {\n            return this.b.raise(`Unrecognized expression type in token`, expr.start);\n        }\n    }\n    takePrecedences() {\n        let rel = this.precedenceRelations = [];\n        if (this.ast)\n            for (let group of this.ast.precedences) {\n                let prev = [];\n                for (let item of group.items) {\n                    let level = [];\n                    if (item instanceof NameExpression) {\n                        for (let built of this.built)\n                            if (item.args.length ? built.matches(item) : built.id == item.id.name)\n                                level.push(built.term);\n                    }\n                    else {\n                        let id = JSON.stringify(item.value), found = this.built.find(b => b.id == id);\n                        if (found)\n                            level.push(found.term);\n                    }\n                    if (!level.length)\n                        this.b.warn(`Precedence specified for unknown token ${item}`, item.start);\n                    for (let term of level)\n                        addRel(rel, term, prev);\n                    prev = prev.concat(level);\n                }\n            }\n    }\n    precededBy(a, b) {\n        let found = this.precedenceRelations.find(r => r.term == a);\n        return found && found.after.includes(b);\n    }\n    buildPrecTable(softConflicts) {\n        let precTable = [], rel = this.precedenceRelations.slice();\n        // Add entries for soft-conflicting tokens that are in the\n        // precedence table, to make sure they'll appear in the right\n        // order and don't mess up the longer-wins default rule.\n        for (let { a, b, soft } of softConflicts)\n            if (soft) {\n                if (!rel.some(r => r.term == a) || !rel.some(r => r.term == b))\n                    continue;\n                if (soft < 0)\n                    [a, b] = [b, a]; // Now a is longer than b (and should thus take precedence)\n                addRel(rel, b, [a]);\n                addRel(rel, a, []);\n            }\n        add: while (rel.length) {\n            for (let i = 0; i < rel.length; i++) {\n                let record = rel[i];\n                if (record.after.every(t => precTable.includes(t.id))) {\n                    precTable.push(record.term.id);\n                    if (rel.length == 1)\n                        break add;\n                    rel[i] = rel.pop();\n                    continue add;\n                }\n            }\n            this.b.raise(`Cyclic token precedence relation between ${rel.map(r => r.term).join(\", \")}`);\n        }\n        return precTable;\n    }\n}\nclass MainTokenSet extends TokenSet {\n    constructor() {\n        super(...arguments);\n        this.explicitConflicts = [];\n    }\n    getLiteral(expr) {\n        let id = JSON.stringify(expr.value);\n        for (let built of this.built)\n            if (built.id == id)\n                return built.term;\n        let name = null, props = {}, dialect = null, exported = null;\n        let decl = this.ast ? this.ast.literals.find(l => l.literal == expr.value) : null;\n        if (decl)\n            ({ name, props, dialect, exported } = this.b.nodeInfo(decl.props, \"da\", expr.value));\n        let term = this.b.makeTerminal(id, name, props);\n        if (dialect != null)\n            (this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term);\n        if (exported)\n            this.b.namedTerms[exported] = term;\n        this.build(expr, this.startState, new State$1([term]), none);\n        this.built.push(new BuiltRule(id, none, term));\n        return term;\n    }\n    takeConflicts() {\n        var _a;\n        let resolve = (expr) => {\n            if (expr instanceof NameExpression) {\n                for (let built of this.built)\n                    if (built.matches(expr))\n                        return built.term;\n            }\n            else {\n                let id = JSON.stringify(expr.value), found = this.built.find(b => b.id == id);\n                if (found)\n                    return found.term;\n            }\n            this.b.warn(`Precedence specified for unknown token ${expr}`, expr.start);\n            return null;\n        };\n        for (let c of ((_a = this.ast) === null || _a === void 0 ? void 0 : _a.conflicts) || []) {\n            let a = resolve(c.a), b = resolve(c.b);\n            if (a && b) {\n                if (a.id < b.id)\n                    [a, b] = [b, a];\n                this.explicitConflicts.push({ a, b });\n            }\n        }\n    }\n    // Token groups are a mechanism for allowing conflicting (matching\n    // overlapping input, without an explicit precedence being given)\n    // tokens to exist in a grammar _if_ they don't occur in the same\n    // place (aren't used in the same states).\n    //\n    // States that use tokens that conflict will raise an error when any\n    // of the conflicting pairs of tokens both occur in that state.\n    // Otherwise, they are assigned a token group, which includes all\n    // the potentially-conflicting tokens they use. If there's already a\n    // group that doesn't have any conflicts with those tokens, that is\n    // reused, otherwise a new group is created.\n    //\n    // So each state has zero or one token groups, and each conflicting\n    // token may belong to one or more groups. Tokens get assigned a\n    // 16-bit bitmask with the groups they belong to set to 1 (all-1s\n    // for non-conflicting tokens). When tokenizing, that mask is\n    // compared to the current state's group (again using all-1s for\n    // group-less states) to determine whether a token is applicable for\n    // this state.\n    //\n    // Extended/specialized tokens are treated as their parent token for\n    // this purpose.\n    buildTokenGroups(states, skipInfo, startID) {\n        let tokens = this.startState.compile();\n        if (tokens.accepting.length)\n            this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`, this.rules.find(r => r.id.name == tokens.accepting[0].name).start);\n        if (/\\btokens\\b/.test(verbose))\n            console.log(tokens.toString());\n        // If there is a precedence specified for the pair, the conflict is resolved\n        let allConflicts = tokens.findConflicts(checkTogether(states, this.b, skipInfo))\n            .filter(({ a, b }) => !this.precededBy(a, b) && !this.precededBy(b, a));\n        for (let { a, b } of this.explicitConflicts) {\n            if (!allConflicts.some(c => c.a == a && c.b == b))\n                allConflicts.push(new Conflict$1(a, b, 0, \"\", \"\"));\n        }\n        let softConflicts = allConflicts.filter(c => c.soft), conflicts = allConflicts.filter(c => !c.soft);\n        let errors = [];\n        let groups = [];\n        for (let state of states) {\n            if (state.defaultReduce || state.tokenGroup > -1)\n                continue;\n            // Find potentially-conflicting terms (in terms) and the things\n            // they conflict with (in conflicts), and raise an error if\n            // there's a token conflict directly in this state.\n            let terms = [], incompatible = [];\n            let skip = skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens;\n            for (let term of skip)\n                if (state.actions.some(a => a.term == term))\n                    this.b.raise(`Use of token ${term.name} conflicts with skip rule`);\n            let stateTerms = [];\n            for (let i = 0; i < state.actions.length + (skip ? skip.length : 0); i++) {\n                let term = i < state.actions.length ? state.actions[i].term : skip[i - state.actions.length];\n                let orig = this.b.tokenOrigins[term.name];\n                if (orig && orig.spec)\n                    term = orig.spec;\n                else if (orig && orig.external)\n                    continue;\n                addToSet(stateTerms, term);\n            }\n            if (stateTerms.length == 0)\n                continue;\n            for (let term of stateTerms) {\n                for (let conflict of conflicts) {\n                    let conflicting = conflict.a == term ? conflict.b : conflict.b == term ? conflict.a : null;\n                    if (!conflicting)\n                        continue;\n                    if (stateTerms.includes(conflicting) && !errors.some(e => e.conflict == conflict)) {\n                        let example = conflict.exampleA ? ` (example: ${JSON.stringify(conflict.exampleA)}${conflict.exampleB ? ` vs ${JSON.stringify(conflict.exampleB)}` : \"\"})` : \"\";\n                        errors.push({\n                            error: `Overlapping tokens ${term.name} and ${conflicting.name} used in same context${example}\\n` +\n                                `After: ${state.set[0].trail()}`,\n                            conflict\n                        });\n                    }\n                    addToSet(terms, term);\n                    addToSet(incompatible, conflicting);\n                }\n            }\n            let tokenGroup = null;\n            for (let group of groups) {\n                if (incompatible.some(term => group.tokens.includes(term)))\n                    continue;\n                for (let term of terms)\n                    addToSet(group.tokens, term);\n                tokenGroup = group;\n                break;\n            }\n            if (!tokenGroup) {\n                tokenGroup = new TokenGroup(terms, groups.length + startID);\n                groups.push(tokenGroup);\n            }\n            state.tokenGroup = tokenGroup.groupID;\n        }\n        if (errors.length)\n            this.b.raise(errors.map(e => e.error).join(\"\\n\\n\"));\n        if (groups.length + startID > 16)\n            this.b.raise(`Too many different token groups (${groups.length}) to represent them as a 16-bit bitfield`);\n        let precTable = this.buildPrecTable(softConflicts);\n        return {\n            tokenGroups: groups,\n            tokenPrec: precTable,\n            tokenData: tokens.toArray(buildTokenMasks(groups), precTable)\n        };\n    }\n}\nclass LocalTokenSet extends TokenSet {\n    constructor(b, ast) {\n        super(b, ast);\n        this.fallback = null;\n        if (ast.fallback)\n            b.unique(ast.fallback.id);\n    }\n    getToken(expr) {\n        let term = null;\n        if (this.ast.fallback && this.ast.fallback.id.name == expr.id.name) {\n            if (expr.args.length)\n                this.b.raise(`Incorrect number of arguments for ${expr.id.name}`, expr.start);\n            if (!this.fallback) {\n                let { name: nodeName, props, exported } = this.b.nodeInfo(this.ast.fallback.props, \"\", expr.id.name, none, none);\n                let term = this.fallback = this.b.makeTerminal(expr.id.name, nodeName, props);\n                if (term.nodeType || exported) {\n                    if (!term.nodeType)\n                        term.preserve = true;\n                    this.b.namedTerms[exported || expr.id.name] = term;\n                }\n                this.b.used(expr.id.name);\n            }\n            term = this.fallback;\n        }\n        else {\n            term = super.getToken(expr);\n        }\n        if (term && !this.b.tokenOrigins[term.name])\n            this.b.tokenOrigins[term.name] = { group: this };\n        return term;\n    }\n    buildLocalGroup(states, skipInfo, id) {\n        let tokens = this.startState.compile();\n        if (tokens.accepting.length)\n            this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`, this.rules.find(r => r.id.name == tokens.accepting[0].name).start);\n        for (let { a, b, exampleA } of tokens.findConflicts(() => true)) {\n            if (!this.precededBy(a, b) && !this.precededBy(b, a))\n                this.b.raise(`Overlapping tokens ${a.name} and ${b.name} in local token group${exampleA ? ` (example: ${JSON.stringify(exampleA)})` : ''}`);\n        }\n        for (let state of states) {\n            if (state.defaultReduce)\n                continue;\n            // See if this state uses any of the tokens in this group, and\n            // if so, make sure it *only* uses tokens from this group.\n            let usesThis = null;\n            let usesOther = skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens[0];\n            for (let { term } of state.actions) {\n                let orig = this.b.tokenOrigins[term.name];\n                if ((orig === null || orig === void 0 ? void 0 : orig.group) == this)\n                    usesThis = term;\n                else\n                    usesOther = term;\n            }\n            if (usesThis) {\n                if (usesOther)\n                    this.b.raise(`Tokens from a local token group used together with other tokens (${usesThis.name} with ${usesOther.name})`);\n                state.tokenGroup = id;\n            }\n        }\n        let precTable = this.buildPrecTable(none);\n        let tokenData = tokens.toArray({ [id]: 65535 /* Seq.End */ }, precTable);\n        let precOffset = tokenData.length;\n        let fullData = new Uint16Array(tokenData.length + precTable.length + 1);\n        fullData.set(tokenData, 0);\n        fullData.set(precTable, precOffset);\n        fullData[fullData.length - 1] = 65535 /* Seq.End */;\n        return {\n            groupID: id,\n            create: () => new LocalTokenGroup(fullData, precOffset, this.fallback ? this.fallback.id : undefined),\n            createSource: importName => `new ${importName(\"LocalTokenGroup\", \"@lezer/lr\")}(${encodeArray(fullData)}, ${precOffset}${this.fallback ? `, ${this.fallback.id}` : ''})`\n        };\n    }\n}\nfunction checkTogether(states, b, skipInfo) {\n    let cache = Object.create(null);\n    function hasTerm(state, term) {\n        return state.actions.some(a => a.term == term) ||\n            skipInfo[b.skipRules.indexOf(state.skip)].startTokens.includes(term);\n    }\n    return (a, b) => {\n        if (a.id < b.id)\n            [a, b] = [b, a];\n        let key = a.id | (b.id << 16), cached = cache[key];\n        if (cached != null)\n            return cached;\n        return cache[key] = states.some(state => hasTerm(state, a) && hasTerm(state, b));\n    };\n}\nfunction invertRanges(ranges) {\n    let pos = 0, result = [];\n    for (let [a, b] of ranges) {\n        if (a > pos)\n            result.push([pos, a]);\n        pos = b;\n    }\n    if (pos <= MAX_CODE)\n        result.push([pos, MAX_CODE + 1]);\n    return result;\n}\nconst ASTRAL = 0x10000, GAP_START = 0xd800, GAP_END = 0xe000, MAX_CODE = 0x10ffff;\nconst LOW_SURR_B = 0xdc00, HIGH_SURR_B = 0xdfff;\n// Create intermediate states for astral characters in a range, if\n// necessary, since the tokenizer acts on UTF16 characters\nfunction rangeEdges(from, to, low, hi) {\n    if (low < ASTRAL) {\n        if (low < GAP_START)\n            from.edge(low, Math.min(hi, GAP_START), to);\n        if (hi > GAP_END)\n            from.edge(Math.max(low, GAP_END), Math.min(hi, MAX_CHAR + 1), to);\n        low = ASTRAL;\n    }\n    if (hi <= ASTRAL)\n        return;\n    let lowStr = String.fromCodePoint(low), hiStr = String.fromCodePoint(hi - 1);\n    let lowA = lowStr.charCodeAt(0), lowB = lowStr.charCodeAt(1);\n    let hiA = hiStr.charCodeAt(0), hiB = hiStr.charCodeAt(1);\n    if (lowA == hiA) { // Share the first char code\n        let hop = new State$1;\n        from.edge(lowA, lowA + 1, hop);\n        hop.edge(lowB, hiB + 1, to);\n    }\n    else {\n        let midStart = lowA, midEnd = hiA;\n        if (lowB > LOW_SURR_B) {\n            midStart++;\n            let hop = new State$1;\n            from.edge(lowA, lowA + 1, hop);\n            hop.edge(lowB, HIGH_SURR_B + 1, to);\n        }\n        if (hiB < HIGH_SURR_B) {\n            midEnd--;\n            let hop = new State$1;\n            from.edge(hiA, hiA + 1, hop);\n            hop.edge(LOW_SURR_B, hiB + 1, to);\n        }\n        if (midStart <= midEnd) {\n            let hop = new State$1;\n            from.edge(midStart, midEnd + 1, hop);\n            hop.edge(LOW_SURR_B, HIGH_SURR_B + 1, to);\n        }\n    }\n}\nfunction isEmpty(expr) {\n    return expr instanceof SequenceExpression && expr.exprs.length == 0;\n}\nfunction gatherExtTokens(b, tokens) {\n    let result = Object.create(null);\n    for (let token of tokens) {\n        b.unique(token.id);\n        let { name, props, dialect } = b.nodeInfo(token.props, \"d\", token.id.name);\n        let term = b.makeTerminal(token.id.name, name, props);\n        if (dialect != null)\n            (b.tokens.byDialect[dialect] || (b.tokens.byDialect[dialect] = [])).push(term);\n        b.namedTerms[token.id.name] = result[token.id.name] = term;\n    }\n    return result;\n}\nfunction findExtToken(b, tokens, expr) {\n    let found = tokens[expr.id.name];\n    if (!found)\n        return null;\n    if (expr.args.length)\n        b.raise(\"External tokens cannot take arguments\", expr.args[0].start);\n    b.used(expr.id.name);\n    return found;\n}\nfunction addRel(rel, term, after) {\n    let found = rel.findIndex(r => r.term == term);\n    if (found < 0)\n        rel.push({ term, after });\n    else\n        rel[found] = { term, after: rel[found].after.concat(after) };\n}\nclass ExternalTokenSet {\n    constructor(b, ast) {\n        this.b = b;\n        this.ast = ast;\n        this.tokens = gatherExtTokens(b, ast.tokens);\n        for (let name in this.tokens)\n            this.b.tokenOrigins[this.tokens[name].name] = { external: this };\n    }\n    getToken(expr) { return findExtToken(this.b, this.tokens, expr); }\n    create() {\n        return this.b.options.externalTokenizer(this.ast.id.name, this.b.termTable);\n    }\n    createSource(importName) {\n        let { source, id: { name } } = this.ast;\n        return importName(name, source);\n    }\n}\nclass ExternalSpecializer {\n    constructor(b, ast) {\n        this.b = b;\n        this.ast = ast;\n        this.term = null;\n        this.tokens = gatherExtTokens(b, ast.tokens);\n    }\n    finish() {\n        let terms = this.b.normalizeExpr(this.ast.token);\n        if (terms.length != 1 || terms[0].terms.length != 1 || !terms[0].terms[0].terminal)\n            this.b.raise(`The token expression to '@external ${this.ast.type}' must resolve to a token`, this.ast.token.start);\n        this.term = terms[0].terms[0];\n        for (let name in this.tokens)\n            this.b.tokenOrigins[this.tokens[name].name] = { spec: this.term, external: this };\n    }\n    getToken(expr) { return findExtToken(this.b, this.tokens, expr); }\n}\nfunction inlineRules(rules, preserve) {\n    for (let pass = 0;; pass++) {\n        let inlinable = Object.create(null), found;\n        if (pass == 0)\n            for (let rule of rules) {\n                if (rule.name.inline && !inlinable[rule.name.name]) {\n                    let group = rules.filter(r => r.name == rule.name);\n                    if (group.some(r => r.parts.includes(rule.name)))\n                        continue;\n                    found = inlinable[rule.name.name] = group;\n                }\n            }\n        for (let i = 0; i < rules.length; i++) {\n            let rule = rules[i];\n            if (!rule.name.interesting && !rule.parts.includes(rule.name) && rule.parts.length < 3 &&\n                !preserve.includes(rule.name) &&\n                (rule.parts.length == 1 || rules.every(other => other.skip == rule.skip || !other.parts.includes(rule.name))) &&\n                !rule.parts.some(p => !!inlinable[p.name]) &&\n                !rules.some((r, j) => j != i && r.name == rule.name))\n                found = inlinable[rule.name.name] = [rule];\n        }\n        if (!found)\n            return rules;\n        let newRules = [];\n        for (let rule of rules) {\n            if (inlinable[rule.name.name])\n                continue;\n            if (!rule.parts.some(p => !!inlinable[p.name])) {\n                newRules.push(rule);\n                continue;\n            }\n            function expand(at, conflicts, parts) {\n                if (at == rule.parts.length) {\n                    newRules.push(new Rule(rule.name, parts, conflicts, rule.skip));\n                    return;\n                }\n                let next = rule.parts[at], replace = inlinable[next.name];\n                if (!replace) {\n                    expand(at + 1, conflicts.concat(rule.conflicts[at + 1]), parts.concat(next));\n                    return;\n                }\n                for (let r of replace)\n                    expand(at + 1, conflicts.slice(0, conflicts.length - 1)\n                        .concat(conflicts[at].join(r.conflicts[0]))\n                        .concat(r.conflicts.slice(1, r.conflicts.length - 1))\n                        .concat(rule.conflicts[at + 1].join(r.conflicts[r.conflicts.length - 1])), parts.concat(r.parts));\n            }\n            expand(0, [rule.conflicts[0]], []);\n        }\n        rules = newRules;\n    }\n}\nfunction mergeRules(rules) {\n    let merged = Object.create(null), found;\n    for (let i = 0; i < rules.length;) {\n        let groupStart = i;\n        let name = rules[i++].name;\n        while (i < rules.length && rules[i].name == name)\n            i++;\n        let size = i - groupStart;\n        if (name.interesting)\n            continue;\n        for (let j = i; j < rules.length;) {\n            let otherStart = j, otherName = rules[j++].name;\n            while (j < rules.length && rules[j].name == otherName)\n                j++;\n            if (j - otherStart != size || otherName.interesting)\n                continue;\n            let match = true;\n            for (let k = 0; k < size && match; k++) {\n                let a = rules[groupStart + k], b = rules[otherStart + k];\n                if (a.cmpNoName(b) != 0)\n                    match = false;\n            }\n            if (match)\n                found = merged[name.name] = otherName;\n        }\n    }\n    if (!found)\n        return rules;\n    let newRules = [];\n    for (let rule of rules)\n        if (!merged[rule.name.name]) {\n            newRules.push(rule.parts.every(p => !merged[p.name]) ? rule :\n                new Rule(rule.name, rule.parts.map(p => merged[p.name] || p), rule.conflicts, rule.skip));\n        }\n    return newRules;\n}\nfunction simplifyRules(rules, preserve) {\n    return mergeRules(inlineRules(rules, preserve));\n}\n/// Build an in-memory parser instance for a given grammar. This is\n/// mostly useful for testing. If your grammar uses external\n/// tokenizers, you'll have to provide the `externalTokenizer` option\n/// for the returned parser to be able to parse anything.\nfunction buildParser(text, options = {}) {\n    let builder = new Builder(text, options), parser = builder.getParser();\n    parser.termTable = builder.termTable;\n    return parser;\n}\nconst KEYWORDS = [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\",\n    \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"while\", \"with\",\n    \"null\", \"true\", \"false\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"new\", \"in\", \"this\",\n    \"const\", \"class\", \"extends\", \"export\", \"import\", \"super\", \"enum\", \"implements\", \"interface\",\n    \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"require\"];\n/// Build the code that represents the parser tables for a given\n/// grammar description. The `parser` property in the return value\n/// holds the main file that exports the `Parser` instance. The\n/// `terms` property holds a declaration file that defines constants\n/// for all of the named terms in grammar, holding their ids as value.\n/// This is useful when external code, such as a tokenizer, needs to\n/// be able to use these ids. It is recommended to run a tree-shaking\n/// bundler when importing this file, since you usually only need a\n/// handful of the many terms in your code.\nfunction buildParserFile(text, options = {}) {\n    return new Builder(text, options).getParserFile();\n}\nfunction ignored(name) {\n    let first = name[0];\n    return first == \"_\" || first.toUpperCase() != first;\n}\nfunction isExported(rule) {\n    return rule.props.some(p => p.at && p.name == \"export\");\n}\n\nexport { GenError, buildParser, buildParserFile };\n"],"names":["Node","constructor","start","this","GrammarDeclaration","rules","topRules","tokens","localTokens","context","externalTokens","externalSpecializers","externalPropSources","precedences","mainSkip","scopedSkip","dialects","externalProps","autoDelim","super","toString","Object","values","join","RuleDeclaration","id","props","params","expr","name","length","PrecDeclaration","items","TokenPrecDeclaration","TokenConflictDeclaration","a","b","TokenDeclaration","conflicts","literals","LocalTokenDeclaration","fallback","LiteralDeclaration","literal","ContextDeclaration","source","ExternalTokenDeclaration","ExternalSpecializeDeclaration","type","token","ExternalPropSourceDeclaration","ExternalPropDeclaration","externalID","Identifier","Expression","walk","f","eq","_other","prototype","prec","NameExpression","args","other","exprsEq","walkExprs","SpecializeExpression","content","Prop","eqProps","exprEq","InlineRuleExpression","rule","oRule","ChoiceExpression","exprs","map","e","maybeParens","SequenceExpression","markers","empty","every","m","i","om","x","ConflictMarker","RepeatExpression","kind","LiteralExpression","value","JSON","stringify","SetExpression","ranges","inverted","String","fromCodePoint","y","AnyExpression","result","slice","push","CharClasses","asciiLetter","asciiLowercase","asciiUppercase","digit","whitespace","eof","CharClass","at","v","test","static","p","PropPart","node","parent","GenError","Error","hasProps","_p","termHash","Term","flags","nodeName","hash","nodeType","top","repeated","terminal","error","interesting","preserve","inline","cmp","TermSet","terms","names","create","tops","term","makeTop","makeTerminal","makeNonTerminal","makeRepeat","uniqueName","cur","finish","filter","t","some","r","parts","includes","nodeTypes","nextID","minRepeatTerm","maxTerm","cmpSet","diff","none$3","Conflicts","precedence","ambigGroups","cut","none","Math","max","union","sort","ruleID","Rule","skip","cmpNoName","reduce","s","isRepeatWrap","sameReduce","MAX_CHAR","Edge","from","to","target","charFor","n","fromCharCode","minimize","states","partition","byAccepting","state","ids","accepting","group","split","newPartition","groups","isEquivalent","applyMinimization","edges","eA","eB","edge","stateID","State$1","nullEdge","compile","labeled","localID","startState","explore","closure","newState","out","transitions","mergeEdges","merged","targets","seen","sameSet$1","findConflicts","occurTogether","cycleTerms","add","soft","aEdges","bEdges","found","find","c","Conflict$1","exampleFromEdges","reachable","j","es","hasCycle","orig","concat","work","table","Map","haveCycle","entry","get","set","next","pop","toArray","groupMasks","offsets","data","acceptEnd","stateMask","indexOf","Uint16Array","mask","exampleA","exampleB","str","elts","elt","MergedEdge","separate","word","_","none$2","Input","string","fileName","end","lineInfo","pos","line","ch","message","msg","posInfo","info","raise","match","re","exec","readString","lastIndex","eat","unexpected","expect","val","parse","parseGrammar","input","external","specialized","propSources","sawTop","parseRule","parseIdent","parseTokens","parseLocalTokens","parseExternalTokens","parseExternalProp","parseExternalSpecialize","parseExternalPropSource","first","parsePrecedence","parseBracedExpr","named","parseProps","parseProp","parseExprChoice","SET_MARKER","parseExprInner","invert","unescaped","replace","code","codePointAt","addRange","charCodeAt","hasOwnProperty","cls","parseArgs","parseExprSuffix","endOfSequence","parseExprSequence","localStart","markerType","ms","left","tokenRules","parseTokenPrecedence","parseTokenConflict","parseExternalTokenSet","point","all","u1","u2","u3","single","unknown","parseInt","hashString","h","verbose","process","env","LOG","timing","time","label","t0","Date","now","console","log","toFixed","_label","Pos","ahead","ambigAhead","skipAhead","via","advance","cmpStr","eqSimple","splice","sameSet","trail","maxLen","reverse","conflictsAt","compareRepeatPrec","posB","termsAhead","after","cont","addTo","eqSet","Shift","Reduce","mapping","mapped","hashPositions","State","startRule","actions","actionPositions","goto","tokenGroup","defaultReduce","g","addActionInner","positions","check","action","fullPos","addOrigins","actionFullPos","actionConflicts","addAction","conflict","conflictPos","findConflictOrigin","Conflict","getGoto","hasSet","dThis","dOther","added","redo","addFor","existing","none$1","origIndex","findIndex","array","computeFirstSets","change","nt","startLen","part","Core","root","hist","unshift","repeat","p2","buildFullAutomaton","startTerms","cores","getState","core","coreHash","byHash","known","startTerm","startSkip","filled","byTerm","byTermPos","atEnd","index","applyCut","replaced","count","canMergeInner","canMerge","mergeStates","newStates","newID","Group","origin","member","members","samePosSet","collapseAutomaton","assignGroups","spill","groupIndex","pass","idA","idB","mergeIdentical","didMerge","finishAutomaton","full","digitToChar","encode","low","rest","encodeArray","Parts","ensureConflicts","otherConflicts","withConflicts","BuiltRule","matches","matchesRepeat","Builder","text","options","tokenOrigins","built","ruleNames","namespaces","namedTerms","termTable","knownProps","dynamicRulePrecedences","definedGroups","astRules","currentSkip","ast","NP","NodeProp","prop","perNode","externalProp","d","MainTokenSet","LocalTokenSet","ext","ExternalTokenSet","decl","ExternalSpecializer","noSkip","newName","defineRule","scoped","sc","isEmpty","unique","skipRules","normalizeExpr","used","nodeInfo","isExported","buildRule","warn","takePrecedences","takeConflicts","defineGroup","checkGroups","base","prepareParser","simplifyRules","termNames","skipInfo","startTokens","fullTable","grp","buildLocalGroup","tokenGroups","tokenPrec","tokenData","buildTokenGroups","skipState","findSkipStates","buildSpecializeTable","tokStart","tokenizer","tokenizers","DataBuilder","skipData","storeArray","Uint32Array","forceReductions","computeForceReductions","finishCx","FinishStateContext","byDialect","dynamicPrecedences","precTable","nodeProps","skippedTypes","gatherNodeProps","stateData","computeGotoTable","nodeNames","repeatNodeCount","getParser","rawNodeProps","rawSpecialized","externalSpecializer","stack","extend","version","externalPropSource","undefined","skippedNodes","tok","contextTracker","getParserFile","rawTokenizers","rawDialects","mod","moduleStyle","gen","head","imports","imported","defined","KEYWORDS","exportName","getName","prefix","importName","spec","src","varName","lrParser","createSource","propID","serializePropValue","specializationTableString","keys","key","specHead","tableName","parserStr","includeNames","parser","gatherNonSkippedNodes","forEach","notSkipped","rec","tag","reductions","candidates","gotoEdges","o","parents","length1Reductions","createsCycle","parentIntersection","reduceAction","setSize","done","substituteArgs","arg","substituteArgsInProps","substituteInValue","conflictsFor","here","marker","precs","item","choices","choice","resolve","getToken","normalizeRepeat","normalizeSequence","builder","complete","endConflicts","getLiteral","resolveSpecialization","dynamicPrec","explicitInline","exported","registerDynamicPrec","allow","defaultName","defaultProps","ignored","dialect","builtin","finishProp","dialectID","delim","findDelimiters","addToProp","param","sp","findToken","lastToken","brackets","bracket","firstToken","_a","recur","getNamed","MinSharedActions","stateArray","sharedActions","findSharedActions","shared","scratch","fill","addr","storeActions","skipReduce","isSkip","forcedReduce","skipID","skipTable","skipTerms","addToSet","tokenizerMask","groupID","depth","findArray","search","startRules","nonSkip","num","offset","entries","list","TokenGroup","buildTokenMasks","masks","groupMask","TokenArg","scope","BuildingRule","TokenSet","building","precedenceRelations","build","lt","loop","invertRanges","rangeEdges","mid","rel","prev","level","addRel","precededBy","buildPrecTable","softConflicts","record","arguments","explicitConflicts","l","startID","allConflicts","checkTogether","errors","incompatible","stateTerms","conflicting","example","usesThis","usesOther","precOffset","fullData","cache","hasTerm","cached","MAX_CODE","ASTRAL","GAP_START","GAP_END","LOW_SURR_B","HIGH_SURR_B","hi","min","lowStr","hiStr","lowA","lowB","hiA","hiB","hop","midStart","midEnd","gatherExtTokens","findExtToken","externalTokenizer","inlineRules","inlinable","newRules","expand","mergeRules","groupStart","size","otherStart","otherName","k","buildParser","buildParserFile","toUpperCase"],"sourceRoot":""}