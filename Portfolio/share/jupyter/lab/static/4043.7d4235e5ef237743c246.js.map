{"version":3,"file":"4043.7d4235e5ef237743c246.js?v=7d4235e5ef237743c246","mappings":"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","sources":["webpack://@jupyterlab/application-top/./node_modules/style-mod/src/style-mod.js"],"sourcesContent":["const C = \"\\u037c\"\nconst COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol.for(C)\nconst SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\")\nconst top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {}\n\n// :: - Style modules encapsulate a set of CSS rules defined from\n// JavaScript. Their definitions are only available in a given DOM\n// root after it has been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\nexport class StyleModule {\n  // :: (Object<Style>, ?{finish: ?(string) → string})\n  // Create a style module from the given spec.\n  //\n  // When `finish` is given, it is called on regular (non-`@`)\n  // selectors (after `&` expansion) to compute the final selector.\n  constructor(spec, options) {\n    this.rules = []\n    let {finish} = options || {}\n\n    function splitSelector(selector) {\n      return /^@/.test(selector) ? [selector] : selector.split(/,\\s*/)\n    }\n\n    function render(selectors, spec, target, isKeyframes) {\n      let local = [], isAt = /^@(\\w+)\\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == \"keyframes\"\n      if (isAt && spec == null) return target.push(selectors[0] + \";\")\n      for (let prop in spec) {\n        let value = spec[prop]\n        if (/&/.test(prop)) {\n          render(prop.split(/,\\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),\n                 value, target)\n        } else if (value && typeof value == \"object\") {\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\")\n          render(splitSelector(prop), value, local, keyframes)\n        } else if (value != null) {\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + value + \";\")\n        }\n      }\n      if (local.length || keyframes) {\n        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(\", \") +\n                    \" {\" + local.join(\" \") + \"}\")\n      }\n    }\n\n    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules)\n  }\n\n  // :: () → string\n  // Returns a string containing the module's CSS rules.\n  getRules() { return this.rules.join(\"\\n\") }\n\n  // :: () → string\n  // Generate a new unique CSS class name.\n  static newName() {\n    let id = top[COUNT] || 1\n    top[COUNT] = id + 1\n    return C + id.toString(36)\n  }\n\n  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)\n  //\n  // Mount the given set of modules in the given DOM root, which ensures\n  // that the CSS rules defined by the module are available in that\n  // context.\n  //\n  // Rules are only added to the document once per root.\n  //\n  // Rule order will follow the order of the modules, so that rules from\n  // modules later in the array take precedence of those from earlier\n  // modules. If you call this function multiple times for the same root\n  // in a way that changes the order of already mounted modules, the old\n  // order will be changed.\n  static mount(root, modules) {\n    (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules])\n  }\n}\n\nlet adoptedSet = null\n\nclass StyleSet {\n  constructor(root) {\n    if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != \"undefined\") {\n      if (adoptedSet) {\n        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets)\n        return root[SET] = adoptedSet\n      }\n      this.sheet = new CSSStyleSheet\n      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets)\n      adoptedSet = this\n    } else {\n      this.styleTag = (root.ownerDocument || root).createElement(\"style\")\n      let target = root.head || root\n      target.insertBefore(this.styleTag, target.firstChild)\n    }\n    this.modules = []\n    root[SET] = this\n  }\n\n  mount(modules) {\n    let sheet = this.sheet\n    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i], index = this.modules.indexOf(mod)\n      if (index < j && index > -1) { // Ordering conflict\n        this.modules.splice(index, 1)\n        j--\n        index = -1\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod)\n        if (sheet) for (let k = 0; k < mod.rules.length; k++)\n          sheet.insertRule(mod.rules[k], pos++)\n      } else {\n        while (j < index) pos += this.modules[j++].rules.length\n        pos += mod.rules.length\n        j++\n      }\n    }\n\n    if (!sheet) {\n      let text = \"\"\n      for (let i = 0; i < this.modules.length; i++)\n        text += this.modules[i].getRules() + \"\\n\"\n      this.styleTag.textContent = text\n    }\n  }\n}\n\n// Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-case—the library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.\n"],"names":["C","COUNT","Symbol","for","SET","Math","floor","random","top","globalThis","window","StyleModule","constructor","spec","options","this","rules","finish","splitSelector","selector","test","split","render","selectors","target","isKeyframes","local","isAt","exec","keyframes","push","prop","value","map","part","sel","replace","reduce","a","b","concat","RangeError","l","toLowerCase","length","join","getRules","static","id","toString","root","modules","StyleSet","mount","Array","isArray","adoptedSet","head","adoptedStyleSheets","CSSStyleSheet","sheet","styleTag","ownerDocument","createElement","insertBefore","firstChild","pos","j","i","mod","index","indexOf","splice","k","insertRule","text","textContent"],"sourceRoot":""}