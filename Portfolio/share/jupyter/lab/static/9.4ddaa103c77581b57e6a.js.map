{"version":3,"file":"9.4ddaa103c77581b57e6a.js?v=4ddaa103c77581b57e6a","mappings":"+XAGA,MAAMA,EACFC,YAAYC,EAEZC,EAAOC,EAAMC,EAAMC,EAAKC,EAAUC,GAC9BC,KAAKP,KAAOA,EACZO,KAAKN,MAAQA,EACbM,KAAKL,KAAOA,EACZK,KAAKJ,KAAOA,EACZI,KAAKH,IAAMA,EACXG,KAAKF,SAAWA,EAChBE,KAAKD,UAAYA,EACjBC,KAAKC,SAAW,CAAC,CAAC,EAAAC,SAAA,YAAsBN,GAC5C,CACAO,cAAcV,EAAMC,EAAOC,EAAMS,EAAYP,GACzC,IAAID,EAAQQ,GAAcA,GAAc,GAAKX,GAAQC,GAAS,GAAM,EACpE,OAAO,IAAIH,EAAeE,EAAMC,EAAOC,EAAMC,EAAMC,EAAK,GAAI,GAChE,CACAQ,SAASC,EAAOC,GACZ,GAAID,EAAME,KAAK,EAAAN,SAAA,cAAyBF,KAAKJ,KACzCU,EAAQ,IAAI,EAAAG,KAAKH,EAAMb,KAAMa,EAAMR,SAAUQ,EAAMP,UAAWO,EAAMI,OAAQV,KAAKC,UACrFD,KAAKF,SAASa,KAAKL,GACnBN,KAAKD,UAAUY,KAAKJ,EACxB,CACAK,OAAOC,EAAShB,EAAMG,KAAKH,KACvB,IAAIiB,EAAOd,KAAKF,SAASY,OAAS,EAClC,GAAII,GAAQ,EACRjB,EAAMkB,KAAKC,IAAInB,EAAKG,KAAKD,UAAUe,GAAQd,KAAKF,SAASgB,GAAMJ,OAASV,KAAKL,MACjF,IAAIsB,EAAO,IAAI,EAAAR,KAAKI,EAAQK,MAAMlB,KAAKP,MAAOO,KAAKF,SAAUE,KAAKD,UAAWF,EAAMG,KAAKL,MAAMwB,QAAQ,CAClGC,SAAU,CAACtB,EAAUC,EAAWW,IAAW,IAAI,EAAAD,KAAK,EAAAY,SAAA,KAAevB,EAAUC,EAAWW,EAAQV,KAAKC,YAEzG,OAAOgB,CACX,EAEJ,IAAIK,GACJ,SAAWA,GACPA,EAAKA,EAAK,YAAc,GAAK,WAC7BA,EAAKA,EAAK,aAAe,GAAK,YAC9BA,EAAKA,EAAK,cAAgB,GAAK,aAC/BA,EAAKA,EAAK,cAAgB,GAAK,aAC/BA,EAAKA,EAAK,kBAAoB,GAAK,iBACnCA,EAAKA,EAAK,cAAgB,GAAK,aAC/BA,EAAKA,EAAK,eAAiB,GAAK,cAChCA,EAAKA,EAAK,YAAc,GAAK,WAC7BA,EAAKA,EAAK,eAAiB,GAAK,cAChCA,EAAKA,EAAK,eAAiB,IAAM,cACjCA,EAAKA,EAAK,eAAiB,IAAM,cACjCA,EAAKA,EAAK,eAAiB,IAAM,cACjCA,EAAKA,EAAK,eAAiB,IAAM,cACjCA,EAAKA,EAAK,eAAiB,IAAM,cACjCA,EAAKA,EAAK,kBAAoB,IAAM,iBACpCA,EAAKA,EAAK,kBAAoB,IAAM,iBACpCA,EAAKA,EAAK,aAAe,IAAM,YAC/BA,EAAKA,EAAK,iBAAmB,IAAM,gBACnCA,EAAKA,EAAK,aAAe,IAAM,YAC/BA,EAAKA,EAAK,gBAAkB,IAAM,eAClCA,EAAKA,EAAK,8BAAgC,IAAM,6BAEhDA,EAAKA,EAAK,UAAY,IAAM,SAC5BA,EAAKA,EAAK,UAAY,IAAM,SAC5BA,EAAKA,EAAK,aAAe,IAAM,YAC/BA,EAAKA,EAAK,YAAc,IAAM,WAC9BA,EAAKA,EAAK,kBAAoB,IAAM,iBACpCA,EAAKA,EAAK,QAAU,IAAM,OAC1BA,EAAKA,EAAK,SAAW,IAAM,QAC3BA,EAAKA,EAAK,cAAgB,IAAM,aAChCA,EAAKA,EAAK,WAAa,IAAM,UAC7BA,EAAKA,EAAK,WAAa,IAAM,UAC7BA,EAAKA,EAAK,yBAA2B,IAAM,wBAC3CA,EAAKA,EAAK,OAAS,IAAM,MAEzBA,EAAKA,EAAK,cAAgB,IAAM,aAChCA,EAAKA,EAAK,aAAe,IAAM,YAC/BA,EAAKA,EAAK,YAAc,IAAM,WAC9BA,EAAKA,EAAK,YAAc,IAAM,WAC9BA,EAAKA,EAAK,gBAAkB,IAAM,eAClCA,EAAKA,EAAK,YAAc,IAAM,WAC9BA,EAAKA,EAAK,YAAc,IAAM,WAC9BA,EAAKA,EAAK,YAAc,IAAM,WAC9BA,EAAKA,EAAK,aAAe,IAAM,YAC/BA,EAAKA,EAAK,aAAe,IAAM,WAClC,EA9CD,CA8CGA,IAASA,EAAO,CAAC,IAGpB,MAAMC,EAEF/B,YAEAgC,EAEAC,GACIzB,KAAKwB,MAAQA,EACbxB,KAAKyB,QAAUA,EAEfzB,KAAK0B,MAAQ,GAEb1B,KAAK2B,QAAU,EACnB,EAGJ,MAAMC,EACFpC,cAEIQ,KAAK6B,KAAO,GAGZ7B,KAAK8B,WAAa,EAElB9B,KAAK+B,QAAU,EAEf/B,KAAKgC,MAAQ,EAEbhC,KAAKiC,QAAU,GAGfjC,KAAKO,IAAM,EAEXP,KAAKkC,OAAS,EAEdlC,KAAKmC,MAAQ,CACjB,CAEAC,UACI,GAAIpC,KAAK+B,QAAU/B,KAAKO,IACpBP,KAAKqC,cACb,CAEAA,eACI,IAAIC,EAAStC,KAAKuC,UAAUvC,KAAK+B,SACjC/B,KAAKkC,OAASlC,KAAKwC,YAAYF,EAAQtC,KAAKO,IAAKP,KAAKkC,QACtDlC,KAAKO,IAAM+B,EACXtC,KAAKmC,KAAOG,GAAUtC,KAAK6B,KAAKnB,QAAU,EAAIV,KAAK6B,KAAKY,WAAWH,EACvE,CAIAC,UAAU5C,GAAQ,OAAO4C,EAAUvC,KAAK6B,KAAMlC,EAAO,CAErD+C,MAAMb,GACF7B,KAAK6B,KAAOA,EACZ7B,KAAK8B,WAAa9B,KAAK+B,QAAU/B,KAAKO,IAAMP,KAAKkC,OAAS,EAC1DlC,KAAKqC,eACLrC,KAAKgC,MAAQ,EACb,MAAOhC,KAAKiC,QAAQvB,OAChBV,KAAKiC,QAAQU,KACrB,CAKAC,SAASC,GACL7C,KAAK+B,QAAUc,EACf7C,KAAK8B,WAAa9B,KAAKwC,YAAYK,EAAI7C,KAAKO,IAAKP,KAAKkC,OAC1D,CAEAY,eAAeZ,GACXlC,KAAK8B,WAAaI,EAClBlC,KAAK+B,QAAU/B,KAAK+C,WAAWb,EACnC,CAIAc,UAAUC,GACNjD,KAAKiC,QAAQtB,KAAKsC,EACtB,CAGAT,YAAYK,EAAIlD,EAAO,EAAGuC,EAAS,GAC/B,IAAK,IAAIgB,EAAIvD,EAAMuD,EAAIL,EAAIK,IACvBhB,GAAUlC,KAAK6B,KAAKY,WAAWS,IAAM,EAAI,EAAIhB,EAAS,EAAI,EAC9D,OAAOA,CACX,CAEAa,WAAWI,GACP,IAAID,EAAI,EACR,IAAK,IAAIhB,EAAS,EAAGgB,EAAIlD,KAAK6B,KAAKnB,QAAUwB,EAASiB,EAAMD,IACxDhB,GAAUlC,KAAK6B,KAAKY,WAAWS,IAAM,EAAI,EAAIhB,EAAS,EAAI,EAC9D,OAAOgB,CACX,CAEAE,QACI,IAAKpD,KAAK8B,WACN,OAAO9B,KAAK6B,KAChB,IAAIwB,EAAS,GACb,IAAK,IAAIH,EAAI,EAAGA,EAAIlD,KAAK+B,QAASmB,IAC9BG,GAAU,IACd,OAAOA,EAASrD,KAAK6B,KAAKyB,MAAMtD,KAAK+B,QACzC,EAEJ,SAASwB,EAAYC,EAAIC,EAAIC,GACzB,GAAIA,EAAKnD,KAAOmD,EAAK7B,KAAKnB,QACrB8C,GAAMC,EAAGE,OAASD,EAAKxB,QAAUuB,EAAGG,MAAMF,EAAK1B,MAAQ,GAAGtC,MAAQgE,EAAK5B,WACxE,OAAO,KACX,GAAI4B,EAAKxB,QAAUwB,EAAK5B,WAAa,EACjC,OAAO,MACX,IAAI+B,GAAQL,EAAG/D,MAAQ6B,EAAKwC,YAAcC,EAAgBC,GAAcN,EAAMD,EAAI,OAClF,OAAOI,EAAO,IACTL,EAAG/D,MAAQ6B,EAAK2C,YAAcC,EAAiBR,EAAMD,EAAI,OAAS,IACnEC,EAAK7B,KAAKY,WAAWiB,EAAKnD,IAAMsD,EAAO,IAAML,EAAG9D,KACxD,CACA,MAAMyE,EAAoB,CACtB,CAAC7C,EAAK8C,YAAYZ,EAAIC,EAAIC,GACtB,GAAIA,EAAKvB,MAAQ,GACb,OAAO,MACXuB,EAAKzB,QAAQtB,KAAKsC,EAAI3B,EAAK+C,UAAWZ,EAAGa,UAAYZ,EAAKnD,IAAKkD,EAAGa,UAAYZ,EAAKnD,IAAM,IACzFmD,EAAKd,SAASc,EAAKnD,KAAOgE,EAAMb,EAAK7B,KAAKY,WAAWiB,EAAKnD,IAAM,IAAM,EAAI,IAC1EiD,EAAG3D,IAAM4D,EAAGa,UAAYZ,EAAK7B,KAAKnB,OAClC,OAAO,IACX,EACA,CAACY,EAAKkD,UAAUhB,EAAIiB,EAAKf,GACrB,GAAIA,EAAKxB,OAASwB,EAAK5B,WAAa0B,EAAG9D,OAASgE,EAAKvB,MAAQ,EACzD,OAAO,MACXuB,EAAKZ,eAAeY,EAAK5B,WAAa0B,EAAG9D,OACzC,OAAO,IACX,EACA,CAAC4B,EAAKwC,aAAcP,EACpB,CAACjC,EAAK2C,YAAaV,EACnB,CAACjC,EAAKoD,YAAc,OAAO,IAAM,GAErC,SAASH,EAAMI,GAAM,OAAOA,GAAM,IAAMA,GAAM,GAAKA,GAAM,IAAMA,GAAM,EAAI,CACzE,SAASpC,EAAUmB,EAAMR,EAAI,GACzB,MAAOA,EAAIQ,EAAKhD,QAAU6D,EAAMb,EAAKjB,WAAWS,IAC5CA,IACJ,OAAOA,CACX,CACA,SAAS0B,EAAclB,EAAMR,EAAGL,GAC5B,MAAOK,EAAIL,GAAM0B,EAAMb,EAAKjB,WAAWS,EAAI,IACvCA,IACJ,OAAOA,CACX,CACA,SAAS2B,EAAanB,GAClB,GAAIA,EAAKvB,MAAQ,IAAMuB,EAAKvB,MAAQ,IAChC,OAAQ,EACZ,IAAI5B,EAAMmD,EAAKnD,IAAM,EACrB,MAAOA,EAAMmD,EAAK7B,KAAKnB,QAAUgD,EAAK7B,KAAKY,WAAWlC,IAAQmD,EAAKvB,KAC/D5B,IACJ,GAAIA,EAAMmD,EAAKnD,IAAM,EACjB,OAAQ,EACZ,GAAImD,EAAKvB,MAAQ,GACb,IAAK,IAAIe,EAAI3C,EAAK2C,EAAIQ,EAAK7B,KAAKnB,OAAQwC,IACpC,GAAIQ,EAAK7B,KAAKY,WAAWS,IAAM,GAC3B,OAAQ,EACpB,OAAO3C,CACX,CACA,SAASuE,EAAapB,GAClB,OAAOA,EAAKvB,MAAQ,IAAgB,EAAIuB,EAAK7B,KAAKY,WAAWiB,EAAKnD,IAAM,IAAM,GAAK,EAAI,CAC3F,CACA,SAAS2D,EAAiBR,EAAMD,EAAIsB,GAChC,GAAIrB,EAAKvB,MAAQ,IAAMuB,EAAKvB,MAAQ,IAAMuB,EAAKvB,MAAQ,GACnD,OAAQ,EACZ,IAAI6C,EAAQ,EACZ,IAAK,IAAIzE,EAAMmD,EAAKnD,IAAM,EAAGA,EAAMmD,EAAK7B,KAAKnB,OAAQH,IAAO,CACxD,IAAIoE,EAAKjB,EAAK7B,KAAKY,WAAWlC,GAC9B,GAAIoE,GAAMjB,EAAKvB,KACX6C,SACC,IAAKT,EAAMI,GACZ,OAAQ,CAChB,CAEA,GAAII,GAAYrB,EAAKvB,MAAQ,IAAM8C,EAAkBvB,IAAS,GAAKA,EAAK1B,OAASyB,EAAGG,MAAMlD,OACtF,OAAQ,EACZ,OAAOsE,EAAQ,GAAK,EAAI,CAC5B,CACA,SAASE,EAAOzB,EAAIhE,GAChB,IAAK,IAAIyD,EAAIO,EAAGG,MAAMlD,OAAS,EAAGwC,GAAK,EAAGA,IACtC,GAAIO,EAAGG,MAAMV,GAAGzD,MAAQA,EACpB,OAAO,KACf,OAAO,KACX,CACA,SAASuE,EAAaN,EAAMD,EAAIsB,GAC5B,OAAQrB,EAAKvB,MAAQ,IAAMuB,EAAKvB,MAAQ,IAAMuB,EAAKvB,MAAQ,MACtDuB,EAAKnD,KAAOmD,EAAK7B,KAAKnB,OAAS,GAAK6D,EAAMb,EAAK7B,KAAKY,WAAWiB,EAAKnD,IAAM,QACzEwE,GAAYG,EAAOzB,EAAInC,EAAK2C,aAAeP,EAAKnB,UAAUmB,EAAKnD,IAAM,GAAKmD,EAAK7B,KAAKnB,QAAU,GAAK,CAC7G,CACA,SAASqD,EAAcL,EAAMD,EAAIsB,GAC7B,IAAIxE,EAAMmD,EAAKnD,IAAK4B,EAAOuB,EAAKvB,KAChC,OAAS,CACL,GAAIA,GAAQ,IAAMA,GAAQ,GACtB5B,SAEA,MACJ,GAAIA,GAAOmD,EAAK7B,KAAKnB,OACjB,OAAQ,EACZyB,EAAOuB,EAAK7B,KAAKY,WAAWlC,EAChC,CACA,GAAIA,GAAOmD,EAAKnD,KAAOA,EAAMmD,EAAKnD,IAAM,GACnC4B,GAAQ,IAAMA,GAAQ,IACtB5B,EAAMmD,EAAK7B,KAAKnB,OAAS,IAAM6D,EAAMb,EAAK7B,KAAKY,WAAWlC,EAAM,KACjEwE,IAAaG,EAAOzB,EAAInC,EAAKwC,eACxBJ,EAAKnB,UAAUhC,EAAM,IAAMmD,EAAK7B,KAAKnB,QAAUH,EAAMmD,EAAKnD,IAAM,GAAKmD,EAAKvB,MAAQ,IACvF,OAAQ,EACZ,OAAO5B,EAAM,EAAImD,EAAKnD,GAC1B,CACA,SAAS4E,EAAazB,GAClB,GAAIA,EAAKvB,MAAQ,GACb,OAAQ,EACZ,IAAI5B,EAAMmD,EAAKnD,IAAM,EACrB,MAAOA,EAAMmD,EAAK7B,KAAKnB,QAAUgD,EAAK7B,KAAKY,WAAWlC,IAAQ,GAC1DA,IACJ,GAAIA,EAAMmD,EAAK7B,KAAKnB,QAAUgD,EAAK7B,KAAKY,WAAWlC,IAAQ,GACvD,OAAQ,EACZ,IAAIsD,EAAOtD,EAAMmD,EAAKnD,IACtB,OAAOsD,EAAO,GAAK,EAAIA,CAC3B,CACA,SAASoB,EAAkBvB,GACvB,GAAIA,EAAKvB,MAAQ,IAAMuB,EAAKvB,MAAQ,IAAiBuB,EAAKxB,QAAUwB,EAAK5B,WAAa,EAClF,OAAQ,EACZ,IAAIvB,EAAMmD,EAAKnD,IAAM,EACrB,MAAOA,EAAMmD,EAAK7B,KAAKnB,QAAUgD,EAAK7B,KAAKY,WAAWlC,IAAQmD,EAAKvB,KAC/D5B,IACJ,IAAIV,EAAMU,EACV,MAAOA,EAAMmD,EAAK7B,KAAKnB,QAAU6D,EAAMb,EAAK7B,KAAKY,WAAWlC,IACxDA,IACJ,OAAOA,GAAOmD,EAAK7B,KAAKnB,OAASb,GAAO,CAC5C,CACA,MAAMuF,EAAY,WAAYC,EAAa,MAAOC,EAAgB,MAClE,MAAMC,EAAiB,CACnB,CAAC,oCAAqC,6BACtC,CAAC,WAAYF,GACb,CAAC,UAAWC,GACZ,CAAC,cAAe,KAChB,CAAC,kBAAmB,SACpB,CAAC,gYAAiYF,GAClY,CAAC,mHAAoHA,IAEzH,SAASI,EAAY9B,EAAMe,EAAKM,GAC5B,GAAIrB,EAAKvB,MAAQ,GACb,OAAQ,EACZ,IAAIsD,EAAO/B,EAAK7B,KAAKyB,MAAMI,EAAKnD,KAChC,IAAK,IAAI2C,EAAI,EAAGwC,EAAIH,EAAe7E,QAAUqE,EAAW,EAAI,GAAI7B,EAAIwC,EAAGxC,IACnE,GAAIqC,EAAerC,GAAG,GAAGyC,KAAKF,GAC1B,OAAOvC,EACf,OAAQ,CACZ,CACA,SAAS0C,EAAclC,EAAMnD,GACzB,IAAIsF,EAAcnC,EAAKlB,YAAYjC,EAAKmD,EAAKnD,IAAKmD,EAAKxB,QACvD,IAAI4D,EAAWpC,EAAKlB,YAAYkB,EAAKnB,UAAUhC,GAAMA,EAAKsF,GAC1D,OAAOC,GAAYD,EAAc,EAAIA,EAAc,EAAIC,CAC3D,CACA,SAASC,EAAYrE,EAAO/B,EAAMkD,GAC9B,IAAI/B,EAAOY,EAAMhB,OAAS,EAC1B,GAAII,GAAQ,GAAKY,EAAMZ,GAAM+B,IAAMlD,GAAQ+B,EAAMZ,GAAMrB,MAAQ6B,EAAK0E,SAChEtE,EAAMZ,GAAM+B,GAAKA,OAEjBnB,EAAMf,KAAKsC,EAAI3B,EAAK0E,SAAUrG,EAAMkD,GAC5C,CAKA,MAAMoD,EAAsB,CACxBC,cAAeC,UACfC,aAAa3C,EAAIC,GACb,IAAI2C,EAAO3C,EAAK5B,WAAa,EAC7B,GAAI4B,EAAKxB,OAASmE,EACd,OAAO,MACX,IAAI7E,EAAQkC,EAAKX,WAAWsD,GAC5B,IAAI1G,EAAO8D,EAAGa,UAAY9C,EAAOqB,EAAKY,EAAGa,UAAYZ,EAAK7B,KAAKnB,OAC/D,IAAIgB,EAAQ,GAAI4E,EAAe,GAC/BP,EAAYrE,EAAO/B,EAAMkD,GACzB,MAAOY,EAAG8C,YAAc7C,EAAK1B,OAASyB,EAAGG,MAAMlD,OAAQ,CACnD,GAAIgD,EAAKnD,KAAOmD,EAAK7B,KAAKnB,OAAQ,CAC9BqF,EAAYO,EAAc7C,EAAGa,UAAY,EAAGb,EAAGa,WAC/C,IAAK,IAAIkC,KAAK9C,EAAKzB,QACfqE,EAAa3F,KAAK6F,EAC1B,MACK,GAAI9C,EAAKxB,OAASmE,EAAM,CACzB,KACJ,KACK,CACD,GAAIC,EAAa5F,OAAQ,CACrB,IAAK,IAAI8F,KAAKF,EAAc,CACxB,GAAIE,EAAE/G,MAAQ6B,EAAK0E,SACfD,EAAYrE,EAAO8E,EAAE7G,KAAM6G,EAAE3D,SAE7BnB,EAAMf,KAAK6F,EACnB,CACAF,EAAe,EACnB,CACAP,EAAYrE,EAAO+B,EAAGa,UAAY,EAAGb,EAAGa,WACxC,IAAK,IAAIkC,KAAK9C,EAAKzB,QACfP,EAAMf,KAAK6F,GACf3D,EAAKY,EAAGa,UAAYZ,EAAK7B,KAAKnB,OAC9B,IAAI+F,EAAYhD,EAAGa,UAAYZ,EAAKX,WAAWW,EAAK5B,WAAa,GACjE,GAAI2E,EAAY5D,EACZkD,EAAYrE,EAAO+E,EAAW5D,EACtC,CACJ,CACA,GAAIyD,EAAa5F,OAAQ,CACrB4F,EAAeA,EAAaI,QAAOF,GAAKA,EAAE/G,MAAQ6B,EAAK0E,WACvD,GAAIM,EAAa5F,OACbgD,EAAKzB,QAAUqE,EAAaK,OAAOjD,EAAKzB,QAChD,CACAwB,EAAGmD,QAAQnD,EAAGoD,OAAOC,cAAcpF,GAAQ/B,GAAMoH,OAAOzF,EAAK0F,UAAWnE,EAAKlD,GAAOA,GACpF,OAAO,IACX,EACAsH,WAAWxD,EAAIC,GACX,IAAIwD,EAAWrC,EAAanB,GAC5B,GAAIwD,EAAW,EACX,OAAO,MACX,IAAIvH,EAAO8D,EAAGa,UAAYZ,EAAKnD,IAAKoE,EAAKjB,EAAKvB,KAAMgF,EAAMD,EAAWxD,EAAKnD,IAC1E,IAAI6G,EAAW1D,EAAKnB,UAAU2E,GAAWG,EAASzC,EAAclB,EAAK7B,KAAM6B,EAAK7B,KAAKnB,OAAQ0G,GAC7F,IAAI1F,EAAQ,CAACuB,EAAI3B,EAAKgG,SAAU3H,EAAMA,EAAOwH,IAC7C,GAAIC,EAAWC,EACX3F,EAAMf,KAAKsC,EAAI3B,EAAKiG,SAAU9D,EAAGa,UAAY8C,EAAU3D,EAAGa,UAAY+C,IAC1E,IAAK,IAAIG,EAAQ,KAAM/D,EAAG8C,YAAc7C,EAAK1B,OAASyB,EAAGG,MAAMlD,OAAQ8G,EAAQ,MAAO,CAClF,IAAItE,EAAIQ,EAAKnD,IACb,GAAImD,EAAKxB,OAASwB,EAAK5B,WAAa,EAChC,MAAOoB,EAAIQ,EAAK7B,KAAKnB,QAAUgD,EAAK7B,KAAKY,WAAWS,IAAMyB,EACtDzB,IACR,GAAIA,EAAIQ,EAAKnD,KAAO4G,GAAOzD,EAAKnB,UAAUW,IAAMQ,EAAK7B,KAAKnB,OAAQ,CAC9D,IAAK,IAAI8F,KAAK9C,EAAKzB,QACfP,EAAMf,KAAK6F,GACf9E,EAAMf,KAAKsC,EAAI3B,EAAKgG,SAAU7D,EAAGa,UAAYZ,EAAKnD,IAAKkD,EAAGa,UAAYpB,IACtEO,EAAG8C,WACH,KACJ,KACK,CACD,IAAKiB,EACDzB,EAAYrE,EAAO+B,EAAGa,UAAY,EAAGb,EAAGa,WAC5C,IAAK,IAAIkC,KAAK9C,EAAKzB,QACfP,EAAMf,KAAK6F,GACf,IAAIiB,EAAYhE,EAAGa,UAAYZ,EAAK3B,QAAS2F,EAAUjE,EAAGa,UAAYZ,EAAK7B,KAAKnB,OAChF,GAAI+G,EAAYC,EACZ3B,EAAYrE,EAAO+F,EAAWC,EACtC,CACJ,CACAjE,EAAGmD,QAAQnD,EAAGoD,OAAOC,cAAcpF,GAAQ/B,GACtCoH,OAAOzF,EAAK2F,WAAYxD,EAAGkE,cAAgBhI,GAAOA,GACvD,OAAO,IACX,EACAyE,WAAWX,EAAIC,GACX,IAAIG,EAAOiB,EAAapB,GACxB,GAAIG,EAAO,EACP,OAAO,MACXJ,EAAGmE,aAAatG,EAAK8C,WAAYV,EAAKnD,KACtCkD,EAAGmD,QAAQtF,EAAK+C,UAAWZ,EAAGa,UAAYZ,EAAKnD,IAAKkD,EAAGa,UAAYZ,EAAKnD,IAAM,GAC9EmD,EAAKd,SAASc,EAAKnD,IAAMsD,GACzB,OAAO,IACX,EACAgE,eAAepE,EAAIC,GACf,GAAIQ,EAAiBR,EAAMD,EAAI,OAAS,EACpC,OAAO,MACX,IAAI9D,EAAO8D,EAAGa,UAAYZ,EAAKnD,IAC/BkD,EAAG8C,WACH9C,EAAGmD,QAAQtF,EAAKuG,eAAgBlI,GAChC,OAAO,IACX,EACAsE,WAAWR,EAAIC,GACX,IAAIG,EAAOG,EAAaN,EAAMD,EAAI,OAClC,GAAII,EAAO,EACP,OAAO,MACX,GAAIJ,EAAGE,MAAMlE,MAAQ6B,EAAK2C,WACtBR,EAAGmE,aAAatG,EAAK2C,WAAYP,EAAK3B,QAAS2B,EAAKvB,MACxD,IAAI2F,EAAUlC,EAAclC,EAAMA,EAAKnD,IAAM,GAC7CkD,EAAGmE,aAAatG,EAAKkD,SAAUd,EAAK3B,QAAS+F,EAAUpE,EAAK5B,YAC5D2B,EAAGmD,QAAQtF,EAAKyG,SAAUtE,EAAGa,UAAYZ,EAAKnD,IAAKkD,EAAGa,UAAYZ,EAAKnD,IAAMsD,GAC7EH,EAAKZ,eAAegF,GACpB,OAAO,IACX,EACAhE,YAAYL,EAAIC,GACZ,IAAIG,EAAOE,EAAcL,EAAMD,EAAI,OACnC,GAAII,EAAO,EACP,OAAO,MACX,GAAIJ,EAAGE,MAAMlE,MAAQ6B,EAAKwC,YACtBL,EAAGmE,aAAatG,EAAKwC,YAAaJ,EAAK3B,QAAS2B,EAAK7B,KAAKY,WAAWiB,EAAKnD,IAAMsD,EAAO,IAC3F,IAAIiE,EAAUlC,EAAclC,EAAMA,EAAKnD,IAAMsD,GAC7CJ,EAAGmE,aAAatG,EAAKkD,SAAUd,EAAK3B,QAAS+F,EAAUpE,EAAK5B,YAC5D2B,EAAGmD,QAAQtF,EAAKyG,SAAUtE,EAAGa,UAAYZ,EAAKnD,IAAKkD,EAAGa,UAAYZ,EAAKnD,IAAMsD,GAC7EH,EAAKZ,eAAegF,GACpB,OAAO,IACX,EACAE,WAAWvE,EAAIC,GACX,IAAIG,EAAOsB,EAAazB,GACxB,GAAIG,EAAO,EACP,OAAO,MACX,IAAIoE,EAAMvE,EAAKnD,IAAKZ,EAAO8D,EAAGa,UAAY2D,EAC1C,IAAIC,EAAatD,EAAclB,EAAK7B,KAAM6B,EAAK7B,KAAKnB,OAAQuH,GAAME,EAAQD,EAC1E,MAAOC,EAAQF,GAAOvE,EAAK7B,KAAKY,WAAW0F,EAAQ,IAAMzE,EAAKvB,KAC1DgG,IACJ,GAAIA,GAASD,GAAcC,GAASF,IAAQ1D,EAAMb,EAAK7B,KAAKY,WAAW0F,EAAQ,IAC3EA,EAAQzE,EAAK7B,KAAKnB,OACtB,IAAI0H,EAAM3E,EAAGoD,OACRwB,MAAM/G,EAAKgH,WAAY,EAAGzE,GAC1BiD,cAAcrD,EAAG8E,OAAOC,YAAY9E,EAAK7B,KAAKyB,MAAM2E,EAAMpE,EAAO,EAAGsE,GAAQxI,EAAOkE,EAAO,IAAKlE,GACpG,GAAIwI,EAAQzE,EAAK7B,KAAKnB,OAClB0H,EAAIC,MAAM/G,EAAKgH,WAAYH,EAAQF,EAAKC,EAAaD,GACzD,IAAIQ,EAAOL,EAAIrB,OAAOzF,EAAKoH,YAAc,EAAI7E,EAAMH,EAAK7B,KAAKnB,OAASuH,GACtExE,EAAG8C,WACH9C,EAAGmD,QAAQ6B,EAAM9I,GACjB,OAAO,IACX,EACAgJ,UAAUlF,EAAIC,GACV,IAAIjE,EAAO+F,EAAY9B,EAAMD,EAAI,OACjC,GAAIhE,EAAO,EACP,OAAO,MACX,IAAIE,EAAO8D,EAAGa,UAAYZ,EAAKnD,IAAKV,EAAM0F,EAAe9F,GAAM,GAC/D,IAAIiC,EAAQ,GAAIkH,EAAW/I,GAAOuF,EAClC,OAAQvF,EAAI8F,KAAKjC,EAAK7B,OAAS4B,EAAG8C,WAAY,CAC1C,GAAI7C,EAAK1B,MAAQyB,EAAGG,MAAMlD,OAAQ,CAC9BkI,EAAW,MACX,KACJ,CACA,IAAK,IAAIpC,KAAK9C,EAAKzB,QACfP,EAAMf,KAAK6F,EACnB,CACA,GAAIoC,EACAnF,EAAG8C,WACP,IAAIsC,EAAWhJ,GAAOwF,EAAa/D,EAAKwH,aAAejJ,GAAOyF,EAAgBhE,EAAKyH,2BAA6BzH,EAAKqH,UACrH,IAAI9F,EAAKY,EAAGkE,cACZlE,EAAGmD,QAAQnD,EAAGoD,OAAOC,cAAcpF,GAAQ/B,GAAMoH,OAAO8B,EAAUhG,EAAKlD,GAAOA,GAC9E,OAAO,IACX,EACAqJ,cAAe7C,WAOnB,MAAM8C,EACFzJ,YAAY0J,GACRlJ,KAAKmJ,MAAQ,EACbnJ,KAAKoJ,KAAO,GACZpJ,KAAKO,IAAM,EACXP,KAAKwB,MAAQ0H,EAAK1H,MAClBxB,KAAKqJ,QAAQH,EAAKzH,QACtB,CACA8E,SAAS9C,EAAIC,EAAMwF,GACf,GAAIlJ,KAAKmJ,QAAU,EACf,OAAO,MACX,IAAI1H,EAAUyH,EAAKzH,QAAU,KAAOiC,EAAKN,QACzC,IAAI2D,EAAS/G,KAAKqJ,QAAQ5H,GAC1B,GAAIsF,GAAU,GAAKA,EAAStF,EAAQf,OAChC,OAAOV,KAAKsJ,SAAS7F,EAAIyF,EAAMnC,GACnC,OAAO,KACX,CACAA,OAAOtD,EAAIyF,GACP,IAAKlJ,KAAKmJ,OAAS,GAAgBnJ,KAAKmJ,OAAS,IAAkB5G,EAAU2G,EAAKzH,QAASzB,KAAKO,MAAQ2I,EAAKzH,QAAQf,OACjH,OAAOV,KAAKsJ,SAAS7F,EAAIyF,EAAMA,EAAKzH,QAAQf,QAChD,OAAO,KACX,CACA4I,SAAS7F,EAAIyF,EAAM/B,GACf1D,EAAG8F,eAAeL,EAAMjG,EAAI3B,EAAK4E,cAAelG,KAAKwB,MAAOxB,KAAKwB,MAAQ2F,EAAKnH,KAAKoJ,OACnF,OAAO,IACX,CACAI,UAAUvG,GACN,GAAIA,EAAK,CACLjD,KAAKO,IAAM0C,EAAIJ,GAAK7C,KAAKwB,MACzBxB,KAAKoJ,KAAKzI,KAAKsC,GACfjD,KAAKmJ,QACL,OAAO,IACX,CACA,GAAIlG,IAAQ,MACRjD,KAAKmJ,OAAS,EAClB,OAAO,KACX,CACAE,QAAQ5H,GACJ,OAAS,CACL,GAAIzB,KAAKmJ,QAAU,EAAgB,CAC/B,OAAQ,CACZ,MACK,GAAInJ,KAAKmJ,OAAS,EAAe,CAClC,IAAKnJ,KAAKwJ,UAAUC,GAAehI,EAASzB,KAAKO,IAAKP,KAAKwB,MAAO,OAC9D,OAAQ,EACZ,GAAIC,EAAQgB,WAAWzC,KAAKO,MAAQ,GAChC,OAAOP,KAAKmJ,OAAS,EACzBnJ,KAAKoJ,KAAKzI,KAAKsC,EAAI3B,EAAKoI,SAAU1J,KAAKO,IAAMP,KAAKwB,MAAOxB,KAAKO,IAAMP,KAAKwB,MAAQ,IACjFxB,KAAKO,KACT,MACK,GAAIP,KAAKmJ,OAAS,EAAe,CAClC,IAAKnJ,KAAKwJ,UAAUG,GAASlI,EAASc,EAAUd,EAASzB,KAAKO,KAAMP,KAAKwB,QACrE,OAAQ,CAChB,MACK,GAAIxB,KAAKmJ,OAAS,EAAc,CACjC,IAAIS,EAAOrH,EAAUd,EAASzB,KAAKO,KAAMV,EAAM,EAC/C,GAAI+J,EAAO5J,KAAKO,IAAK,CACjB,IAAIsJ,EAAQC,GAAerI,EAASmI,EAAM5J,KAAKwB,OAC/C,GAAIqI,EAAO,CACP,IAAIE,EAAWC,EAAQvI,EAASoI,EAAMhH,GAAK7C,KAAKwB,OAChD,GAAIuI,EAAW,EAAG,CACd/J,KAAKwJ,UAAUK,GACfhK,EAAMkK,CACV,CACJ,CACJ,CACA,IAAKlK,EACDA,EAAMmK,EAAQvI,EAASzB,KAAKO,KAChC,OAAOV,EAAM,GAAKA,EAAM4B,EAAQf,OAASb,GAAO,CACpD,KACK,CACD,OAAOmK,EAAQvI,EAASzB,KAAKO,IACjC,CACJ,CACJ,EAEJ,SAASyJ,EAAQnI,EAAMtB,GACnB,KAAOA,EAAMsB,EAAKnB,OAAQH,IAAO,CAC7B,IAAI4B,EAAON,EAAKY,WAAWlC,GAC3B,GAAI4B,GAAQ,GACR,MACJ,IAAKoC,EAAMpC,GACP,OAAQ,CAChB,CACA,OAAO5B,CACX,CACA,MAAM0J,EACF1D,SAAS9C,EAAIC,EAAMwF,GACf,IAAIgB,EAAYxG,EAAK1B,MAAQyB,EAAGG,MAAMlD,QAAU,EAAIuE,EAAkBvB,GACtE,IAAIvB,EAAOuB,EAAKvB,KAChB,GAAI+H,EAAY,EACZ,OAAO,MACX,IAAIC,EAAgBlH,EAAI3B,EAAKgH,WAAY7E,EAAGa,UAAYZ,EAAKnD,IAAKkD,EAAGa,UAAY4F,GACjFzG,EAAG8C,WACH9C,EAAG8F,eAAeL,EAAMjG,EAAId,GAAQ,GAAKb,EAAK8I,eAAiB9I,EAAK+I,eAAgBnB,EAAK1H,MAAOiC,EAAGkE,cAAe,IAC3GlE,EAAG8E,OAAOC,YAAYU,EAAKzH,QAASyH,EAAK1H,OAC5C2I,KAEJ,OAAO,IACX,CACApD,SACI,OAAO,KACX,EAEJ,MAAMuD,EAAoB,CACtBpE,cAAcqE,EAAGrB,GAAQ,OAAOA,EAAKzH,QAAQgB,WAAW,IAAM,GAAe,IAAIwG,EAAoBC,GAAQ,IAAM,EACnHF,gBAAkB,OAAO,IAAIiB,CAAqB,GAEtD,MAAMO,EAAiB,CACnB,CAACD,EAAG7G,IAASyB,EAAazB,IAAS,EACnC,CAAC6G,EAAG7G,IAASmB,EAAanB,IAAS,EACnC,CAAC6G,EAAG7G,IAASoB,EAAapB,IAAS,EACnC,CAAC+G,EAAG/G,IAASM,EAAaN,EAAM+G,EAAG,OAAS,EAC5C,CAACA,EAAG/G,IAASK,EAAcL,EAAM+G,EAAG,OAAS,EAC7C,CAACA,EAAG/G,IAASQ,EAAiBR,EAAM+G,EAAG,OAAS,EAChD,CAACA,EAAG/G,IAAS8B,EAAY9B,EAAM+G,EAAG,OAAS,GAE/C,MAAMC,EAAiB,CAAE7I,KAAM,GAAIhC,IAAK,GAExC,MAAM8K,EAEFnL,YAEA+I,EAEAqC,EAAOC,EAEPC,GACI9K,KAAKuI,OAASA,EACdvI,KAAK4K,MAAQA,EACb5K,KAAK8K,OAASA,EACd9K,KAAK0D,KAAO,IAAI9B,EAChB5B,KAAK+K,MAAQ,MAEb/K,KAAKgL,WAAa,IAAIC,IACtBjL,KAAKkL,UAAY,KAEjBlL,KAAKmL,OAAS,EACdnL,KAAK6C,GAAKiI,EAAOA,EAAOpK,OAAS,GAAGmC,GACpC7C,KAAKsE,UAAYtE,KAAKoL,kBAAoBpL,KAAKqL,gBAAkBP,EAAO,GAAGnL,KAC3EK,KAAK2D,MAAQpE,EAAe+L,OAAOhK,EAAKoD,SAAU,EAAG1E,KAAKsE,UAAW,EAAG,GACxEtE,KAAK4D,MAAQ,CAAC5D,KAAK2D,OACnB3D,KAAK6K,UAAYA,EAAUnK,OAAS,IAAI6K,GAAeV,EAAWD,GAAS,KAC3E5K,KAAKwL,UACT,CACIC,gBACA,OAAOzL,KAAKoL,iBAChB,CACA/B,UACI,GAAIrJ,KAAKkL,WAAa,MAAQlL,KAAKoL,kBAAoBpL,KAAKkL,UACxD,OAAOlL,KAAK+G,SAChB,IAAI,KAAErD,GAAS1D,KACf,OAAS,CACL,MAAO0D,EAAK1B,MAAQhC,KAAK4D,MAAMlD,OAC3BV,KAAK0L,gBACT,IAAK,IAAIC,KAAQjI,EAAKzB,QAClBjC,KAAK4G,QAAQ+E,EAAKlM,KAAMkM,EAAKhM,KAAMgM,EAAK9I,IAC5C,GAAIa,EAAKnD,IAAMmD,EAAK7B,KAAKnB,OACrB,MAEJ,IAAKV,KAAKuG,WACN,OAAOvG,KAAK+G,QACpB,CACA,GAAI/G,KAAK6K,WAAa7K,KAAK4L,cAAclI,EAAK3B,SAC1C,OAAO,KACXP,EAAO,OAAS,CACZ,IAAK,IAAI/B,KAAQO,KAAKuI,OAAOsD,aACzB,GAAIpM,EAAM,CACN,IAAI4D,EAAS5D,EAAKO,KAAM0D,GACxB,GAAIL,GAAU,MAAO,CACjB,GAAIA,GAAU,KACV,OAAO,KACXK,EAAKtB,UACL,SAASZ,CACb,CACJ,CACJ,KACJ,CACA,IAAI0H,EAAO,IAAI3H,EAAUvB,KAAKsE,UAAYZ,EAAKnD,IAAKmD,EAAK7B,KAAKyB,MAAMI,EAAKnD,MACzE,IAAK,IAAIuL,KAAS9L,KAAKuI,OAAOwD,iBAC1B,GAAID,EAAO,CACP,IAAIvD,EAASuD,EAAM9L,KAAMkJ,GACzB,GAAIX,EACAW,EAAKvH,QAAQhB,KAAK4H,EAC1B,CACJyD,EAAO,MAAOhM,KAAKuG,WAAY,CAC3B,GAAI7C,EAAKnD,KAAOmD,EAAK7B,KAAKnB,OACtB,MACJ,GAAIgD,EAAKxB,OAASwB,EAAK5B,WAAa,EAAG,CACnC,IAAK,IAAImK,KAAQjM,KAAKuI,OAAO2D,aACzB,GAAID,EAAKjM,KAAM0D,EAAMwF,GACjB,MAAM8C,CAClB,CACA,IAAK,IAAIzD,KAAUW,EAAKvH,QACpB,GAAI4G,EAAOhC,SAASvG,KAAM0D,EAAMwF,GAC5B,OAAO,KACfA,EAAKzH,SAAW,KAAOiC,EAAKN,QAC5B,IAAK,IAAIoD,KAAK9C,EAAKzB,QACfiH,EAAKxH,MAAMf,KAAK6F,EACxB,CACAxG,KAAKmM,WAAWjD,GAChB,OAAO,IACX,CACAkD,OAAO7L,GACH,GAAIP,KAAKkL,WAAa,MAAQlL,KAAKkL,UAAY3K,EAC3C,MAAM,IAAI8L,WAAW,gCACzBrM,KAAKkL,UAAY3K,CACrB,CACAqL,cAAcpK,GACV,IAAKxB,KAAK6K,UAAUyB,OAAOtM,KAAKoL,kBAAoB5J,EAAOxB,KAAKoL,qBAC3DpL,KAAK6K,UAAU0B,QAAQvM,KAAK2D,MAAM/D,MACnC,OAAO,MACX,IAAI4M,EAAQxM,KAAK6K,UAAU4B,UAAUzM,MACrC,IAAKwM,EACD,OAAO,MACX,IAAIE,EAAcF,EAAO3M,EAAMG,KAAKoL,kBAAoBoB,EACxD,IAAK,IAAItJ,EAAI,EAAGA,EAAIlD,KAAK8K,OAAOpK,OAAQwC,IAAK,CACzC,IAAIyJ,EAAU3M,KAAK8K,OAAO5H,EAAI,GAAGL,GAAI+J,EAAQ5M,KAAK8K,OAAO5H,GAAGvD,KAC5D,GAAIgN,GAAW3M,KAAKsE,WAAasI,EAAQ/M,EACrC6M,GAAeE,EAAQD,CAC/B,CACA3M,KAAKsE,WAAaoI,EAClB1M,KAAKoL,mBAAqBoB,EAC1BxM,KAAK6M,aACL,GAAI7M,KAAKoL,kBAAoBpL,KAAK6C,GAAI,CAClC7C,KAAKsE,YACLtE,KAAKoL,oBACLpL,KAAKwL,UACT,KACK,CACDxL,KAAK+K,MAAQ,KACb/K,KAAKwL,UACT,CACA,OAAO,IACX,CAEIxJ,YACA,OAAOhC,KAAK4D,MAAMlD,MACtB,CAGAoM,WAAW9K,EAAQhC,KAAKgC,MAAQ,GAC5B,OAAOhC,KAAKuI,OAAO1H,QAAQK,MAAMlB,KAAK4D,MAAM5B,GAAOvC,KACvD,CAMA8G,WACIvG,KAAKsE,WAAatE,KAAK0D,KAAK7B,KAAKnB,OACjC,GAAIV,KAAKqL,iBAAmBrL,KAAK6C,GAAI,CACjC7C,KAAKoL,kBAAoBpL,KAAKqL,gBAC9BrL,KAAK+K,MAAQ,KACb/K,KAAKwL,WACL,OAAO,KACX,KACK,CACDxL,KAAKsE,YACLtE,KAAKoL,kBAAoBpL,KAAKqL,gBAAkB,EAChDrL,KAAK6M,aACL7M,KAAKwL,WACL,OAAO,IACX,CACJ,CACAqB,aACI,MAAO7M,KAAKmL,OAASnL,KAAK8K,OAAOpK,OAAS,GAAKV,KAAKoL,mBAAqBpL,KAAK8K,OAAO9K,KAAKmL,QAAQtI,GAAI,CAClG7C,KAAKmL,SACLnL,KAAKoL,kBAAoBrK,KAAKC,IAAIhB,KAAKoL,kBAAmBpL,KAAK8K,OAAO9K,KAAKmL,QAAQxL,KACvF,CACJ,CAEAoN,SAASvL,GACL,IAAIwL,EAAItC,EACRsC,EAAEnN,IAAM2B,EACR,GAAIA,GAASxB,KAAK6C,GAAI,CAClBmK,EAAEnL,KAAO,EACb,KACK,CACDmL,EAAEnL,KAAO7B,KAAKiN,YAAYzL,GAC1BwL,EAAEnN,KAAOmN,EAAEnL,KAAKnB,OAChB,GAAIV,KAAK8K,OAAOpK,OAAS,EAAG,CACxB,IAAIwM,EAAalN,KAAKoL,kBAAmBD,EAASnL,KAAKmL,OACvD,MAAOnL,KAAK8K,OAAOK,GAAQtI,GAAKmK,EAAEnN,IAAK,CACnCsL,IACA,IAAIgC,EAAWnN,KAAK8K,OAAOK,GAAQxL,KACnC,IAAIwI,EAAQnI,KAAKiN,YAAYE,GAC7BH,EAAEnN,IAAMsN,EAAWhF,EAAMzH,OACzBsM,EAAEnL,KAAOmL,EAAEnL,KAAKyB,MAAM,EAAGtD,KAAK8K,OAAOK,EAAS,GAAGtI,GAAKqK,GAAc/E,EACpE+E,EAAaF,EAAEnN,IAAMmN,EAAEnL,KAAKnB,MAChC,CACJ,CACJ,CACA,OAAOsM,CACX,CAEAxB,WACI,IAAI,KAAE9H,GAAS1D,MAAM,KAAE6B,EAAI,IAAEhC,GAAQG,KAAK+M,SAAS/M,KAAKoL,mBACxDpL,KAAKqL,gBAAkBxL,EACvB6D,EAAKhB,MAAMb,GACX,KAAO6B,EAAK1B,MAAQhC,KAAK4D,MAAMlD,OAAQgD,EAAK1B,QAAS,CACjD,IAAIyB,EAAKzD,KAAK4D,MAAMF,EAAK1B,OAAQoL,EAAUpN,KAAKuI,OAAO8E,kBAAkB5J,EAAGhE,MAC5E,IAAK2N,EACD,MAAM,IAAIE,MAAM,2BAA6BhM,EAAKmC,EAAGhE,OACzD,IAAK2N,EAAQ3J,EAAIzD,KAAM0D,GACnB,MACJA,EAAKtB,SACT,CACJ,CACA6K,YAAY1M,GACR,IAAI4B,EAAOnC,KAAK4K,MAAM2C,MAAMhN,GAAMsB,EAClC,IAAK7B,KAAK4K,MAAM4C,WAAY,CACxB,IAAIC,EAAMtL,EAAKuL,QAAQ,MACvB7L,EAAO4L,EAAM,EAAItL,EAAOA,EAAKmB,MAAM,EAAGmK,EAC1C,KACK,CACD5L,EAAOM,GAAQ,KAAO,GAAKA,CAC/B,CACA,OAAO5B,EAAMsB,EAAKnB,OAASV,KAAK6C,GAAKhB,EAAKyB,MAAM,EAAGtD,KAAK6C,GAAKtC,GAAOsB,CACxE,CAEA8F,cAAgB,OAAO3H,KAAK+K,MAAQ/K,KAAKsE,UAAYtE,KAAKsE,UAAY,CAAG,CAEzEsD,aAAanI,EAAM+B,EAAO9B,EAAQ,GAC9BM,KAAK2D,MAAQpE,EAAe+L,OAAO7L,EAAMC,EAAOM,KAAKsE,UAAY9C,EAAOxB,KAAK2D,MAAM/D,KAAMI,KAAKsE,UAAYtE,KAAK0D,KAAK7B,KAAKnB,QACzHV,KAAK4D,MAAMjD,KAAKX,KAAK2D,MACzB,CAGAgK,eAAelO,EAAM+B,EAAO9B,EAAQ,GAChCM,KAAK4H,aAAa5H,KAAKuI,OAAOqF,YAAYnO,GAAO+B,EAAO9B,EAC5D,CAEAkH,QAAQjD,EAAOhE,EAAMkD,GACjB,UAAWc,GAAS,SAChBA,EAAQ,IAAI,EAAAlD,KAAKT,KAAKuI,OAAO1H,QAAQK,MAAMyC,GAAQkK,EAAMA,GAAOhL,IAAO,MAAQA,SAAY,EAAIA,EAAK7C,KAAK2H,eAAiBhI,GAC9HK,KAAK2D,MAAMtD,SAASsD,EAAOhE,EAAOK,KAAK2D,MAAMhE,KACjD,CAGAmO,WAAW7K,GACPjD,KAAK2D,MAAMtD,SAAS4C,EAAIrC,OAAOZ,KAAKuI,OAAO1H,SAAUoC,EAAItD,KAAOK,KAAK2D,MAAMhE,KAC/E,CAIA4J,eAAeL,EAAMjG,GACjBjD,KAAK4G,QAAQ5G,KAAK6G,OACbC,cAAciH,GAAY9K,EAAInD,SAAUoJ,EAAKxH,QAASuB,EAAItD,MAC1DoH,OAAO9D,EAAIxD,KAAMwD,EAAIJ,GAAKI,EAAItD,MAAOsD,EAAItD,KAClD,CAEA+L,gBACI,IAAIjI,EAAKzD,KAAK4D,MAAMjB,MACpB,IAAIqL,EAAMhO,KAAK4D,MAAM5D,KAAK4D,MAAMlD,OAAS,GACzCsN,EAAI3N,SAASoD,EAAG7C,OAAOZ,KAAKuI,OAAO1H,SAAU4C,EAAG9D,KAAOqO,EAAIrO,MAC3DK,KAAK2D,MAAQqK,CACjB,CACAjH,SACI,MAAO/G,KAAK4D,MAAMlD,OAAS,EACvBV,KAAK0L,gBACT,OAAO1L,KAAKiO,QAAQjO,KAAK2D,MAAM/C,OAAOZ,KAAKuI,OAAO1H,QAASb,KAAKsE,WACpE,CACA2J,QAAQhN,GACJ,OAAOjB,KAAK8K,OAAOpK,OAAS,EAAIwN,EAAWlO,KAAK8K,OAAQ,EAAG7J,EAAKkN,QAASnO,KAAK8K,OAAO,GAAGnL,KAAMK,KAAKgL,YAAc/J,CACrH,CAEAkL,WAAWjD,GACP,IAAK,IAAIX,KAAUW,EAAKvH,QACpB,GAAI4G,EAAOxB,OAAO/G,KAAMkJ,GACpB,OACR,IAAIkF,EAASL,GAAY/N,KAAKuI,OAAOC,YAAYU,EAAKzH,QAASyH,EAAK1H,OAAQ0H,EAAKxH,OACjF1B,KAAK4G,QAAQ5G,KAAK6G,OACbC,cAAcsH,GAASlF,EAAK1H,OAC5BuF,OAAOzF,EAAK+M,UAAWnF,EAAKzH,QAAQf,QAASwI,EAAK1H,MAC3D,CACAyB,IAAIxD,EAAME,EAAMkD,EAAI/C,GAChB,UAAWL,GAAQ,SACf,OAAOwD,EAAIjD,KAAKuI,OAAOqF,YAAYnO,GAAOE,EAAMkD,EAAI/C,GACxD,OAAO,IAAIwO,EAAY7O,EAAME,EACjC,CAEIkH,aAAW,OAAO,IAAI0H,EAAOvO,KAAKuI,OAAO1H,QAAU,EAE3D,SAASqN,EAAWpD,EAAQK,EAAQlK,EAAMuN,EAAQC,GAC9C,GAAIA,EAAKC,IAAIzN,EAAKA,MACd,OAAOA,EAAKA,KAChB,IAAI0N,EAAW7D,EAAOK,GAAQtI,GAC9B,IAAI/C,EAAW,GAAIC,EAAY,GAAIyB,EAAQP,EAAKtB,KAAO6O,EACvD,SAASI,EAAaC,EAAMC,GACxB,MAAOA,EAAYD,GAAQF,EAAWE,EAAOF,EAAU,CACnD,IAAI9K,EAAOiH,EAAOK,EAAS,GAAGxL,KAAOgP,EACrCH,GAAU3K,EACVgL,GAAQhL,EACRsH,IACAwD,EAAW7D,EAAOK,GAAQtI,EAC9B,CACJ,CACA,IAAK,IAAI8B,EAAK1D,EAAK8N,WAAYpK,EAAIA,EAAKA,EAAGqK,YAAa,CACpDJ,EAAajK,EAAGhF,KAAO6O,EAAQ,MAC/B,IAAI7O,EAAOgF,EAAGhF,KAAO6O,EAAQ/F,EAC7B,GAAI9D,EAAG9B,GAAK2L,EAASG,EAAU,CAC3BlG,EAAOyF,EAAWpD,EAAQK,EAAQxG,EAAI6J,EAAQC,GAC9CG,EAAajK,EAAG9B,GAAK2L,EAAQ,MACjC,KACK,CACD/F,EAAO9D,EAAG/D,QACd,CACAd,EAASa,KAAK8H,GACd1I,EAAUY,KAAKhB,EAAO6B,EAC1B,CACAoN,EAAa3N,EAAK4B,GAAK2L,EAAQ,OAC/B,OAAO,IAAI,EAAA/N,KAAKQ,EAAKxB,KAAMK,EAAUC,EAAWkB,EAAK4B,GAAK2L,EAAShN,EAAOP,EAAKA,KAAOA,EAAKA,KAAKgO,WAAa9I,UACjH,CAEA,MAAM+I,UAAuB,EAAAC,OAEzB3P,YAGAqB,EAEAgL,EAEAE,EAEAqD,EAEAlD,EAEAmB,EAEAgC,EAEAC,EAEAC,GACIC,QACAxP,KAAKa,QAAUA,EACfb,KAAK6L,aAAeA,EACpB7L,KAAK+L,iBAAmBA,EACxB/L,KAAKoP,WAAaA,EAClBpP,KAAKkM,aAAeA,EACpBlM,KAAKqN,kBAAoBA,EACzBrN,KAAKqP,cAAgBA,EACrBrP,KAAKsP,YAAcA,EACnBtP,KAAKuP,SAAWA,EAEhBvP,KAAKyP,UAAYC,OAAOpE,OAAO,MAC/B,IAAK,IAAIqE,KAAK9O,EAAQK,MAClBlB,KAAKyP,UAAUE,EAAEC,MAAQD,EAAEE,EACnC,CACAC,YAAYlF,EAAOC,EAAWC,GAC1B,IAAIgB,EAAQ,IAAInB,EAAa3K,KAAM4K,EAAOC,EAAWC,GACrD,IAAK,IAAIiF,KAAK/P,KAAKuP,SACfzD,EAAQiE,EAAEjE,EAAOlB,EAAOC,EAAWC,GACvC,OAAOgB,CACX,CAEAkE,UAAUC,GACN,IAAIC,EAASC,EAAcF,GAC3B,IAAKC,EACD,OAAOlQ,KACX,IAAI,QAAEa,EAAO,kBAAEwM,GAAsBrN,KACrC,IAAI6L,EAAe7L,KAAK6L,aAAavI,QAASyI,EAAmB/L,KAAK+L,iBAAiBzI,QAAS8L,EAAapP,KAAKoP,WAAW9L,QAAS+L,EAAgBrP,KAAKqP,cAAc/L,QAASgM,EAActP,KAAKsP,YAAYhM,QAAS4I,EAAelM,KAAKkM,aAAa5I,QAASiM,EAAWvP,KAAKuP,SACpR,GAAIa,EAASF,EAAOG,aAAc,CAC9BhD,EAAoBqC,OAAOY,OAAO,CAAC,EAAGjD,GACtC,IAAIoC,EAAY5O,EAAQK,MAAMoC,QAASiN,EACvC,IAAK,IAAIC,KAAKN,EAAOG,YAAa,CAC9B,IAAI,KAAET,EAAI,MAAEjM,EAAK,UAAE8M,EAAS,MAAEC,UAAiBF,GAAK,SAAW,CAAEZ,KAAMY,GAAMA,EAC7E,GAAIf,EAAUkB,MAAKhB,GAAKA,EAAEC,MAAQA,IAC9B,SACJ,GAAIa,EACApD,EAAkBoC,EAAU/O,QACxB,CAAC8C,EAAIC,EAAIC,IAAS+M,EAAUhN,EAAIC,EAAMF,EAAG9D,OACjD,IAAImQ,EAAKJ,EAAU/O,OACnB,IAAIkQ,EAAQH,EAAY,CAAC,QAAS,iBAAmB9M,EAAQwC,UACvD0J,GAAMvO,EAAKoH,aAAemH,GAAMvO,EAAK+I,eAAiB,CAAC,QAAS,YAAa,WAAa,CAAC,QAAS,aAC1GoF,EAAU9O,KAAK,EAAAU,SAAA,OAAgB,CAC3BwO,KACAD,OACAiB,MAAOD,GAAS,CAAC,CAAC,EAAA1Q,SAAA,MAAgB0Q,OAEtC,GAAIF,EAAO,CACP,IAAKH,EACDA,EAAS,CAAC,EACd,GAAIO,MAAMC,QAAQL,IAAUA,aAAiB,EAAAM,IACzCT,EAAOX,GAAQc,OAEfhB,OAAOY,OAAOC,EAAQG,EAC9B,CACJ,CACA7P,EAAU,IAAI,EAAAoQ,QAAQxB,GACtB,GAAIc,EACA1P,EAAUA,EAAQqQ,QAAO,IAAAC,WAAUZ,GAC3C,CACA,GAAIH,EAASF,EAAOW,OAChBhQ,EAAUA,EAAQqQ,UAAUhB,EAAOW,OACvC,GAAIT,EAASF,EAAOkB,QAAS,CACzB,IAAK,IAAIC,KAAMnB,EAAOkB,OAAQ,CAC1B,IAAIzN,EAAQ3D,KAAKoP,WAAW1B,QAAQ2D,GAAKjD,EAASpO,KAAKsP,YAAY5B,QAAQ2D,GAC3E,GAAI1N,GAAS,EACTkI,EAAalI,GAASoI,EAAiBpI,GAASwC,UACpD,GAAIiI,GAAU,EACViB,EAAcjB,GAAUjI,SAChC,CACJ,CACA,GAAIiK,EAASF,EAAOoB,YAAa,CAC7B,IAAK,IAAIrB,KAAQC,EAAOoB,WAAY,CAChC,IAAIC,EAAQnC,EAAW1B,QAAQuC,EAAKL,MACpC,GAAI2B,GAAS,EAAG,CACZ1F,EAAa0F,GAAStB,EAAKnE,MAC3BC,EAAiBwF,GAAStB,EAAK/G,IACnC,KACK,CACD,IAAI3I,EAAM0P,EAAKuB,OAASC,EAASrC,EAAYa,EAAKuB,QAC5CvB,EAAK9H,MAAQsJ,EAASrC,EAAYa,EAAK9H,OAAS,EAAIiH,EAAW1O,OAAS,EAC9EmL,EAAa6F,OAAOnR,EAAK,EAAG0P,EAAKnE,OACjCC,EAAiB2F,OAAOnR,EAAK,EAAG0P,EAAK/G,MACrCkG,EAAWsC,OAAOnR,EAAK,EAAG0P,EAAKL,KACnC,CACA,GAAIK,EAAK0B,QACLzF,EAAavL,KAAKsP,EAAK0B,QAC/B,CACJ,CACA,GAAIvB,EAASF,EAAO1H,aAAc,CAC9B,IAAK,IAAIyH,KAAQC,EAAO1H,YAAa,CACjC,IAAI+I,EAAQjC,EAAY5B,QAAQuC,EAAKL,MACrC,GAAI2B,GAAS,EAAG,CACZlC,EAAckC,GAAStB,EAAKnE,KAChC,KACK,CACD,IAAIvL,EAAM0P,EAAKuB,OAASC,EAASnC,EAAaW,EAAKuB,QAC7CvB,EAAK9H,MAAQsJ,EAASnC,EAAaW,EAAK9H,OAAS,EAAImH,EAAY5O,OAAS,EAChF2O,EAAcqC,OAAOnR,EAAK,EAAG0P,EAAKnE,OAClCwD,EAAYoC,OAAOnR,EAAK,EAAG0P,EAAKL,KACpC,CACJ,CACJ,CACA,GAAIM,EAAO0B,KACPrC,EAAWA,EAAS5I,OAAOuJ,EAAO0B,MACtC,OAAO,IAAI1C,EAAerO,EAASgL,EAAcE,EAAkBqD,EAAYlD,EAAcmB,EAAmBgC,EAAeC,EAAaC,EAChJ,CAEA3B,YAAYgC,GACR,IAAI2B,EAAQvR,KAAKyP,UAAUG,GAC3B,GAAI2B,GAAS,KACT,MAAM,IAAIlF,WAAW,sBAAsBuD,MAC/C,OAAO2B,CACX,CAIA/I,YAAY3G,EAAM2M,GACd,IAAI/K,EAAK,IAAIoO,GAAc7R,KAAM6B,EAAM2M,GACvCsD,EAAO,IAAK,IAAIvR,EAAMiO,EAAQjO,EAAMkD,EAAG5D,KAAM,CACzC,IAAIsC,EAAOsB,EAAGsO,KAAKxR,GACnB,IAAK,IAAIyR,KAAShS,KAAKqP,cACnB,GAAI2C,EAAO,CACP,IAAI3O,EAAS2O,EAAMvO,EAAItB,EAAM5B,GAC7B,GAAI8C,GAAU,EAAG,CACb9C,EAAM8C,EACN,SAASyO,CACb,CACJ,CACJvR,GACJ,CACA,OAAOkD,EAAGwO,eAAe,EAC7B,EAEJ,SAAS7B,EAAS8B,GACd,OAAOA,GAAK,MAAQA,EAAExR,OAAS,CACnC,CACA,SAASyP,EAAcF,GACnB,IAAKa,MAAMC,QAAQd,GACf,OAAOA,EACX,GAAIA,EAAKvP,QAAU,EACf,OAAO,KACX,IAAIyR,EAAOhC,EAAcF,EAAK,IAC9B,GAAIA,EAAKvP,QAAU,EACf,OAAOyR,EACX,IAAI1M,EAAO0K,EAAcF,EAAK3M,MAAM,IACpC,IAAKmC,IAAS0M,EACV,OAAOA,GAAQ1M,EACnB,IAAI2M,EAAO,CAACF,EAAGG,KAAOH,GAAKrE,GAAMlH,OAAO0L,GAAKxE,GAC7C,IAAIyE,EAAQH,EAAKP,KAAMW,EAAQ9M,EAAKmM,KACpC,MAAO,CACHf,MAAOuB,EAAKD,EAAKtB,MAAOpL,EAAKoL,OAC7BR,YAAa+B,EAAKD,EAAK9B,YAAa5K,EAAK4K,aACzCiB,WAAYc,EAAKD,EAAKb,WAAY7L,EAAK6L,YACvC9I,YAAa4J,EAAKD,EAAK3J,YAAa/C,EAAK+C,aACzC4I,OAAQgB,EAAKD,EAAKf,OAAQ3L,EAAK2L,QAC/BQ,MAAOU,EAAQC,GAASA,EAAQD,EAC5B,CAACE,EAAO5H,EAAOC,EAAWC,IAAWwH,EAAMC,EAAMC,EAAO5H,EAAOC,EAAWC,GAASF,EAAOC,EAAWC,GAEjH,CACA,SAAS2G,EAASgB,EAAO7C,GACrB,IAAI2B,EAAQkB,EAAM/E,QAAQkC,GAC1B,GAAI2B,EAAQ,EACR,MAAM,IAAIlF,WAAW,iDAAiDuD,KAC1E,OAAO2B,CACX,CACA,IAAI9B,EAAY,CAAC,EAAApO,SAAA,MACjB,IAAK,IAAI6B,GAAI,EAAG0M,GAAMA,GAAOtO,EAAK4B,IAAIA,KAAK,CACvCuM,EAAUvM,IAAK,EAAA7B,SAAA,OAAgB,CAC3BwO,GAAI3M,GACJ0M,QACAiB,MAAO3N,IAAK5B,EAAKoR,OAAS,GAAK,CAAC,CAAC,EAAAxS,SAAA,MAAgBgD,MAAKiB,EAAoB,CAAC,QAAS,gBAAkB,CAAC,QAAS,gBAExH,CACA,MAAM0J,EAAO,GACb,MAAMU,EACF/O,YAAYqB,GACRb,KAAKa,QAAUA,EACfb,KAAKyB,QAAU,GACfzB,KAAK2S,MAAQ,EACjB,CACAtK,MAAM5I,EAAME,EAAMkD,EAAI/C,EAAW,GAC7BE,KAAKyB,QAAQd,KAAKlB,EAAME,EAAMkD,EAAI,EAAI/C,EAAW,GACjD,OAAOE,IACX,CACA8G,cAAcsC,EAAMoF,EAAS,GACzB,IAAK,IAAI9I,KAAK0D,EACV1D,EAAEkN,QAAQ5S,KAAMwO,GACpB,OAAOxO,IACX,CACA+G,OAAOtH,EAAMiB,GACT,OAAO,EAAAD,KAAA,MAAW,CACdoG,OAAQ7G,KAAKyB,QACbZ,QAASb,KAAKa,QACdgS,OAAQ7S,KAAK2S,MACbG,MAAOrT,EACPiB,UAER,EAGJ,MAAMqS,EAEFvT,YAGAC,EAEAE,EAEAkD,EAEA/C,EAAW+N,GACP7N,KAAKP,KAAOA,EACZO,KAAKL,KAAOA,EACZK,KAAK6C,GAAKA,EACV7C,KAAKF,SAAWA,CACpB,CAEA8S,QAAQxK,EAAKoG,GACT,IAAIwE,EAAW5K,EAAI3G,QAAQf,OAC3B0H,EAAItB,cAAc9G,KAAKF,SAAU0O,GACjCpG,EAAI3G,QAAQd,KAAKX,KAAKP,KAAMO,KAAKL,KAAO6O,EAAQxO,KAAK6C,GAAK2L,EAAQpG,EAAI3G,QAAQf,OAAS,EAAIsS,EAC/F,CAEApS,OAAOC,GACH,OAAO,IAAI0N,EAAO1N,GAASiG,cAAc9G,KAAKF,UAAWE,KAAKL,MAAMoH,OAAO/G,KAAKP,KAAMO,KAAK6C,GAAK7C,KAAKL,KACzG,EAEJ,MAAM2O,EACF9O,YAAYyB,EAAMtB,GACdK,KAAKiB,KAAOA,EACZjB,KAAKL,KAAOA,CAChB,CACIkD,SAAO,OAAO7C,KAAKL,KAAOK,KAAKiB,KAAKP,MAAQ,CAC5CjB,WAAS,OAAOO,KAAKiB,KAAKxB,KAAKoQ,EAAI,CACnC/P,eAAa,OAAO+N,CAAM,CAC9B+E,QAAQxK,EAAKoG,GACTpG,EAAIuK,MAAMhS,KAAKX,KAAKiB,MACpBmH,EAAI3G,QAAQd,KAAKyH,EAAIuK,MAAMjS,OAAS,EAAGV,KAAKL,KAAO6O,EAAQxO,KAAK6C,GAAK2L,GAAS,EAClF,CACA5N,SAAW,OAAOZ,KAAKiB,IAAM,EAEjC,SAASgC,EAAIxD,EAAME,EAAMkD,EAAI/C,GACzB,OAAO,IAAIiT,EAAQtT,EAAME,EAAMkD,EAAI/C,EACvC,CACA,MAAMmT,EAAqB,CAAEC,QAAS,WAAYvH,KAAM,gBACxD,MAAMwH,EAAmB,CAAED,QAAS,WAAYvH,KAAM,gBACtD,MAAMyH,EAAY,CAAC,EAAGC,GAAa,CAAC,EACpC,MAAMC,GACF9T,YAAYC,EAAME,EAAMkD,EAAI0Q,GACxBvT,KAAKP,KAAOA,EACZO,KAAKL,KAAOA,EACZK,KAAK6C,GAAKA,EACV7C,KAAKuT,KAAOA,CAChB,EAEJ,MAAMC,GAAY,qCAClB,IAAIC,GAAc,2DAClB,IACIA,GAAc,IAAIC,OAAO,4DAA6D,IAC1F,CACA,MAAOnJ,IAAK,CACZ,MAAMoJ,GAAgB,CAClBjB,OAAOjP,EAAItB,EAAMX,GACb,GAAIW,GAAQ,IAAiBX,GAASiC,EAAG5D,IAAM,EAC3C,OAAQ,EACZ,IAAI+T,EAAUnQ,EAAGsO,KAAKvQ,EAAQ,GAC9B,IAAK,IAAI0B,EAAI,EAAGA,EAAIsQ,GAAU9S,OAAQwC,IAClC,GAAIsQ,GAAU/Q,WAAWS,IAAM0Q,EAC3B,OAAOnQ,EAAGoQ,OAAO5Q,EAAI3B,EAAKoR,OAAQlR,EAAOA,EAAQ,IACzD,OAAQ,CACZ,EACAsS,OAAOrQ,EAAItB,EAAMX,GACb,GAAIW,GAAQ,GACR,OAAQ,EACZ,IAAIqE,EAAI,6BAA6BuN,KAAKtQ,EAAGH,MAAM9B,EAAQ,EAAGA,EAAQ,KACtE,OAAOgF,EAAI/C,EAAGoQ,OAAO5Q,EAAI3B,EAAKwS,OAAQtS,EAAOA,EAAQ,EAAIgF,EAAE,GAAG9F,UAAY,CAC9E,EACAsT,WAAWvQ,EAAItB,EAAMX,GACjB,GAAIW,GAAQ,IAAgBX,GAASiC,EAAGsO,KAAKvQ,EAAQ,IAAM,GACvD,OAAQ,EACZ,IAAIjB,EAAMiB,EAAQ,EAClB,MAAOjB,EAAMkD,EAAG5D,KAAO4D,EAAGsO,KAAKxR,IAAQ,GACnCA,IACJ,IAAIsD,EAAOtD,EAAMiB,EAAOyS,EAAU,EAClC,KAAO1T,EAAMkD,EAAG5D,IAAKU,IAAO,CACxB,GAAIkD,EAAGsO,KAAKxR,IAAQ,GAAI,CACpB0T,IACA,GAAIA,GAAWpQ,GAAQJ,EAAGsO,KAAKxR,EAAM,IAAM,GACvC,OAAOkD,EAAGoQ,OAAO5Q,EAAI3B,EAAK0S,WAAYxS,EAAOjB,EAAM,EAAG,CAClD0C,EAAI3B,EAAKgG,SAAU9F,EAAOA,EAAQqC,GAClCZ,EAAI3B,EAAKgG,SAAU/G,EAAM,EAAIsD,EAAMtD,EAAM,KAErD,KACK,CACD0T,EAAU,CACd,CACJ,CACA,OAAQ,CACZ,EACAC,QAAQzQ,EAAItB,EAAMX,GACd,GAAIW,GAAQ,IAAgBX,GAASiC,EAAG5D,IAAM,EAC1C,OAAQ,EACZ,IAAIsI,EAAQ1E,EAAGH,MAAM9B,EAAQ,EAAGiC,EAAG5D,KACnC,IAAIsU,EAAM,sIAAsIJ,KAAK5L,GACrJ,GAAIgM,EACA,OAAO1Q,EAAGoQ,OAAO5Q,EAAI3B,EAAK8S,IAAK5S,EAAOA,EAAQ,EAAI2S,EAAI,GAAGzT,SAC7D,IAAI2T,EAAU,+BAA+BN,KAAK5L,GAClD,GAAIkM,EACA,OAAO5Q,EAAGoQ,OAAO5Q,EAAI3B,EAAKgT,QAAS9S,EAAOA,EAAQ,EAAI6S,EAAQ,GAAG3T,SACrE,IAAI6T,EAAW,cAAcR,KAAK5L,GAClC,GAAIoM,EACA,OAAO9Q,EAAGoQ,OAAO5Q,EAAI3B,EAAKkT,sBAAuBhT,EAAOA,EAAQ,EAAI+S,EAAS,GAAG7T,SACpF,IAAI8F,EAAI,mKAAmKuN,KAAK5L,GAChL,IAAK3B,EACD,OAAQ,EACZ,OAAO/C,EAAGoQ,OAAO5Q,EAAI3B,EAAK4S,QAAS1S,EAAOA,EAAQ,EAAIgF,EAAE,GAAG9F,QAC/D,EACA+T,SAAShR,EAAItB,EAAMX,GACf,GAAIW,GAAQ,IAAMA,GAAQ,GACtB,OAAQ,EACZ,IAAI5B,EAAMiB,EAAQ,EAClB,MAAOiC,EAAGsO,KAAKxR,IAAQ4B,EACnB5B,IACJ,IAAIiR,EAAS/N,EAAGH,MAAM9B,EAAQ,EAAGA,GAAQ2G,EAAQ1E,EAAGH,MAAM/C,EAAKA,EAAM,GACrE,IAAImU,EAAUjB,GAAY9N,KAAK6L,GAASmD,EAASlB,GAAY9N,KAAKwC,GAClE,IAAIyM,EAAU,QAAQjP,KAAK6L,GAASqD,EAAS,QAAQlP,KAAKwC,GAC1D,IAAI2M,GAAgBD,KAAYF,GAAUC,GAAWF,GACrD,IAAIK,GAAiBH,KAAaF,GAAWG,GAAUF,GACvD,IAAIK,EAAUF,IAAiB3S,GAAQ,KAAO4S,GAAiBL,GAC/D,IAAIO,EAAWF,IAAkB5S,GAAQ,KAAO2S,GAAgBH,GAChE,OAAOlR,EAAGoQ,OAAO,IAAIP,GAAgBnR,GAAQ,GAAK8Q,EAAqBE,EAAkB3R,EAAOjB,GAAMyU,EAAU,EAAe,IAAMC,EAAW,EAAgB,IACpK,EACAC,UAAUzR,EAAItB,EAAMX,GAChB,GAAIW,GAAQ,IAAiBsB,EAAGsO,KAAKvQ,EAAQ,IAAM,GAC/C,OAAOiC,EAAGoQ,OAAO5Q,EAAI3B,EAAK4T,UAAW1T,EAAOA,EAAQ,IACxD,GAAIW,GAAQ,GAAI,CACZ,IAAI5B,EAAMiB,EAAQ,EAClB,MAAOiC,EAAGsO,KAAKxR,IAAQ,GACnBA,IACJ,GAAIkD,EAAGsO,KAAKxR,IAAQ,IAAMA,GAAOiB,EAAQ,EACrC,OAAOiC,EAAGoQ,OAAO5Q,EAAI3B,EAAK4T,UAAW1T,EAAOjB,EAAM,GAC1D,CACA,OAAQ,CACZ,EACA4U,KAAK1R,EAAItB,EAAMX,GACX,OAAOW,GAAQ,GAAesB,EAAGoQ,OAAO,IAAIP,GAAgBF,EAAW5R,EAAOA,EAAQ,EAAG,KAAkB,CAC/G,EACA4T,MAAM3R,EAAItB,EAAMX,GACZ,OAAOW,GAAQ,IAAgBsB,EAAGsO,KAAKvQ,EAAQ,IAAM,GAC/CiC,EAAGoQ,OAAO,IAAIP,GAAgBD,GAAY7R,EAAOA,EAAQ,EAAG,KAAkB,CACxF,EACA6T,QAAQ5R,EAAItB,EAAMX,GACd,GAAIW,GAAQ,GACR,OAAQ,EAEZ,IAAK,IAAIe,EAAIO,EAAG6R,MAAM5U,OAAS,EAAGwC,GAAK,EAAGA,IAAK,CAC3C,IAAIqS,EAAO9R,EAAG6R,MAAMpS,GACpB,GAAIqS,aAAgBjC,KAAoBiC,EAAK9V,MAAQ2T,GAAamC,EAAK9V,MAAQ4T,IAAa,CAGxF,IAAKkC,EAAKhC,MAAQ9P,EAAGlB,UAAUgT,EAAK1S,KAAOrB,IAAU,QAAQmE,KAAKlC,EAAGH,MAAM9B,EAAQ,EAAGA,EAAQ,IAAK,CAC/FiC,EAAG6R,MAAMpS,GAAK,KACd,OAAQ,CACZ,CAGA,IAAIzB,EAAUgC,EAAG+R,YAAYtS,GAC7B,IAAIuS,EAAOhS,EAAG6R,MAAMpS,GAAKwS,GAAWjS,EAAIhC,EAAS8T,EAAK9V,MAAQ2T,EAAY9R,EAAK6T,KAAO7T,EAAK8T,MAAOG,EAAK5V,KAAM6B,EAAQ,GAErH,GAAI+T,EAAK9V,MAAQ2T,EACb,IAAK,IAAIuC,EAAI,EAAGA,EAAIzS,EAAGyS,IAAK,CACxB,IAAIlL,EAAIhH,EAAG6R,MAAMK,GACjB,GAAIlL,aAAa6I,IAAmB7I,EAAEhL,MAAQ2T,EAC1C3I,EAAE8I,KAAO,CACjB,CACJ,OAAOkC,EAAK5S,EAChB,CACJ,CACA,OAAQ,CACZ,GAEJ,SAAS6S,GAAWjS,EAAIhC,EAAShC,EAAM+B,EAAOoU,GAC1C,IAAI,KAAE/T,GAAS4B,EAAItB,EAAOsB,EAAGsO,KAAK6D,GAAWC,EAASD,EACtDnU,EAAQqU,QAAQ7S,EAAI3B,EAAKoI,SAAUlI,EAAOA,GAAS/B,GAAQ6B,EAAK8T,MAAQ,EAAI,KAC5E3T,EAAQd,KAAKsC,EAAI3B,EAAKoI,SAAUkM,EAAW,EAAGA,IAC9C,GAAIzT,GAAQ,GAAc,CACtB,IAAI5B,EAAMkD,EAAGlB,UAAUqT,EAAW,GAClC,IAAIG,EAAOpM,GAAS9H,EAAMtB,EAAMkD,EAAG+K,OAAQ/K,EAAG+K,QAAS3E,EACvD,GAAIkM,EAAM,CACNxV,EAAMkD,EAAGlB,UAAUwT,EAAKlT,IACxBgH,EAAQC,GAAejI,EAAMtB,EAAMkD,EAAG+K,OAAQ/K,EAAG+K,QACjD,GAAI3E,EACAtJ,EAAMkD,EAAGlB,UAAUsH,EAAMhH,GACjC,CACA,GAAIY,EAAGsO,KAAKxR,IAAQ,GAAc,CAC9BkB,EAAQd,KAAKsC,EAAI3B,EAAKoI,SAAUkM,EAAUA,EAAW,IACrDC,EAAStV,EAAM,EACf,GAAIwV,EACAtU,EAAQd,KAAKoV,GACjB,GAAIlM,EACApI,EAAQd,KAAKkJ,GACjBpI,EAAQd,KAAKsC,EAAI3B,EAAKoI,SAAUnJ,EAAKsV,GACzC,CACJ,MACK,GAAI1T,GAAQ,GAAc,CAC3B,IAAI6T,EAAQvM,GAAe5H,EAAM+T,EAAWnS,EAAG+K,OAAQ/K,EAAG+K,OAAQ,OAClE,GAAIwH,EAAO,CACPvU,EAAQd,KAAKqV,GACbH,EAASG,EAAMnT,EACnB,CACJ,CACA,OAAOI,EAAIxD,EAAM+B,EAAOqU,EAAQpU,EACpC,CAIA,SAASkI,GAAS9H,EAAML,EAAOgN,GAC3B,IAAIrM,EAAON,EAAKY,WAAWjB,GAC3B,GAAIW,GAAQ,GAAc,CACtB,IAAK,IAAI5B,EAAMiB,EAAQ,EAAGjB,EAAMsB,EAAKnB,OAAQH,IAAO,CAChD,IAAIoE,EAAK9C,EAAKY,WAAWlC,GACzB,GAAIoE,GAAM,GACN,OAAO1B,EAAI3B,EAAK8S,IAAK5S,EAAQgN,EAAQjO,EAAM,EAAIiO,GACnD,GAAI7J,GAAM,IAAMA,GAAM,GAClB,OAAO,KACf,CACA,OAAO,IACX,KACK,CACD,IAAI3C,EAAQ,EAAGzB,EAAMiB,EACrB,IAAK,IAAIoS,EAAU,MAAOrT,EAAMsB,EAAKnB,OAAQH,IAAO,CAChD,IAAIoE,EAAK9C,EAAKY,WAAWlC,GACzB,GAAIgE,EAAMI,GAAK,CACX,KACJ,MACK,GAAIiP,EAAS,CACdA,EAAU,KACd,MACK,GAAIjP,GAAM,GAAc,CACzB3C,GACJ,MACK,GAAI2C,GAAM,GAAc,CACzB,IAAK3C,EACD,MACJA,GACJ,MACK,GAAI2C,GAAM,GAAe,CAC1BiP,EAAU,IACd,CACJ,CACA,OAAOrT,EAAMiB,EAAQyB,EAAI3B,EAAK8S,IAAK5S,EAAQgN,EAAQjO,EAAMiO,GAAUjO,GAAOsB,EAAKnB,OAAS,KAAO,KACnG,CACJ,CACA,SAASoJ,GAAejI,EAAML,EAAOgN,GACjC,IAAIrM,EAAON,EAAKY,WAAWjB,GAC3B,GAAIW,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,GACpC,OAAO,MACX,IAAItC,EAAMsC,GAAQ,GAAK,GAAKA,EAC5B,IAAK,IAAI5B,EAAMiB,EAAQ,EAAGoS,EAAU,MAAOrT,EAAMsB,EAAKnB,OAAQH,IAAO,CACjE,IAAIoE,EAAK9C,EAAKY,WAAWlC,GACzB,GAAIqT,EACAA,EAAU,WACT,GAAIjP,GAAM9E,EACX,OAAOoD,EAAI3B,EAAK2U,UAAWzU,EAAQgN,EAAQjO,EAAM,EAAIiO,QACpD,GAAI7J,GAAM,GACXiP,EAAU,IAClB,CACA,OAAO,IACX,CACA,SAASnK,GAAe5H,EAAML,EAAOgN,EAAQ0H,GACzC,IAAK,IAAItC,EAAU,MAAOrT,EAAMiB,EAAQ,EAAG3B,EAAMkB,KAAKoV,IAAItU,EAAKnB,OAAQH,EAAM,KAAMA,EAAMV,EAAKU,IAAO,CACjG,IAAIoE,EAAK9C,EAAKY,WAAWlC,GACzB,GAAIqT,EACAA,EAAU,WACT,GAAIjP,GAAM,GACX,OAAOuR,EAAe,MAAQjT,EAAI3B,EAAK8U,UAAW5U,EAAQgN,EAAQjO,EAAM,EAAIiO,OAC3E,CACD,GAAI0H,IAAiB3R,EAAMI,GACvBuR,EAAe,MACnB,GAAIvR,GAAM,GACN,OAAO,WACN,GAAIA,GAAM,GACXiP,EAAU,IAClB,CACJ,CACA,OAAO,IACX,CAGA,MAAM/B,GAEFrS,YAEA+I,EAEA1G,EAEA2M,GACIxO,KAAKuI,OAASA,EACdvI,KAAK6B,KAAOA,EACZ7B,KAAKwO,OAASA,EAEdxO,KAAKsV,MAAQ,EACjB,CAGAvD,KAAKxR,GAAO,OAAOA,GAAOP,KAAKH,KAAO,EAAIG,KAAK6B,KAAKY,WAAWlC,EAAMP,KAAKwO,OAAS,CAE/E3O,UAAQ,OAAOG,KAAKwO,OAASxO,KAAK6B,KAAKnB,MAAQ,CAGnD4C,MAAM3D,EAAMkD,GAAM,OAAO7C,KAAK6B,KAAKyB,MAAM3D,EAAOK,KAAKwO,OAAQ3L,EAAK7C,KAAKwO,OAAS,CAEhFqF,OAAO5Q,GACHjD,KAAKsV,MAAM3U,KAAKsC,GAChB,OAAOA,EAAIJ,EACf,CAKAwT,aAAa5W,EAAME,EAAMkD,EAAIyT,EAAMC,GAC/B,OAAOvW,KAAK6T,OAAO,IAAIP,GAAgB7T,EAAME,EAAMkD,GAAKyT,EAAO,EAAe,IAAMC,EAAQ,EAAgB,IAChH,CAEAzI,WAAW7K,GACP,OAAOjD,KAAK6T,OAAO5Q,EACvB,CAGAgP,eAAetS,GAEX,IAAK,IAAIuD,EAAIvD,EAAMuD,EAAIlD,KAAKsV,MAAM5U,OAAQwC,IAAK,CAC3C,IAAIqT,EAAQvW,KAAKsV,MAAMpS,GACvB,KAAMqT,aAAiBjD,IAAmBiD,EAAM9W,KAAKyT,SAAYqD,EAAMhD,KAAO,GAC1E,SACJ,IAAIiD,EAAMD,EAAM9W,MAAQwT,GAAsBsD,EAAM9W,MAAQ0T,EAC5D,IAAIsD,EAAYF,EAAM1T,GAAK0T,EAAM5W,KACjC,IAAI2W,EAAMX,EAAIzS,EAAI,EAElB,KAAOyS,GAAKhW,EAAMgW,IAAK,CACnB,IAAIJ,EAAOvV,KAAKsV,MAAMK,GACtB,GAAIJ,aAAgBjC,IAAoBiC,EAAKhC,KAAO,GAAiBgC,EAAK9V,MAAQ8W,EAAM9W,QAElF+W,IAASD,EAAMhD,KAAO,GAAkBgC,EAAKhC,KAAO,KACjDgC,EAAK1S,GAAK0S,EAAK5V,KAAO8W,GAAa,GAAK,KAAOlB,EAAK1S,GAAK0S,EAAK5V,MAAQ,GAAK8W,EAAY,IAAK,CACjGH,EAAOf,EACP,KACJ,CACJ,CACA,IAAKe,EACD,SACJ,IAAI7W,EAAO8W,EAAM9W,KAAKyT,QAASzR,EAAU,GACzC,IAAID,EAAQ8U,EAAK3W,KAAME,EAAM0W,EAAM1T,GAGnC,GAAI2T,EAAK,CACL,IAAI3S,EAAO9C,KAAKoV,IAAI,EAAGG,EAAKzT,GAAKyT,EAAK3W,KAAM8W,GAC5CjV,EAAQ8U,EAAKzT,GAAKgB,EAClBhE,EAAM0W,EAAM5W,KAAOkE,EACnBpE,EAAOoE,GAAQ,EAAI,WAAa,gBACpC,CAEA,GAAIyS,EAAK7W,KAAKkM,KACVlK,EAAQd,KAAKX,KAAKiD,IAAIqT,EAAK7W,KAAKkM,KAAMnK,EAAO8U,EAAKzT,KACtD,IAAK,IAAI6T,EAAIf,EAAI,EAAGe,EAAIxT,EAAGwT,IAAK,CAC5B,GAAI1W,KAAKsV,MAAMoB,aAAc3D,EACzBtR,EAAQd,KAAKX,KAAKsV,MAAMoB,IAC5B1W,KAAKsV,MAAMoB,GAAK,IACpB,CACA,GAAIH,EAAM9W,KAAKkM,KACXlK,EAAQd,KAAKX,KAAKiD,IAAIsT,EAAM9W,KAAKkM,KAAM4K,EAAM5W,KAAME,IACvD,IAAI8W,EAAU3W,KAAKiD,IAAIxD,EAAM+B,EAAO3B,EAAK4B,GAEzCzB,KAAKsV,MAAMK,GAAKa,GAAOF,EAAK3W,MAAQ6B,EAAQ,IAAI8R,GAAgBgD,EAAK7W,KAAM6W,EAAK3W,KAAM6B,EAAO8U,EAAK/C,MAAQ,KAC1G,IAAIqD,EAAO5W,KAAKsV,MAAMpS,GAAKsT,GAAOD,EAAM1T,IAAMhD,EAAM,IAAIyT,GAAgBiD,EAAM9W,KAAMI,EAAK0W,EAAM1T,GAAI0T,EAAMhD,MAAQ,KAEjH,GAAIqD,EACA5W,KAAKsV,MAAM5D,OAAOxO,EAAG,EAAGyT,QAExB3W,KAAKsV,MAAMpS,GAAKyT,CACxB,CAEA,IAAItT,EAAS,GACb,IAAK,IAAIH,EAAIvD,EAAMuD,EAAIlD,KAAKsV,MAAM5U,OAAQwC,IAAK,CAC3C,IAAIqS,EAAOvV,KAAKsV,MAAMpS,GACtB,GAAIqS,aAAgBxC,EAChB1P,EAAO1C,KAAK4U,EACpB,CACA,OAAOlS,CACX,CAIAwT,qBAAqBpX,GACjB,IAAK,IAAIyD,EAAIlD,KAAKsV,MAAM5U,OAAS,EAAGwC,GAAK,EAAGA,IAAK,CAC7C,IAAIqS,EAAOvV,KAAKsV,MAAMpS,GACtB,GAAIqS,aAAgBjC,IAAmBiC,EAAK9V,MAAQA,EAChD,OAAOyD,CACf,CACA,OAAO,IACX,CAMAsS,YAAYsB,GACR,IAAIrV,EAAUzB,KAAKiS,eAAe6E,GAClC9W,KAAKsV,MAAM5U,OAASoW,EACpB,OAAOrV,CACX,CAIAc,UAAU5C,GAAQ,OAAO4C,EAAUvC,KAAK6B,KAAMlC,EAAOK,KAAKwO,QAAUxO,KAAKwO,MAAQ,CACjFvL,IAAIxD,EAAME,EAAMkD,EAAI/C,GAChB,UAAWL,GAAQ,SACf,OAAOwD,EAAIjD,KAAKuI,OAAOqF,YAAYnO,GAAOE,EAAMkD,EAAI/C,GACxD,OAAO,IAAIwO,EAAY7O,EAAME,EACjC,EAEJ,SAASoO,GAAYgJ,EAAUrV,GAC3B,IAAKA,EAAMhB,OACP,OAAOqW,EACX,IAAKA,EAASrW,OACV,OAAOgB,EACX,IAAI0H,EAAO2N,EAASzT,QAAS0T,EAAK,EAClC,IAAK,IAAIrL,KAAQjK,EAAO,CACpB,MAAOsV,EAAK5N,EAAK1I,QAAU0I,EAAK4N,GAAInU,GAAK8I,EAAK9I,GAC1CmU,IACJ,GAAIA,EAAK5N,EAAK1I,QAAU0I,EAAK4N,GAAIrX,KAAOgM,EAAKhM,KAAM,CAC/C,IAAI+F,EAAI0D,EAAK4N,GACb,GAAItR,aAAaqN,EACb3J,EAAK4N,GAAM,IAAIjE,EAAQrN,EAAEjG,KAAMiG,EAAE/F,KAAM+F,EAAE7C,GAAIkL,GAAYrI,EAAE5F,SAAU,CAAC6L,IAC9E,KACK,CACDvC,EAAKsI,OAAOsF,IAAM,EAAGrL,EACzB,CACJ,CACA,OAAOvC,CACX,CAGA,MAAM6N,GAAU,CAAC3V,EAAK0F,UAAW1F,EAAKkD,SAAUlD,EAAKwC,YAAaxC,EAAK2C,YACvE,MAAMsH,GACF/L,YAAYqL,EAAWD,GACnB5K,KAAK6K,UAAYA,EACjB7K,KAAK4K,MAAQA,EAEb5K,KAAKkD,EAAI,EAETlD,KAAKkX,SAAW,KAChBlX,KAAKmX,aAAe,EAGpBnX,KAAKoX,OAAS,KACd,GAAIvM,EAAUnK,OACVV,KAAKkX,SAAWrM,EAAU7K,KAAKkD,IACvC,CACAmU,eACIrX,KAAKkX,SAAWlX,KAAKkD,EAAIlD,KAAK6K,UAAUnK,OAASV,KAAK6K,UAAU7K,KAAKkD,KAAO,KAC5ElD,KAAKoX,OAAS,KACdpX,KAAKmX,aAAe,CACxB,CACA7K,OAAO/L,EAAK+D,GACR,MAAOtE,KAAKkX,UAAYlX,KAAKkX,SAASrU,IAAMtC,EACxCP,KAAKqX,eACT,IAAKrX,KAAKkX,UAAYlX,KAAKkX,SAASvX,MAAQY,EAAMA,EAAM,EAAI,GACxD,OAAO,MACX,GAAIP,KAAKmX,YAAc,EAAG,CACtB,IAAItX,EAAMG,KAAKkX,SAASrU,GACxB,MAAOhD,EAAM,GAAKG,KAAK4K,MAAM0M,KAAKzX,EAAM,EAAGA,IAAQ,KAC/CA,IACJG,KAAKmX,YAActX,EAAMA,EAAM,EAAI,CACvC,CACA,IAAI0X,EAAIvX,KAAKoX,OACb,IAAKG,EAAG,CACJA,EAAIvX,KAAKoX,OAASpX,KAAKkX,SAASjW,KAAKmW,SACrCG,EAAExI,YACN,CACA,IAAIyI,EAAOjX,EAAMP,KAAKkX,SAAS1I,OAC/B,MAAO+I,EAAE1U,IAAM2U,MACND,EAAEE,SACH,OAAO,MACf,OAAS,CACL,GAAIF,EAAE5X,MAAQ6X,EACV,OAAOxX,KAAKkX,SAASvX,MAAQ2E,EACjC,IAAKiT,EAAEG,WAAWF,GACd,OAAO,KACf,CACJ,CACAjL,QAAQ3M,GACJ,IAAIqB,EAAOjB,KAAKoX,OAAOnW,KACvB,OAAOA,GAAQA,EAAKT,KAAK,EAAAN,SAAA,cAAyBN,CACtD,CACA6M,UAAUhJ,GACN,IAAIkU,EAAM3X,KAAKoX,OAAQnP,EAAMjI,KAAKkX,SAAS1I,OAAQoJ,EAAU5X,KAAKmX,aAAenX,KAAKkX,SAASW,QAAU,EAAI,GAC7G,IAAIrW,EAAQiC,EAAG2H,kBAAmBvL,EAAM2B,EAAOsW,EAASrU,EAAGE,MAAM7D,SAASY,OAC1E,IAAIqX,EAAUlY,EAAKmY,EAAQF,EAC3B,OAAS,CACL,GAAIH,EAAI9U,GAAKoF,EAAM2P,EAAS,CACxB,GAAID,EAAIlY,KAAKwY,aAAeN,EAAI5I,aAC5B,SACJ,KACJ,CACAtL,EAAGuH,WAAWkN,IAAIP,EAAI1W,MACtBwC,EAAGmD,QAAQ+Q,EAAI1W,KAAM0W,EAAIhY,KAAOsI,GAKhC,GAAI0P,EAAIlY,KAAK0Y,GAAG,SAAU,CACtB,GAAIlB,GAAQvJ,QAAQiK,EAAIlY,KAAKoQ,IAAM,EAAG,CAClChQ,EAAM8X,EAAI9U,GAAKoF,EACf6P,EAASrU,EAAGE,MAAM7D,SAASY,MAC/B,KACK,CACDb,EAAMkY,EACND,EAASE,EACTD,EAAUJ,EAAI9U,GAAKoF,EACnB+P,EAAQvU,EAAGE,MAAM7D,SAASY,MAC9B,CACJ,CACA,IAAKiX,EAAI3I,cACL,KACR,CACA,MAAOvL,EAAGE,MAAM7D,SAASY,OAASoX,EAAQ,CACtCrU,EAAGE,MAAM7D,SAAS6C,MAClBc,EAAGE,MAAM5D,UAAU4C,KACvB,CACA,OAAO9C,EAAM2B,CACjB,EAEJ,MAAM4W,IAAuB,IAAAjH,WAAU,CACnC,iBAAkB,EAAAkH,KAAA,MAClBxQ,eAAgB,EAAAwQ,KAAA,iBAChB,qCAAsC,EAAAA,KAAA,SACtC,qCAAsC,EAAAA,KAAA,SACtC,kBAAmB,EAAAA,KAAA,SACnB,kBAAmB,EAAAA,KAAA,SACnB,kBAAmB,EAAAA,KAAA,SACnB,kBAAmB,EAAAA,KAAA,SACnB,uBAAwB,EAAAA,KAAA,QACxB3F,OAAQ,EAAA2F,KAAA,OACRvE,OAAQ,EAAAuE,KAAA,UACR,eAAgB,EAAAA,KAAA,SAChB,qBAAsB,EAAAA,KAAA,OACtB,qBAAsB,EAAAA,KAAA,KACtB,iCAAkC,EAAAA,KAAA,KAClC,iBAAkB,EAAAA,KAAA,MAClB,sBAAuB,EAAAA,KAAA,UACvBjE,IAAK,EAAAiE,KAAA,IACL,yEAA0E,EAAAA,KAAA,sBAC1E,qBAAsB,EAAAA,KAAA,UACtBpC,UAAW,EAAAoC,KAAA,OACXhK,UAAW,EAAAgK,KAAA,UAGf,MAAM9P,GAAS,IAAI2G,EAAe,IAAI,EAAA+B,QAAQxB,GAAWyB,OAAOkH,IAAuB1I,OAAO4I,KAAKrS,GAAqBsS,KAAIC,GAAKvS,EAAoBuS,KAAK9I,OAAO4I,KAAKrS,GAAqBsS,KAAIC,GAAKlO,EAAkBkO,KAAK9I,OAAO4I,KAAKrS,GAAsBuE,EAAgBrG,EAAmBuL,OAAO4I,KAAK3E,IAAe4E,KAAIC,GAAK7E,GAAc6E,KAAK9I,OAAO4I,KAAK3E,IAAgB,IAEnX,SAAS8E,GAAchQ,EAAM9I,EAAMkD,GAC/B,IAAIiI,EAAS,GACb,IAAK,IAAI0N,EAAI/P,EAAKsG,WAAYxO,EAAMZ,GAAO6Y,EAAIA,EAAExJ,YAAa,CAC1D,IAAI0J,EAAUF,EAAIA,EAAE7Y,KAAOkD,EAC3B,GAAI6V,EAAUnY,EACVuK,EAAOnK,KAAK,CAAEhB,KAAMY,EAAKsC,GAAI6V,IACjC,IAAKF,EACD,MACJjY,EAAMiY,EAAE3V,EACZ,CACA,OAAOiI,CACX,CAGA,SAAS6N,GAAUzI,GACf,IAAI,WAAE0I,EAAU,WAAEC,GAAe3I,EACjC,IAAI0B,GAAO,IAAAkH,aAAW,CAACrQ,EAAMmC,KACzB,IAAIiF,EAAKpH,EAAKhJ,KAAKoQ,GACnB,GAAI+I,IAAe/I,GAAMvO,EAAK0F,WAAa6I,GAAMvO,EAAK2F,YAAa,CAC/D,IAAI8R,EAAO,GACX,GAAIlJ,GAAMvO,EAAK2F,WAAY,CACvB,IAAI+R,EAAWvQ,EAAKA,KAAKwQ,SAAS3X,EAAKiG,UACvC,GAAIyR,EACAD,EAAOnO,EAAM0M,KAAK0B,EAASrZ,KAAMqZ,EAASnW,GAClD,CACA,IAAI0F,EAASqQ,EAAWG,GACxB,GAAIxQ,EACA,MAAO,CAAEA,SAAQ2Q,QAASzQ,GAAQA,EAAKhJ,KAAKoQ,IAAMvO,EAAK0E,SAC/D,MACK,GAAI6S,IAAehJ,GAAMvO,EAAKqH,WAAakH,GAAMvO,EAAK4S,SAAU,CACjE,MAAO,CAAE3L,OAAQsQ,EAAYK,QAAST,GAAchQ,EAAKA,KAAMA,EAAK9I,KAAM8I,EAAK5F,IACnF,CACA,OAAO,IAAI,IAEf,MAAO,CAAE+O,OACb,CAEA,MAAMuH,GAAqB,CAAEjG,QAAS,gBAAiBvH,KAAM,qBAI7D,MAAMyN,GAAgB,CAClB/I,YAAa,CAAC,CACNT,KAAM,gBACNc,MAAO,CAAE,oBAAqB,EAAA2H,KAAA,gBAC/B,CACCzI,KAAM,oBACNc,MAAO,EAAA2H,KAAA,wBAEf7P,YAAa,CAAC,CACNoH,KAAM,gBACN9D,MAAMrI,EAAItB,EAAM5B,GACZ,GAAI4B,GAAQ,KAAiBsB,EAAGsO,KAAKxR,EAAM,IAAM,KAAOkD,EAAGsO,KAAKxR,EAAM,IAAM,IACxE,OAAQ,EACZ,IAAIiR,EAAS/N,EAAGH,MAAM/C,EAAM,EAAGA,GAAM4H,EAAQ1E,EAAGH,MAAM/C,EAAM,EAAGA,EAAM,GACrE,IAAIqU,EAAU,QAAQjP,KAAK6L,GAASqD,EAAS,QAAQlP,KAAKwC,GAC1D,IAAIuM,EAAUjB,GAAY9N,KAAK6L,GAASmD,EAASlB,GAAY9N,KAAKwC,GAClE,OAAO1E,EAAG4S,aAAa8C,GAAoB5Y,EAAKA,EAAM,GAAIsU,KAAYF,GAAUC,GAAWF,IAAWE,KAAaF,GAAWG,GAAUF,GAC5I,EACAxM,MAAO,cAGnB,SAASkR,GAAS5V,EAAIC,EAAM4V,EAAS,EAAGlQ,EAAMoF,EAAS,GACnD,IAAIxJ,EAAQ,EAAGwC,EAAQ,KAAM+R,GAAa,EAAGC,GAAW,EAAGC,EAAM,MACjE,IAAIC,EAAY,KACZtQ,EAAKzI,KAAK8C,EAAGR,IAAI,YAAauL,EAAS+K,EAAW/K,EAASgL,EAAS/V,EAAG8E,OAAOC,YAAY9E,EAAKJ,MAAMiW,EAAWC,GAAUhL,EAAS+K,IAAY,EAEnJ,IAAK,IAAIrW,EAAIoW,EAAQpW,EAAIQ,EAAKhD,OAAQwC,IAAK,CACvC,IAAIf,EAAOuB,EAAKjB,WAAWS,GAC3B,GAAIf,GAAQ,MAAkBsX,EAAK,CAC/B,IAAKjS,GAAS+R,GAAa,EACvBvU,IACJwC,EAAQ,MACR,GAAI4B,EAAM,CACN,GAAImQ,GAAa,EACbG,IACJtQ,EAAKzI,KAAK8C,EAAGR,IAAI,iBAAkBC,EAAIsL,EAAQtL,EAAIsL,EAAS,GAChE,CACA+K,EAAYC,GAAW,CAC3B,MACK,GAAIC,GAAOtX,GAAQ,IAAMA,GAAQ,EAAG,CACrC,GAAIoX,EAAY,EACZA,EAAYrW,EAChBsW,EAAUtW,EAAI,CAClB,CACAuW,GAAOA,GAAOtX,GAAQ,EAC1B,CACA,GAAIoX,GAAa,EAAG,CAChBvU,IACA,GAAIoE,EACAsQ,GACR,CACA,OAAO1U,CACX,CACA,SAAS2U,GAAQC,EAAKpY,GAClB,IAAK,IAAI0B,EAAI1B,EAAO0B,EAAI0W,EAAIlZ,OAAQwC,IAAK,CACrC,IAAIf,EAAOyX,EAAInX,WAAWS,GAC1B,GAAIf,GAAQ,IACR,OAAO,KACX,GAAIA,GAAQ,GACRe,GACR,CACA,OAAO,KACX,CACA,MAAM2W,GAAgB,wCACtB,MAAMC,GACFta,cAIIQ,KAAK+Z,KAAO,IAChB,CACAxT,SAAS9C,EAAIC,EAAMwF,GACf,GAAIlJ,KAAK+Z,MAAQ,KAAM,CACnB/Z,KAAK+Z,KAAO,MACZ,IAAIC,EACJ,IAAKtW,EAAKvB,MAAQ,IAAMuB,EAAKvB,MAAQ,IAAMuB,EAAKvB,MAAQ,MACpD0X,GAAclU,KAAKqU,EAAWtW,EAAK7B,KAAKyB,MAAMI,EAAKnD,MAAO,CAC1D,IAAI0Z,EAAW,GAAIC,EAAab,GAAS5V,EAAIyF,EAAKzH,QAAS,EAAGwY,EAAU/Q,EAAK1H,OAC7E,GAAI0Y,GAAcb,GAAS5V,EAAIuW,EAAUtW,EAAKnD,KAC1CP,KAAK+Z,KAAO,CAACtW,EAAGR,IAAI,cAAeiG,EAAK1H,MAAO0H,EAAK1H,MAAQ0H,EAAKzH,QAAQf,OAAQuZ,GAC7ExW,EAAGR,IAAI,iBAAkBQ,EAAGa,UAAYZ,EAAKnD,IAAKkD,EAAGa,UAAYZ,EAAK7B,KAAKnB,QACvF,CACJ,MACK,GAAIV,KAAK+Z,KAAM,CAChB,IAAItY,EAAU,GACd4X,GAAS5V,EAAIC,EAAK7B,KAAM6B,EAAKnD,IAAKkB,EAASgC,EAAGa,WAC9CtE,KAAK+Z,KAAKpZ,KAAK8C,EAAGR,IAAI,WAAYQ,EAAGa,UAAYZ,EAAKnD,IAAKkD,EAAGa,UAAYZ,EAAK7B,KAAKnB,OAAQe,GAChG,CACA,OAAO,KACX,CACAsF,OAAOtD,EAAIyF,GACP,IAAKlJ,KAAK+Z,KACN,OAAO,MACXtW,EAAG8F,eAAeL,EAAMzF,EAAGR,IAAI,QAASiG,EAAK1H,MAAO0H,EAAK1H,MAAQ0H,EAAKzH,QAAQf,OAAQV,KAAK+Z,OAC3F,OAAO,IACX,EAWJ,MAAMI,GAAQ,CACV9J,YAAa,CACT,CAAET,KAAM,QAASjM,MAAO,MACxB,CAAEiM,KAAM,cAAec,MAAO,CAAE,kBAAmB,EAAA2H,KAAA,UACnD,WACA,CAAEzI,KAAM,YAAac,MAAO,EAAA2H,KAAA,SAC5B,CAAEzI,KAAM,iBAAkBc,MAAO,EAAA2H,KAAA,wBAErC/G,WAAY,CAAC,CACL1B,KAAM,QACN1G,KAAKqB,EAAGrB,GAAQ,OAAOyQ,GAAQzQ,EAAKzH,QAAS,GAAK,IAAIqY,GAAc,IAAM,EAC1EnI,QAAQlO,EAAIC,EAAMwF,GACd,GAAIA,EAAKvH,QAAQgP,MAAKlG,GAAKA,aAAaqP,OAAiBH,GAAQjW,EAAK7B,KAAM6B,EAAK3B,SAC7E,OAAO,MACX,IAAII,EAAOsB,EAAGsJ,SAAStJ,EAAG4H,gBAAkB,GAAGxJ,KAC/C,OAAOgY,GAAclU,KAAKxD,IAASkX,GAAS5V,EAAIC,EAAK7B,KAAM6B,EAAK3B,UAAYsX,GAAS5V,EAAItB,EAAMuB,EAAK3B,QACxG,EACAyP,OAAQ,mBAGpB,MAAM4I,GACF7T,WAAa,OAAO,KAAO,CAC3BQ,OAAOtD,EAAIyF,GACPzF,EAAG8F,eAAeL,EAAMzF,EAAGR,IAAI,OAAQiG,EAAK1H,MAAO0H,EAAK1H,MAAQ0H,EAAKzH,QAAQf,OAAQ,CACjF+C,EAAGR,IAAI,aAAciG,EAAK1H,MAAO0H,EAAK1H,MAAQ,MAC3CiC,EAAG8E,OAAOC,YAAYU,EAAKzH,QAAQ6B,MAAM,GAAI4F,EAAK1H,MAAQ,MAEjE,OAAO,IACX,EAMJ,MAAM6Y,GAAW,CACbhK,YAAa,CACT,CAAET,KAAM,OAAQjM,MAAO,KAAM+M,MAAO,EAAA2H,KAAA,MACpC,CAAEzI,KAAM,aAAcc,MAAO,EAAA2H,KAAA,OAEjC/G,WAAY,CAAC,CACL1B,KAAM,WACN1G,KAAKzF,EAAIyF,GACL,MAAO,aAAavD,KAAKuD,EAAKzH,UAAYgC,EAAGqJ,aAAa8C,MAAQ,WAAa,IAAIwK,GAAa,IACpG,EACAjS,MAAO,mBAKnB,MAAMmS,GAAM,CAACH,GAAOE,GAAUjB,IAC9B,SAASmB,GAAc5V,EAAI8D,EAAMkD,GAC7B,MAAO,CAAClI,EAAItB,EAAM5B,KACd,GAAI4B,GAAQwC,GAAMlB,EAAGsO,KAAKxR,EAAM,IAAMoE,EAClC,OAAQ,EACZ,IAAIyE,EAAO,CAAC3F,EAAGR,IAAI0I,EAAMpL,EAAKA,EAAM,IACpC,IAAK,IAAI2C,EAAI3C,EAAM,EAAG2C,EAAIO,EAAG5D,IAAKqD,IAAK,CACnC,IAAIf,EAAOsB,EAAGsO,KAAK7O,GACnB,GAAIf,GAAQwC,EACR,OAAOlB,EAAGqK,WAAWrK,EAAGR,IAAIwF,EAAMlI,EAAK2C,EAAI,EAAGkG,EAAKzC,OAAOlD,EAAGR,IAAI0I,EAAMzI,EAAGA,EAAI,MAClF,GAAIf,GAAQ,GACRiH,EAAKzI,KAAK8C,EAAGR,IAAI,SAAUC,EAAGA,IAAM,IACxC,GAAIqB,EAAMpC,GACN,KACR,CACA,OAAQ,CAAC,CAEjB,CAIA,MAAMqY,GAAc,CAChBnK,YAAa,CACT,CAAET,KAAM,cAAec,MAAO,EAAA2H,KAAA,QAAa,EAAAA,KAAA,UAC3C,CAAEzI,KAAM,kBAAmBc,MAAO,EAAA2H,KAAA,wBAEtC7P,YAAa,CAAC,CACNoH,KAAM,cACN9D,MAAOyO,GAAc,GAAc,cAAe,sBAM9D,MAAME,GAAY,CACdpK,YAAa,CACT,CAAET,KAAM,YAAac,MAAO,EAAA2H,KAAA,QAAa,EAAAA,KAAA,UACzC,CAAEzI,KAAM,gBAAiBc,MAAO,EAAA2H,KAAA,wBAEpC7P,YAAa,CAAC,CACNoH,KAAM,YACN9D,MAAOyO,GAAc,IAAe,YAAa,oBAK7D,MAAMG,GAAQ,CACVrK,YAAa,CAAC,CAAET,KAAM,QAASc,MAAO,EAAA2H,KAAA,YACtC7P,YAAa,CAAC,CACNoH,KAAM,QACN9D,MAAMrI,EAAItB,EAAM5B,GACZ,IAAIoa,EACJ,GAAIxY,GAAQ,MAAkBwY,EAAQ,kBAAkB5G,KAAKtQ,EAAGH,MAAM/C,EAAM,EAAGkD,EAAG5D,OAC9E,OAAQ,EACZ,OAAO4D,EAAGqK,WAAWrK,EAAGR,IAAI,QAAS1C,EAAKA,EAAM,EAAIoa,EAAM,GAAGja,QACjE,K,gBC76DZ,MAAMka,IAAoB,IAAAC,qBAAoB,CAAEC,cAAe,CAAEnX,MAAO,CAAE2S,KAAM,UAAQC,MAAO,aAC/F,MAAMwE,GAA2B,IAAI,EAAA7a,SACrC,MAAM8a,GAA0BzS,GAAOyH,UAAU,CAC7Ca,MAAO,CACU,EAAAoK,aAAA,KAAiBxb,IAClBA,EAAK0Y,GAAG,UAAY1Y,EAAK0Y,GAAG,aAAe+C,GAAUzb,IAAS,KAAO0G,UACvE,CAAClF,EAAMka,KAAU,CAAGxb,KAAMwb,EAAMC,IAAIC,OAAOpa,EAAKtB,MAAMkD,GAAIA,GAAI5B,EAAK4B,OAEhEkY,GAAY7C,IAAIgD,IAChB,EAAAI,eAAA,IAAmB,CAC5B5W,SAAU,IAAM,OAEP,EAAA6W,iBAAA,IAAqB,CAC9B7W,SAAUkW,QAItB,SAASM,GAAUzb,GACf,IAAIkb,EAAQ,8BAA8B5G,KAAKtU,EAAKmQ,MACpD,OAAO+K,GAASA,EAAM,GAAKxU,SAC/B,CACA,SAASqV,GAAeC,EAAYC,GAChC,IAAI5a,EAAO2a,EACX,OAAS,CACL,IAAItZ,EAAOrB,EAAKkO,YAAa2M,EAC7B,IAAKxZ,IAASwZ,EAAUT,GAAU/Y,EAAK1C,QAAU,MAAQkc,GAAWD,EAChE,MACJ5a,EAAOqB,CACX,CACA,OAAOrB,EAAK+B,EAChB,CACA,MAAM+Y,GAA4B,EAAAC,YAAA,IAAe,CAACV,EAAO3Z,EAAO3B,KAC5D,IAAK,IAAI4I,GAAO,IAAAqT,YAAWX,GAAOY,aAAalc,GAAM,GAAI4I,EAAMA,EAAOA,EAAKgP,OAAQ,CAC/E,GAAIhP,EAAK9I,KAAO6B,EACZ,MACJ,IAAIma,EAAUlT,EAAKhJ,KAAKe,KAAKua,IAC7B,GAAIY,GAAW,KACX,SACJ,IAAI9M,EAAO2M,GAAe/S,EAAMkT,GAChC,GAAI9M,EAAOhP,EACP,MAAO,CAAEF,KAAME,EAAKgD,GAAIgM,EAChC,CACA,OAAO,IAAI,IAEf,SAASmN,GAAOzT,GACZ,OAAO,IAAI,EAAA0T,SAASrB,GAAMrS,EAAQ,CAACqT,IAAe,WACtD,CAIA,MAAMM,GAAkCF,GAAOhB,IAC/C,MAAMmB,GAAwBnB,GAAWhL,UAAU,CAACsK,GAAKG,GAAWD,GAAaE,KAKjF,MAAM0B,GAAgCJ,GAAOG,IAC7C,SAASE,GAAcC,EAAWC,GAC9B,OAAQxD,IACJ,GAAIA,GAAQuD,EAAW,CACnB,IAAI/K,EAAQ,KAEZwH,EAAO,MAAMhF,KAAKgF,GAAM,GACxB,UAAWuD,GAAa,WACpB/K,EAAQ+K,EAAUvD,QAElBxH,EAAQ,EAAAiL,oBAAA,kBAAsCF,EAAWvD,EAAM,MACnE,GAAIxH,aAAiB,EAAAiL,oBACjB,OAAOjL,EAAMkL,QAAUlL,EAAMkL,QAAQC,SAASnU,OAAS,EAAAoU,aAAA,kBAA+BpL,EAAMqL,aAC3F,GAAIrL,EACL,OAAOA,EAAMhJ,MACrB,CACA,OAAOgU,EAAkBA,EAAgBhU,OAAS,IAAI,CAE9D,CAEA,MAAMsU,GACFrd,YAAYiJ,EAAM9I,EAAMkD,EAAIia,EAAaC,EAAYtd,EAAMud,GACvDhd,KAAKyI,KAAOA,EACZzI,KAAKL,KAAOA,EACZK,KAAK6C,GAAKA,EACV7C,KAAK8c,YAAcA,EACnB9c,KAAK+c,WAAaA,EAClB/c,KAAKP,KAAOA,EACZO,KAAKgd,KAAOA,CAChB,CACAC,MAAMC,EAAUtU,EAAW,MACvB,IAAIvF,EAASrD,KAAK8c,aAAe9c,KAAKyI,KAAKmH,MAAQ,aAAe,IAAM,IACxE,GAAIsN,GAAY,KAAM,CAClB,MAAO7Z,EAAO3C,OAASwc,EACnB7Z,GAAU,IACd,OAAOA,CACX,KACK,CACD,IAAK,IAAIH,EAAIlD,KAAK6C,GAAK7C,KAAKL,KAAO0D,EAAO3C,OAASV,KAAK+c,WAAWrc,OAAQwC,EAAI,EAAGA,IAC9EG,GAAU,IACd,OAAOA,GAAUuF,EAAW5I,KAAK+c,WAAa,GAClD,CACJ,CACAI,OAAO/B,EAAKlD,GACR,IAAIkF,EAASpd,KAAKyI,KAAKmH,MAAQ,cAAgByN,QAASC,GAAWtd,KAAKgd,KAAM5B,GAAK,GAAKlD,GAAQ,GAChG,OAAOlY,KAAK8c,YAAcM,EAASpd,KAAKP,KAAOO,KAAK+c,UACxD,EAEJ,SAASQ,GAAW9U,EAAM2S,GACtB,IAAIzI,EAAQ,GACZ,IAAK,IAAIgF,EAAMlP,EAAMkP,GAAOA,EAAI/H,MAAQ,WAAY+H,EAAMA,EAAIF,OAAQ,CAClE,GAAIE,EAAI/H,MAAQ,YAAc+H,EAAI/H,MAAQ,cAAgB+H,EAAI/H,MAAQ,aAClE+C,EAAMhS,KAAKgX,EACnB,CACA,IAAI6F,EAAU,GACd,IAAK,IAAIta,EAAIyP,EAAMjS,OAAS,EAAGwC,GAAK,EAAGA,IAAK,CACxC,IAAIuF,EAAOkK,EAAMzP,GAAIyX,EACrB,IAAIjX,EAAO0X,EAAIC,OAAO5S,EAAK9I,MAAOiW,EAAWnN,EAAK9I,KAAO+D,EAAK/D,KAC9D,GAAI8I,EAAKmH,MAAQ,aAAc,CAC3B4N,EAAQ7c,KAAK,IAAIkc,GAAQpU,EAAMmN,EAAUA,EAAU,GAAI,GAAI,GAAI,MACnE,MACK,GAAInN,EAAKmH,MAAQ,eAAiB+K,EAAQ,eAAe5G,KAAKrQ,EAAK7B,KAAKyB,MAAMsS,KAAa,CAC5F4H,EAAQ7c,KAAK,IAAIkc,GAAQpU,EAAMmN,EAAUA,EAAW+E,EAAM,GAAGja,OAAQ,GAAIia,EAAM,GAAI,IAAK,MAC5F,MACK,GAAIlS,EAAKmH,MAAQ,YAAcnH,EAAKgP,OAAO7H,MAAQ,gBACnD+K,EAAQ,6BAA6B5G,KAAKrQ,EAAK7B,KAAKyB,MAAMsS,KAAa,CACxE,IAAIzN,EAAQwS,EAAM,GAAIxT,EAAMwT,EAAM,GAAGja,OACrC,GAAIyH,EAAMzH,QAAU,EAAG,CACnByH,EAAQA,EAAM7E,MAAM,EAAG6E,EAAMzH,OAAS,GACtCyG,GAAO,CACX,CACAqW,EAAQ7c,KAAK,IAAIkc,GAAQpU,EAAKgP,OAAQ7B,EAAUA,EAAWzO,EAAKwT,EAAM,GAAIxS,EAAOwS,EAAM,GAAIlS,GAC/F,MACK,GAAIA,EAAKmH,MAAQ,YAAcnH,EAAKgP,OAAO7H,MAAQ,eACnD+K,EAAQ,iDAAiD5G,KAAKrQ,EAAK7B,KAAKyB,MAAMsS,KAAa,CAC5F,IAAIzN,EAAQwS,EAAM,GAAIxT,EAAMwT,EAAM,GAAGja,OACrC,GAAIyH,EAAMzH,OAAS,EAAG,CAClByH,EAAQA,EAAM7E,MAAM,EAAG6E,EAAMzH,OAAS,GACtCyG,GAAO,CACX,CACA,IAAI1H,EAAOkb,EAAM,GACjB,GAAIA,EAAM,GACNlb,GAAQkb,EAAM,GAAG8C,QAAQ,OAAQ,KACrCD,EAAQ7c,KAAK,IAAIkc,GAAQpU,EAAKgP,OAAQ7B,EAAUA,EAAWzO,EAAKwT,EAAM,GAAIxS,EAAO1I,EAAMgJ,GAC3F,CACJ,CACA,OAAO+U,CACX,CACA,SAASF,GAAWN,EAAM5B,GACtB,MAAO,sBAAsBrH,KAAKqH,EAAIsC,YAAYV,EAAKrd,KAAMqd,EAAKrd,KAAO,IAC7E,CACA,SAASge,GAAaxV,EAAOiT,EAAKwC,EAASpP,EAAS,GAChD,IAAK,IAAIqP,GAAQ,EAAGpV,EAAON,IAAS,CAChC,GAAIM,EAAKmH,MAAQ,WAAY,CACzB,IAAIpJ,EAAI8W,GAAW7U,EAAM2S,GACzB,IAAIgC,GAAU5W,EAAE,GAChB,GAAIqX,GAAQ,EAAG,CACX,GAAIT,GAAUS,EAAO,EACjB,OACJD,EAAQjd,KAAK,CAAEhB,KAAM8I,EAAK9I,KAAO6G,EAAE,GAAG9F,OAAQmC,GAAI4F,EAAK9I,KAAO6G,EAAE,GAAG9F,OAAQod,OAAQT,OAAOQ,EAAO,EAAIrP,IACzG,CACAqP,EAAOT,CACX,CACA,IAAIjb,EAAOsG,EAAKuG,YAChB,IAAK7M,EACD,MACJsG,EAAOtG,CACX,CACJ,CAYA,MAAM4b,GAA8B,EAAG5C,QAAO6C,eAC1C,IAAI/c,GAAO,IAAA6a,YAAWX,IAAQ,IAAEC,GAAQD,EACxC,IAAI1M,EAAO,KAAMmP,EAAUzC,EAAM8C,eAAcC,IAC3C,IAAKA,EAAMC,QAAU/B,GAAiBgC,WAAWjD,EAAO+C,EAAMve,MAC1D,OAAO8O,EAAO,CAAEyP,SACpB,IAAI3d,EAAM2d,EAAMve,KAAM+D,EAAO0X,EAAIC,OAAO9a,GACxC,IAAIid,EAAUD,GAAWtc,EAAK8a,aAAaxb,GAAM,GAAI6a,GACrD,MAAOoC,EAAQ9c,QAAU8c,EAAQA,EAAQ9c,OAAS,GAAGf,KAAOY,EAAMmD,EAAK/D,KACnE6d,EAAQ7a,MACZ,IAAK6a,EAAQ9c,OACT,OAAO+N,EAAO,CAAEyP,SACpB,IAAI1L,EAAQgL,EAAQA,EAAQ9c,OAAS,GACrC,GAAI8R,EAAM3P,GAAK2P,EAAMuK,WAAWrc,OAASH,EAAMmD,EAAK/D,KAChD,OAAO8O,EAAO,CAAEyP,SACpB,IAAIG,EAAY9d,GAAQiS,EAAM3P,GAAK2P,EAAMuK,WAAWrc,SAAY,KAAKiF,KAAKjC,EAAK7B,KAAKyB,MAAMkP,EAAM3P,KAEhG,GAAI2P,EAAMwK,MAAQqB,EAAW,CAEzB,GAAI7L,EAAM/J,KAAKsG,WAAWlM,IAAMtC,GAC5BmD,EAAK/D,KAAO,IAAM,SAASgG,KAAKyV,EAAIC,OAAO3X,EAAK/D,KAAO,GAAGkC,MAAO,CACjE,IAAIM,EAAOqb,EAAQ9c,OAAS,EAAI8c,EAAQA,EAAQ9c,OAAS,GAAK,KAC9D,IAAI4d,EAAOR,EAAS,GACpB,GAAI3b,GAAQA,EAAK6a,KAAM,CACnBsB,EAAQ5a,EAAK/D,KAAOwC,EAAKxC,KACzBme,EAAS3b,EAAKgb,OAAO/B,EAAK,EAC9B,KACK,CACDkD,EAAQ5a,EAAK/D,MAAQwC,EAAOA,EAAKU,GAAK,EAC1C,CACA,IAAI+a,EAAU,CAAC,CAAEje,KAAM2e,EAAOzb,GAAItC,EAAKud,WACvC,GAAItL,EAAM/J,KAAKmH,MAAQ,cACnB+N,GAAanL,EAAMwK,KAAM5B,EAAKwC,GAAU,GAC5C,GAAIzb,GAAQA,EAAKsG,KAAKmH,MAAQ,cAC1B+N,GAAaxb,EAAK6a,KAAM5B,EAAKwC,GACjC,MAAO,CAAEM,MAAO,EAAAK,gBAAA,OAAuBD,EAAQR,EAAOpd,QAASkd,UACnE,KACK,CACD,IAAIE,EAAS,GACb,IAAK,IAAI5a,EAAI,EAAGwC,EAAI8X,EAAQ9c,OAAS,EAAGwC,GAAKwC,EAAGxC,IAAK,CACjD4a,GAAUN,EAAQta,GAAG+Z,MAAM/Z,EAAIwC,EAAI8X,EAAQta,EAAI,GAAGvD,KAAOme,EAAOpd,OAAS,KAAMwC,EAAIwC,EACvF,CACAoY,GAAU3C,EAAMqD,UAChB,MAAO,CAAEN,MAAO,EAAAK,gBAAA,OAAuBhe,EAAMud,EAAOpd,QAASkd,QAAS,CAAEje,KAAM+D,EAAK/D,KAAMme,UAC7F,CACJ,CACA,GAAItL,EAAM/J,KAAKmH,MAAQ,cAAgByO,GAAa3a,EAAK/D,KAAM,CAC3D,IAAI8e,EAAWrD,EAAIC,OAAO3X,EAAK/D,KAAO,GAAI+e,EAAS,QAAQ3K,KAAK0K,EAAS5c,MAEzE,GAAI6c,GAAUA,EAAOC,OAASnM,EAAM7S,KAAM,CACtC,IAAIie,EAAUzC,EAAMyC,QAAQ,CAAC,CAAEje,KAAM8e,EAAS9e,KAAO+e,EAAOC,MAAO9b,GAAI4b,EAAS5b,IAC5E,CAAElD,KAAM+D,EAAK/D,KAAO6S,EAAM7S,KAAMkD,GAAIa,EAAKb,MAC7C,MAAO,CAAEqb,MAAOA,EAAM3F,IAAIqF,GAAUA,UACxC,CACJ,CACA,IAAIA,EAAU,GACd,GAAIpL,EAAM/J,KAAKmH,MAAQ,cACnB+N,GAAanL,EAAMwK,KAAM5B,EAAKwC,GAClC,IAAIgB,EAAYpM,EAAMwK,MAAQxK,EAAMwK,KAAKrd,KAAO+D,EAAK/D,KACrD,IAAIme,EAAS,GAEb,IAAKc,GAAa,kBAAkB7K,KAAKrQ,EAAK7B,MAAM,GAAGnB,QAAU8R,EAAM3P,GAAI,CACvE,IAAK,IAAIK,EAAI,EAAGwC,EAAI8X,EAAQ9c,OAAS,EAAGwC,GAAKwC,EAAGxC,IAAK,CACjD4a,GAAU5a,GAAKwC,IAAMkZ,EAAYpB,EAAQta,GAAGia,OAAO/B,EAAK,GAClDoC,EAAQta,GAAG+Z,MAAM/Z,EAAIwC,EAAI8X,EAAQta,EAAI,GAAGvD,KAAOme,EAAOpd,OAAS,KACzE,CACJ,CACA,IAAIf,EAAOY,EACX,MAAOZ,EAAO+D,EAAK/D,MAAQ,KAAKgG,KAAKjC,EAAK7B,KAAKgd,OAAOlf,EAAO+D,EAAK/D,KAAO,IACrEA,IACJme,EAAS3C,EAAMqD,UAAYV,EAC3BF,EAAQjd,KAAK,CAAEhB,OAAMkD,GAAItC,EAAKud,WAC9B,MAAO,CAAEI,MAAO,EAAAK,gBAAA,OAAuB5e,EAAOme,EAAOpd,QAASkd,UAAS,IAE3E,GAAInP,EACA,OAAO,MACXuP,EAAS7C,EAAM2D,OAAOlB,EAAS,CAAEmB,eAAgB,KAAMC,UAAW,WAClE,OAAO,IAAI,EAEf,SAASC,GAAOxW,GACZ,OAAOA,EAAKmH,MAAQ,aAAenH,EAAKmH,MAAQ,UACpD,CACA,SAASsP,GAAqBje,EAAMV,GAChC,IAAIkI,EAAOxH,EAAK8a,aAAaxb,GAAM,GAAI4e,EAAO5e,EAC9C,GAAI0e,GAAOxW,GAAO,CACd0W,EAAO1W,EAAK9I,KACZ8I,EAAOA,EAAKgP,MAChB,CACA,IAAK,IAAIoG,EAAMA,EAAOpV,EAAK2W,YAAYD,IAAQ,CAC3C,GAAIF,GAAOpB,GAAO,CACdsB,EAAOtB,EAAKle,IAChB,MACK,GAAIke,EAAKjO,MAAQ,eAAiBiO,EAAKjO,MAAQ,aAAc,CAC9DnH,EAAOoV,EAAKwB,UACZF,EAAO1W,EAAK5F,EAChB,KACK,CACD,KACJ,CACJ,CACA,OAAO4F,CACX,CAYA,MAAM6W,GAAuB,EAAGnE,QAAO6C,eACnC,IAAI/c,GAAO,IAAA6a,YAAWX,GACtB,IAAI1M,EAAO,KAAMmP,EAAUzC,EAAM8C,eAAcC,IAC3C,IAAI3d,EAAM2d,EAAMve,MAAM,IAAEyb,GAAQD,EAChC,GAAI+C,EAAMC,OAAS/B,GAAiBgC,WAAWjD,EAAO+C,EAAMve,MAAO,CAC/D,IAAI+D,EAAO0X,EAAIC,OAAO9a,GACtB,IAAIid,EAAUD,GAAW2B,GAAqBje,EAAMV,GAAM6a,GAC1D,GAAIoC,EAAQ9c,OAAQ,CAChB,IAAI8R,EAAQgL,EAAQA,EAAQ9c,OAAS,GACrC,IAAI6e,EAAW/M,EAAM3P,GAAK2P,EAAMuK,WAAWrc,QAAU8R,EAAMuK,WAAa,EAAI,GAE5E,GAAIxc,EAAMmD,EAAK/D,KAAO4f,IAAa,KAAK5Z,KAAKjC,EAAK7B,KAAKyB,MAAMic,EAAUhf,EAAMmD,EAAK/D,OAC9E,MAAO,CAAEue,MAAO,EAAAK,gBAAA,OAAuB7a,EAAK/D,KAAO4f,GAC/C3B,QAAS,CAAEje,KAAM+D,EAAK/D,KAAO4f,EAAU1c,GAAItC,IACnD,GAAIA,EAAMmD,EAAK/D,MAAQ4f,KAIjB/M,EAAMwK,MAAQtZ,EAAK/D,MAAQ6S,EAAMwK,KAAKrd,OAAS,KAAKgG,KAAKjC,EAAK7B,KAAKyB,MAAM,EAAGkP,EAAM3P,MAAO,CAC3F,IAAIrB,EAAQkC,EAAK/D,KAAO6S,EAAM7S,KAE9B,GAAI6S,EAAMwK,MAAQxK,EAAM/J,KAAK9I,KAAO6S,EAAMwK,KAAKrd,MAAQ,KAAKgG,KAAKjC,EAAK7B,KAAKyB,MAAMkP,EAAM7S,KAAM6S,EAAM3P,KAC/F,MAAO,CAAEqb,QAAON,QAAS,CAAEje,KAAM6B,EAAOqB,GAAIa,EAAK/D,KAAO6S,EAAM3P,GAAIib,OAAQtL,EAAMyK,MAAMzK,EAAM3P,GAAK2P,EAAM7S,QAE3G,GAAI6B,EAAQjB,EACR,MAAO,CAAE2d,MAAO,EAAAK,gBAAA,OAAuB/c,GAAQoc,QAAS,CAAEje,KAAM6B,EAAOqB,GAAItC,GACnF,CACJ,CACJ,CACA,OAAOkO,EAAO,CAAEyP,QAAO,IAE3B,GAAIzP,EACA,OAAO,MACXuP,EAAS7C,EAAM2D,OAAOlB,EAAS,CAAEmB,eAAgB,KAAMC,UAAW,YAClE,OAAO,IAAI,EASf,MAAMQ,GAAiB,CACnB,CAAEC,IAAK,QAASC,IAAK3B,IACrB,CAAE0B,IAAK,YAAaC,IAAKJ,KAE7B,MAAMK,IAA2B,KAAAC,MAAK,CAAEC,iBAAkB,QAI1D,SAASC,GAAS5P,EAAS,CAAC,GACxB,IAAI,cAAE6P,EAAa,oBAAEC,EAAmB,UAAEC,EAAY,KAAM5Z,MAAM,OAAEkC,GAAW2T,IAAuBhM,EACtG,KAAM3H,aAAkB2G,GACpB,MAAM,IAAI7C,WAAW,kEACzB,IAAI6T,EAAahQ,EAAOgQ,WAAa,CAAChQ,EAAOgQ,YAAc,GAC3D,IAAIzD,EAAU,CAACkD,GAAYlD,SAAU0D,EACrC,GAAIH,aAA+B,EAAAI,gBAAiB,CAChD3D,EAAQ9b,KAAKqf,EAAoBvD,SACjC0D,EAAcH,EAAoBtD,QACtC,MACK,GAAIsD,EAAqB,CAC1BG,EAAcH,CAClB,CACA,IAAIpH,EAAamH,GAAiBI,EAAc9D,GAAc0D,EAAeI,GAAeha,UAC5F+Z,EAAWvf,KAAKgY,GAAU,CAAEC,aAAYC,WAAY8G,GAAYjD,SAASnU,UACzE,GAAI0X,EACAxD,EAAQ9b,KAAK,EAAA0f,KAAA,KAAU,EAAAC,OAAA,GAAUd,MACrC,OAAO,IAAI,EAAAY,gBAAgBpE,GAAOzT,EAAOyH,UAAUkQ,IAAczD,EACrE,C","sources":["webpack://@jupyterlab/application-top/./node_modules/@lezer/markdown/dist/index.js","webpack://@jupyterlab/application-top/./node_modules/@codemirror/lang-markdown/dist/index.js"],"sourcesContent":["import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\n\nclass CompositeBlock {\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        let tree = new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n        return tree;\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"URL\"] = 33] = \"URL\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n})(Type || (Type = {}));\n/// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\nclass LeafBlock {\n    /// @internal\n    constructor(\n    /// The start position of the block.\n    start, \n    /// The block's text content.\n    content) {\n        this.start = start;\n        this.content = content;\n        /// @internal\n        this.marks = [];\n        /// The block parsers active for this block.\n        this.parsers = [];\n    }\n}\n/// Data structure used during block-level per-line parsing.\nclass Line {\n    constructor() {\n        /// The line's full text.\n        this.text = \"\";\n        /// The base indent provided by the composite contexts (that have\n        /// been handled so far).\n        this.baseIndent = 0;\n        /// The string position corresponding to the base indent.\n        this.basePos = 0;\n        /// The number of contexts handled @internal\n        this.depth = 0;\n        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        this.markers = [];\n        /// The position of the next non-whitespace character beyond any\n        /// list, blockquote, or other composite block markers.\n        this.pos = 0;\n        /// The column of the next non-whitespace character.\n        this.indent = 0;\n        /// The character code of the character after `pos`.\n        this.next = -1;\n    }\n    /// @internal\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /// @internal\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /// Skip whitespace after the given position, return the position of\n    /// the next non-space character or the end of the line if there's\n    /// only space after `from`.\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /// @internal\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /// Move the line's base position forward to the given position.\n    /// This should only be called by composite [block\n    /// parsers](#BlockParser.parse) or [markup skipping\n    /// functions](#NodeSpec.composite).\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /// Move the line's base position forward to the given _column_.\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /// Store a composite-block-level marker. Should be called from\n    /// [markup skipping functions](#NodeSpec.composite) when they\n    /// consume any non-whitespace characters.\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /// Find the column position at `to`, optionally starting at a given\n    /// position and column.\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /// Find the position corresponding to the given column.\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /// @internal\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* Link */ || this.stage == 3 /* Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/// Block-level parsing functions get access to this context object.\nclass BlockContext {\n    /// @internal\n    constructor(\n    /// The parser configuration used.\n    parser, \n    /// @internal\n    input, fragments, \n    /// @internal\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /// @internal\n        this.dontInject = new Set;\n        this.stoppedAt = null;\n        /// The range index that absoluteLineStart points into @internal\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            while (line.depth < this.stack.length)\n                this.finishContext();\n            for (let mark of line.markers)\n                this.addNode(mark.type, mark.from, mark.to);\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        let withoutGaps = taken, end = this.absoluteLineStart + taken;\n        for (let i = 1; i < this.ranges.length; i++) {\n            let gapFrom = this.ranges[i - 1].to, gapTo = this.ranges[i].from;\n            if (gapFrom >= this.lineStart && gapTo < end)\n                withoutGaps -= gapTo - gapFrom;\n        }\n        this.lineStart += withoutGaps;\n        this.absoluteLineStart += taken;\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /// The number of parent blocks surrounding the current block.\n    get depth() {\n        return this.stack.length;\n    }\n    /// Get the type of the parent block at the given depth. When no\n    /// depth is passed, return the type of the innermost parent.\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /// Move to the next input line. This should only be called by\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\n    /// the line directly, or leaf block parser\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    /// consume the current line (and return true).\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n            this.rangeI++;\n            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n        }\n    }\n    /// @internal\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(start);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /// @internal\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /// The end position of the previous line.\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /// @internal\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /// Start a composite block. Should only be called from [block\n    /// parser functions](#BlockParser.parse) that return null.\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /// @internal\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /// Add a block element. Can be called by [block\n    /// parsers](#BlockParser.parse).\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\n    /// makes sure any extra composite block markup (such as blockquote\n    /// markers) inside the block are also added to the syntax tree.\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /// @internal\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.dontInject) : tree;\n    }\n    /// @internal\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /// @internal\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dont) {\n    if (dont.has(tree.tree))\n        return tree.tree;\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node;\n        if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dont);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/// A Markdown parser configuration.\nclass MarkdownParser extends Parser {\n    /// @internal\n    constructor(\n    /// The parser's syntax [node\n    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    nodeSet, \n    /// @internal\n    blockParsers, \n    /// @internal\n    leafBlockParsers, \n    /// @internal\n    blockNames, \n    /// @internal\n    endLeafBlock, \n    /// @internal\n    skipContextMarkup, \n    /// @internal\n    inlineParsers, \n    /// @internal\n    inlineNames, \n    /// @internal\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /// @internal\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Reconfigure the parser.\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend(styleTags(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /// @internal\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /// Parse the given piece of inline text at the given offset,\n    /// returning an array of [`Element`](#Element) objects representing\n    /// the inline content.\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]]\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/// Elements are used to compose syntax nodes during parsing.\nclass Element {\n    /// @internal\n    constructor(\n    /// The node's\n    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    type, \n    /// The start of the node, as an offset from the start of the document.\n    from, \n    /// The end of the node.\n    to, \n    /// The node's child nodes @internal\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /// @internal\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /// @internal\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url)\n            return cx.append(elt(Type.URL, start, start + 1 + url[0].length));\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Open */ : 0) | (canClose ? 2 /* Close */ : 0)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n            if (title)\n                pos = cx.skipSpace(title.to);\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\nclass InlineContext {\n    /// @internal\n    constructor(\n    /// The parser that is being used.\n    parser, \n    /// The text of this inline section.\n    text, \n    /// The starting offset of the section in the document.\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /// @internal\n        this.parts = [];\n    }\n    /// Get the character code at the given (document-relative)\n    /// position.\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /// The position of the end of this inline section.\n    get end() { return this.offset + this.text.length; }\n    /// Get a substring of this inline section. Again uses\n    /// document-relative positions.\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /// @internal\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\n    /// and `close` indicate whether this delimiter is opening, closing,\n    /// or both. Returns the end of the delimiter, for convenient\n    /// returning from [parse functions](#InlineParser.parse).\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Open */ : 0) | (close ? 2 /* Close */ : 0)));\n    }\n    /// Add an inline element. Returns the end of the element.\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /// Resolve markers between this.parts.length and from, wrapping matched markers in the\n    /// appropriate node and updating the content of this.parts. @internal\n    resolveMarkers(from) {\n        // Scan forward, looking for closing tokens\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            // Continue scanning for a matching opening token\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (part instanceof InlineDelimiter && (part.side & 1 /* Open */) && part.type == close.type &&\n                    // Ignore emphasis delimiters where the character count doesn't match\n                    !(emp && ((close.side & 1 /* Open */) || (part.side & 2 /* Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {\n                    open = part;\n                    break;\n                }\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            // Emphasis marker effect depends on the character count. Size consumed is minimum of the two\n            // markers.\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            // Move the covered region into content, optionally adding marker nodes\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            // If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            // Insert the new element in this.parts\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        // Collect the elements remaining in this.parts into an array.\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /// Find an opening delimiter of the given type. Returns `null` if\n    /// no delimiter is found, or an index that can be passed to\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /// Remove all inline elements and delimiters starting from the\n    /// given index (which you should get from\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    /// resolve delimiters inside of them, and return them as an array\n    /// of elements.\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /// Skip space after the given (document) position, returning either\n    /// the position of the next non-space character or the end of the\n    /// section.\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            cx.dontInject.add(cur.tree);\n            cx.addNode(cur.tree, cur.from - off);\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\nconst markdownHighlighting = styleTags({\n    \"Blockquote/...\": tags.quote,\n    HorizontalRule: tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n    \"ATXHeading3/...\": tags.heading3,\n    \"ATXHeading4/...\": tags.heading4,\n    \"ATXHeading5/...\": tags.heading5,\n    \"ATXHeading6/...\": tags.heading6,\n    \"Comment CommentBlock\": tags.comment,\n    Escape: tags.escape,\n    Entity: tags.character,\n    \"Emphasis/...\": tags.emphasis,\n    \"StrongEmphasis/...\": tags.strong,\n    \"Link/... Image/...\": tags.link,\n    \"OrderedList/... BulletList/...\": tags.list,\n    \"BlockQuote/...\": tags.quote,\n    \"InlineCode CodeText\": tags.monospace,\n    URL: tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n    \"CodeInfo LinkLabel\": tags.labelName,\n    LinkTitle: tags.string,\n    Paragraph: tags.content\n});\n/// The default CommonMark parser.\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)\n                    return -1;\n                let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);\n                let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n                let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));\n            },\n            after: \"Emphasis\"\n        }]\n};\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: tags.content },\n        { name: \"TableDelimiter\", style: tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: tags.list },\n        { name: \"TaskMarker\", style: tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\n/// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList) and [`Strikethrough`](#Strikethrough).\nconst GFM = [Table, TaskList, Strikethrough];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: tags.special(tags.content) },\n        { name: \"SuperscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: tags.special(tags.content) },\n        { name: \"SubscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n","import { EditorSelection, Prec } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, foldService, syntaxTree, Language, LanguageDescription, ParseContext, LanguageSupport } from '@codemirror/language';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html } from '@codemirror/lang-html';\nimport { NodeProp } from '@lezer/common';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"<!--\", close: \"-->\" } } });\nconst headingProp = /*@__PURE__*/new NodeProp();\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/foldNodeProp.add(type => {\n            return !type.is(\"Block\") || type.is(\"Document\") || isHeading(type) != null ? undefined\n                : (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/headingProp.add(isHeading),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction isHeading(type) {\n    let match = /^(?:ATX|Setext)Heading(\\d)$/.exec(type.name);\n    return match ? +match[1] : undefined;\n}\nfunction findSectionEnd(headerNode, level) {\n    let last = headerNode;\n    for (;;) {\n        let next = last.nextSibling, heading;\n        if (!next || (heading = isHeading(next.type)) != null && heading <= level)\n            break;\n        last = next;\n    }\n    return last.to;\n}\nconst headerIndent = /*@__PURE__*/foldService.of((state, start, end) => {\n    for (let node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {\n        if (node.from < start)\n            break;\n        let heading = node.type.prop(headingProp);\n        if (heading == null)\n            continue;\n        let upto = findSectionEnd(node, heading);\n        if (upto > end)\n            return { from: end, to: upto };\n    }\n    return null;\n});\nfunction mkLang(parser) {\n    return new Language(data, parser, [headerIndent], \"markdown\");\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        if (info && languages) {\n            let found = null;\n            // Strip anything after whitespace\n            info = /\\S*/.exec(info)[0];\n            if (typeof languages == \"function\")\n                found = languages(info);\n            else\n                found = LanguageDescription.matchLanguageName(languages, info, true);\n            if (found instanceof LanguageDescription)\n                return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());\n            else if (found)\n                return found.parser;\n        }\n        return defaultLanguage ? defaultLanguage.parser : null;\n    };\n}\n\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(maxWidth, trailing = true) {\n        let result = this.spaceBefore + (this.node.name == \"Blockquote\" ? \">\" : \"\");\n        if (maxWidth != null) {\n            while (result.length < maxWidth)\n                result += \" \";\n            return result;\n        }\n        else {\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n            return result + (trailing ? this.spaceAfter : \"\");\n        }\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, doc) {\n    let nodes = [];\n    for (let cur = node; cur && cur.name != \"Document\"; cur = cur.parent) {\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\" || cur.name == \"FencedCode\")\n            nodes.push(cur);\n    }\n    let context = [];\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match;\n        let line = doc.lineAt(node.from), startPos = node.from - line.from;\n        if (node.name == \"FencedCode\") {\n            context.push(new Context(node, startPos, startPos, \"\", \"\", \"\", null));\n        }\n        else if (node.name == \"Blockquote\" && (match = /^[ \\t]*>( ?)/.exec(line.text.slice(startPos)))) {\n            context.push(new Context(node, startPos, startPos + match[0].length, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^([ \\t]*)\\d+([.)])([ \\t]*)/.exec(line.text.slice(startPos)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^([ \\t]*)([-+*])([ \\t]{1,4}\\[[ xX]\\])?([ \\t]+)/.exec(line.text.slice(startPos)))) {\n            let after = match[4], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            let type = match[2];\n            if (match[3])\n                type += match[3].replace(/[xX]/, ' ');\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            // First list item or blank line before: delete a level of markup\n            if (inner.node.firstChild.to >= pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move this line down\n                let insert = \"\";\n                for (let i = 0, e = context.length - 2; i <= e; i++) {\n                    insert += context[i].blank(i < e ? context[i + 1].from - insert.length : null, i < e);\n                }\n                insert += state.lineBreak;\n                return { range: EditorSelection.cursor(pos + insert.length), changes: { from: line.from, insert } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let continued = inner.item && inner.item.from < line.from;\n        let insert = \"\";\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++) {\n                insert += i == e && !continued ? context[i].marker(doc, 1)\n                    : context[i].blank(i < e ? context[i + 1].from - insert.length : null);\n            }\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        insert = state.lineBreak + insert;\n        changes.push({ from, to: pos, insert });\n        return { range: EditorSelection.cursor(from + insert.length), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd &&\n                    // Only apply this if we're on the line that has the\n                    // construct's syntax, or there's only indentation in the\n                    // target range\n                    (!inner.item || line.from <= inner.item.from || !/\\S/.test(line.text.slice(0, inner.to)))) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to)))\n                        return { range, changes: { from: start, to: line.from + inner.to, insert: inner.blank(inner.to - inner.from) } };\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlNoMatch.support], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    return new LanguageSupport(mkLang(parser.configure(extensions)), support);\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n"],"names":["CompositeBlock","constructor","type","value","from","hash","end","children","positions","this","hashProp","NodeProp","static","parentHash","addChild","child","pos","prop","Tree","length","push","toTree","nodeSet","last","Math","max","tree","types","balance","makeTree","NodeType","Type","LeafBlock","start","content","marks","parsers","Line","text","baseIndent","basePos","depth","markers","indent","next","forward","forwardInner","newPos","skipSpace","countIndent","charCodeAt","reset","pop","moveBase","to","moveBaseColumn","findColumn","addMarker","elt","i","goal","scrub","result","slice","skipForList","bl","cx","line","block","stack","size","OrderedList","isOrderedList","isBulletList","BulletList","isHorizontalRule","DefaultSkipMarkup","Blockquote","QuoteMark","lineStart","space","ListItem","_cx","Document","ch","skipSpaceBack","isFencedCode","isBlockquote","breaking","count","isSetextUnderline","inList","isAtxHeading","EmptyLine","CommentEnd","ProcessingEnd","HTMLBlockStyle","isHTMLBlock","rest","e","test","getListIndent","indentAfter","indented","addCodeText","CodeText","DefaultBlockParsers","LinkReference","undefined","IndentedCode","base","pendingMarks","nextLine","m","codeStart","filter","concat","addNode","buffer","writeElements","finish","CodeBlock","FencedCode","fenceEnd","len","infoFrom","infoTo","CodeMark","CodeInfo","first","textStart","textEnd","prevLineEnd","startContext","HorizontalRule","newBase","ListMark","ATXHeading","off","endOfSpace","after","buf","write","HeaderMark","parser","parseInline","node","ATXHeading1","HTMLBlock","trailing","nodeType","CommentBlock","ProcessingInstructionBlock","SetextHeading","LinkReferenceParser","leaf","stage","elts","advance","complete","addLeafElement","nextStage","parseLinkLabel","LinkMark","parseURL","skip","title","parseLinkTitle","titleEnd","lineEnd","SetextHeadingParser","underline","underlineMark","SetextHeading1","SetextHeading2","DefaultLeafBlocks","_","DefaultEndLeaf","p","scanLineResult","BlockContext","input","fragments","ranges","atEnd","dontInject","Set","stoppedAt","rangeI","absoluteLineStart","absoluteLineEnd","create","FragmentCursor","readLine","parsedPos","finishContext","mark","reuseFragment","blockParsers","parse","leafBlockParsers","lines","stop","endLeafBlock","finishLeaf","stopAt","RangeError","moveTo","matches","taken","takeNodes","withoutGaps","gapFrom","gapTo","moveRangeI","parentType","scanLine","r","lineChunkAt","textOffset","nextFrom","handler","skipContextMarkup","Error","chunk","lineChunks","eol","indexOf","startComposite","getNodeType","none","addElement","injectMarks","top","addGaps","injectGaps","topNode","inline","Paragraph","TreeElement","Buffer","offset","dont","has","rangeEnd","movePastNext","upto","inclusive","firstChild","nextSibling","propValues","MarkdownParser","Parser","blockNames","inlineParsers","inlineNames","wrappers","super","nodeTypes","Object","t","name","id","createParse","w","configure","spec","config","resolveConfig","nonEmpty","defineNodes","assign","styles","s","composite","style","some","group","props","Array","isArray","Tag","NodeSet","extend","styleTags","remove","rm","parseBlock","found","before","findName","splice","endLeaf","wrap","InlineContext","outer","char","token","resolveMarkers","a","conf","conc","b","wrapA","wrapB","inner","names","Escape","nodes","writeTo","reused","topID","Element","startOff","EmphasisUnderscore","resolve","EmphasisAsterisk","LinkStart","ImageStart","InlineDelimiter","side","Escapable","Punctuation","RegExp","DefaultInline","escaped","append","Entity","exec","InlineCode","curSize","HTMLTag","url","URL","comment","Comment","procInst","ProcessingInstruction","Emphasis","pBefore","pAfter","sBefore","sAfter","leftFlanking","rightFlanking","canOpen","canClose","HardBreak","Link","Image","LinkEnd","parts","part","takeContent","link","finishLink","j","startPos","endPos","unshift","dest","label","LinkTitle","requireNonWS","min","LinkLabel","addDelimiter","open","close","emp","closeSize","k","element","keep","findOpeningDelimiter","startIndex","elements","eI","NotLast","fragment","fragmentEnd","cursor","nextFragment","read","c","rPos","parent","childAfter","cur","fragEnd","openEnd","blockI","prevEnd","prevI","isAnonymous","add","is","markdownHighlighting","tags","keys","map","n","leftOverSpace","nextPos","parseCode","codeParser","htmlParser","parseMixed","info","infoNode","getChild","overlay","StrikethroughDelim","Strikethrough","parseRow","startI","cellStart","cellEnd","esc","parseCell","hasPipe","str","delimiterLine","TableParser","rows","lineText","firstRow","firstCount","Table","TaskParser","TaskList","GFM","parseSubSuper","Superscript","Subscript","Emoji","match","data","defineLanguageFacet","commentTokens","headingProp","commonmark","foldNodeProp","isHeading","state","doc","lineAt","indentNodeProp","languageDataProp","findSectionEnd","headerNode","level","heading","headerIndent","foldService","syntaxTree","resolveInner","mkLang","Language","commonmarkLanguage","extended","markdownLanguage","getCodeParser","languages","defaultLanguage","LanguageDescription","support","language","ParseContext","load","Context","spaceBefore","spaceAfter","item","blank","maxWidth","marker","number","String","itemNumber","getContext","context","replace","sliceString","renumberList","changes","prev","insert","insertNewlineContinueMarkup","dispatch","changeByRange","range","empty","isActiveAt","emptyLine","delTo","EditorSelection","lineBreak","prevLine","quoted","index","continued","charAt","update","scrollIntoView","userEvent","isMark","contextNodeForDelete","scan","childBefore","lastChild","deleteMarkupBackward","spaceEnd","markdownKeymap","key","run","htmlNoMatch","html","matchClosingTags","markdown","codeLanguages","defaultCodeLanguage","addKeymap","extensions","defaultCode","LanguageSupport","Prec","keymap"],"sourceRoot":""}