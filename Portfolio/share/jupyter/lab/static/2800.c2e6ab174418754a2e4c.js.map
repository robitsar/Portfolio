{"version":3,"file":"2800.c2e6ab174418754a2e4c.js?v=c2e6ab174418754a2e4c","mappings":"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","sources":["webpack://@jupyterlab/application-top/./node_modules/crelt/index.es.js","webpack://@jupyterlab/application-top/./node_modules/@codemirror/search/dist/index.js"],"sourcesContent":["export default function crelt() {\n  var elt = arguments[0]\n  if (typeof elt == \"string\") elt = document.createElement(elt)\n  var i = 1, next = arguments[1]\n  if (next && typeof next == \"object\" && next.nodeType == null && !Array.isArray(next)) {\n    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {\n      var value = next[name]\n      if (typeof value == \"string\") elt.setAttribute(name, value)\n      else if (value != null) elt[name] = value\n    }\n    i++\n  }\n  for (; i < arguments.length; i++) add(elt, arguments[i])\n  return elt\n}\n\nfunction add(elt, child) {\n  if (typeof child == \"string\") {\n    elt.appendChild(document.createTextNode(child))\n  } else if (child == null) {\n  } else if (child.nodeType != null) {\n    elt.appendChild(child)\n  } else if (Array.isArray(child)) {\n    for (var i = 0; i < child.length; i++) add(elt, child[i])\n  } else {\n    throw new RangeError(\"Unsupported child node: \" + child)\n  }\n}\n","import { showPanel, EditorView, getPanel, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { codePointAt, fromCodePoint, codePointSize, StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, RangeSetBuilder, Prec, EditorState, findClusterBreak } from '@codemirror/state';\nimport elt from 'crelt';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize, test) {\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += codePointSize(next);\n            let norm = this.normalize(str);\n            for (let i = 0, pos = start;; i++) {\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos);\n                if (match) {\n                    this.value = match;\n                    return this;\n                }\n                if (i == norm.length - 1)\n                    break;\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                    pos++;\n            }\n        }\n    }\n    match(code, pos) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: pos + 1 };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: pos + 1 };\n            else\n                this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferPos))\n            match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\")\n    SearchCursor.prototype[Symbol.iterator] = function () { return this; };\n\nconst empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\nclass RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */\n        this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length)\n                    this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&\n                    (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =\n        function () { return this; };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length)\n        return pos;\n    let line = text.lineAt(pos), next;\n    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)\n        pos++;\n    return pos;\n}\n\nfunction createLineDialog(view) {\n    let input = elt(\"input\", { class: \"cm-textfield\", name: \"line\" });\n    let dom = elt(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event) => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                view.dispatch({ effects: dialogEffect.of(false) });\n                view.focus();\n            }\n            else if (event.keyCode == 13) { // Enter\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event) => {\n            event.preventDefault();\n            go();\n        }\n    }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        view.dispatch({\n            effects: dialogEffect.of(false),\n            selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n            scrollIntoView: true\n        });\n        view.focus();\n    }\n    return { dom };\n}\nconst dialogEffect = /*@__PURE__*/StateEffect.define();\nconst dialogField = /*@__PURE__*/StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/\nconst gotoLine = view => {\n    let panel = getPanel(view, createLineDialog);\n    if (!panel) {\n        let effects = [dialogEffect.of(true)];\n        if (view.state.field(dialogField, false) == null)\n            effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n        view.dispatch({ effects });\n        panel = getPanel(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").focus();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": { fontSize: \"80%\" }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == CharCategory.Word\n        && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to)\n                    && insideWord(check, state, range.from, range.to)))\n                    return Decoration.none;\n            }\n            else {\n                query = state.sliceDoc(range.from, range.to).trim();\n                if (!query)\n                    return Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.next().done) {\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch }) => {\n    let { selection } = state;\n    let newSel = EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection))\n        return false;\n    dispatch(state.update({ selection: newSel }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n        cursor.next();\n        if (cursor.done) {\n            if (cycled)\n                return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        }\n        else {\n            if (cycled && ranges.some(r => r.from == cursor.value.from))\n                continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)\n                    continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/\nconst selectNextOccurrence = ({ state, dispatch }) => {\n    let { ranges } = state.selection;\n    if (ranges.some(sel => sel.from === sel.to))\n        return selectWord({ state, dispatch });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))\n        return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range)\n        return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),\n        effects: EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\n\nconst searchConfigFacet = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            wholeWord: false,\n            createPanel: view => new SearchPanel(view),\n            scrollToMatch: range => EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/\nfunction search(config) {\n    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/\nclass SearchQuery {\n    /**\n    Create a query object.\n    */\n    constructor(config) {\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n    }\n    /**\n    @internal\n    */\n    unquote(text) {\n        return this.literal ? text :\n            text.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&\n            this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */\n    create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */\n    getCursor(state, from = 0, to) {\n        let st = state.doc ? state : EditorState.create({ doc: state });\n        if (to == null)\n            to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec) {\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, state, from, to) {\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos) => {\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word ||\n            categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) &&\n            (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word ||\n                categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec) {\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done)\n            cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* FindPrev.ChunkSize */;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, state, from, to) {\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice(findClusterBreak(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, findClusterBreak(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match) => !match[0].length ||\n        (categorizer(charBefore(match.input, match.index)) != CharCategory.Word ||\n            categorizer(charAfter(match.input, match.index)) != CharCategory.Word) &&\n            (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word ||\n                categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done)\n            cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace.replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\"\n            : i == \"&\" ? result.match[0]\n                : i != \"0\" && +i < result.match.length ? result.match[i]\n                    : m));\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/\nconst setSearchQuery = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst searchState = /*@__PURE__*/StateField.define({\n    create(state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setSearchQuery))\n                value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/\nfunction getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/\nfunction searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid)\n            return Decoration.none;\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next)\n        return false;\n    let selection = EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, next), config.scrollToMatch(selection.main)],\n        userEvent: \"select.search\"\n    });\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev)\n        return false;\n    let selection = EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, prev), config.scrollToMatch(selection.main)],\n        userEvent: \"select.search\"\n    });\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly)\n        return false;\n    let next = query.nextMatch(state, from, from);\n    if (!next)\n        return false;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = EditorSelection.single(next.from - off, next.to - off);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main));\n    }\n    view.dispatch({\n        changes, selection, effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {\n    if (view.state.readOnly)\n        return false;\n    let changes = query.matchAll(view.state, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText)\n        return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        wholeWord: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _d !== void 0 ? _d : config.wholeWord\n    });\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let panel = getPanel(view, createSearchPanel);\n        if (!panel)\n            return false;\n        let searchInput = panel.dom.querySelector(\"[main-field]\");\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid)\n                view.dispatch({ effects: setSearchQuery.of(query) });\n            searchInput.focus();\n            searchInput.select();\n        }\n    }\n    else {\n        view.dispatch({ effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)\n            ] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Alt-g\", run: gotoLine },\n    { key: \"Mod-d\", run: selectNextOccurrence, preventDefault: true },\n];\nclass SearchPanel {\n    constructor(view) {\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = elt(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = elt(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return elt(\"button\", { class: \"cm-button\", name, onclick, type: \"button\" }, content);\n        }\n        this.dom = elt(\"div\", { onkeydown: (e) => this.keydown(e), class: \"cm-search\" }, [\n            this.searchField,\n            button(\"next\", () => findNext(view), [phrase(view, \"next\")]),\n            button(\"prev\", () => findPrevious(view), [phrase(view, \"previous\")]),\n            button(\"select\", () => selectMatches(view), [phrase(view, \"all\")]),\n            elt(\"label\", null, [this.caseField, phrase(view, \"match case\")]),\n            elt(\"label\", null, [this.reField, phrase(view, \"regexp\")]),\n            elt(\"label\", null, [this.wordField, phrase(view, \"by word\")]),\n            ...view.state.readOnly ? [] : [\n                elt(\"br\"),\n                this.replaceField,\n                button(\"replace\", () => replaceNext(view), [phrase(view, \"replace\")]),\n                button(\"replaceAll\", () => replaceAll(view), [phrase(view, \"replace all\")])\n            ],\n            elt(\"button\", {\n                name: \"close\",\n                onclick: () => closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\"×\"])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value,\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({ effects: setSearchQuery.of(query) });\n        }\n    }\n    keydown(e) {\n        if (runScopeHandlers(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        }\n        else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)\n            for (let effect of tr.effects) {\n                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))\n                    this.setQuery(effect.value);\n            }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() { return 80; }\n    get top() { return this.view.state.facet(searchConfigFacet).top; }\n}\nfunction phrase(view, phrase) { return view.state.phrase(phrase); }\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/Prec.lowest(searchHighlighter),\n    baseTheme\n];\n\nexport { RegExpCursor, SearchCursor, SearchQuery, closeSearchPanel, findNext, findPrevious, getSearchQuery, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, search, searchKeymap, searchPanelOpen, selectMatches, selectNextOccurrence, selectSelectionMatches, setSearchQuery };\n"],"names":["crelt","elt","arguments","document","createElement","i","next","nodeType","Array","isArray","name","Object","prototype","hasOwnProperty","call","value","setAttribute","length","add","child","appendChild","createTextNode","RangeError","basicNormalize","String","normalize","x","SearchCursor","constructor","text","query","from","to","test","this","done","matches","buffer","bufferPos","iter","iterRange","bufferStart","peek","codePointAt","pop","nextOverlapping","str","fromCodePoint","start","codePointSize","norm","pos","code","charCodeAt","match","index","keep","splice","push","Symbol","iterator","empty","exec","baseFlags","unicode","RegExpCursor","options","curLine","MultilineRegExpCursor","re","RegExp","ignoreCase","startLine","lineAt","curLineStart","matchPos","toCharEnd","getLine","skip","lineBreak","slice","nextLine","off","lastIndex","flattened","WeakMap","FlattenedDoc","static","doc","cached","get","flat","sliceString","set","cachedFrom","chunkEnd","validRegExp","source","_a","line","createLineDialog","view","input","class","dom","onkeydown","event","keyCode","preventDefault","dispatch","effects","dialogEffect","of","focus","go","onsubmit","state","phrase","type","selection","main","head","sign","ln","cl","percent","col","number","pc","lines","Math","round","docLine","max","min","EditorSelection","scrollIntoView","StateEffect","dialogField","StateField","create","update","tr","e","is","provide","f","showPanel","val","gotoLine","panel","getPanel","field","baseTheme$1","querySelector","EditorView","padding","fontSize","defaultHighlightOptions","highlightWordAroundCursor","minSelectionLength","maxMatches","wholeWords","highlightConfig","Facet","combine","combineConfig","a","b","highlightSelectionMatches","ext","defaultTheme","matchHighlighter","matchDeco","Decoration","mainMatchDeco","insideWordBoundaries","check","sliceDoc","CharCategory","insideWord","ViewPlugin","decorations","getDeco","selectionSet","docChanged","viewportChanged","conf","facet","sel","ranges","range","word","wordAt","charCategorizer","len","trim","deco","part","visibleRanges","cursor","v","backgroundColor","selectWord","newSel","map","mainIndex","eq","findNextOccurrence","fullWord","cycled","some","r","selectNextOccurrence","searchedText","addRange","searchConfigFacet","configs","top","caseSensitive","literal","wholeWord","createPanel","SearchPanel","scrollToMatch","search","config","searchExtensions","SearchQuery","regexp","replace","valid","unquoted","unquote","_","ch","other","RegExpQuery","StringQuery","getCursor","st","EditorState","regexpCursor","stringCursor","QueryType","spec","undefined","toLowerCase","stringWordTest","categorizer","buf","bufPos","charBefore","charAfter","super","nextMatch","curFrom","curTo","prevMatchInRange","prevMatch","getReplacement","_result","matchAll","limit","highlight","regexpWordTest","findClusterBreak","_from","_to","size","result","m","setSearchQuery","togglePanel","searchState","SearchState","defaultQuery","effect","createSearchPanel","getSearchQuery","curState","searchPanelOpen","matchMark","selectedMatchMark","searchHighlighter","startState","builder","RangeSetBuilder","l","selected","finish","searchCommand","openSearchPanel","findNext","announceMatch","userEvent","findPrevious","prev","selectMatches","selectSelectionMatches","cur","replaceNext","readOnly","changes","replacement","toText","insert","replaceAll","announceText","fallback","_b","_c","_d","selText","searchInput","root","activeElement","select","closeSearchPanel","contains","searchKeymap","key","run","scope","shift","commit","bind","searchField","placeholder","form","onchange","onkeyup","replaceField","caseField","checked","reField","wordField","button","onclick","content","keydown","runScopeHandlers","target","shiftKey","transactions","setQuery","mount","AnnounceMargin","Break","lineEnd","end","baseTheme","position","right","border","font","margin","marginRight","whiteSpace","Prec"],"sourceRoot":""}